{
  "config": {
    "id": "interview-qa",
    "name": "Interview Q&A",
    "description": "Comprehensive technical interview questions and answers covering various domains.",
    "icon": "üéØ",
    "enabled": true
  },
  "content": [
    {
      "id": "database-performance-qa",
      "title": "üóÑÔ∏è Database Performance & Optimization Q&A",
      "sections": [
        {
          "name": "Slow Insert Performance",
          "text": "# Database Insert Performance Issues\n\n**Question:** If a database takes long to insert a new record due to the table having millions of records, what could be the approach to improve the performance?\n\n## **Answer:**\n\n### **Root Causes:**\n- **Index Overhead**: Too many indexes slow down INSERT operations\n- **Lock Contention**: Table-level locks during inserts\n- **Disk I/O**: Slow disk writes due to fragmentation\n- **Constraint Checks**: Foreign key and unique constraint validations\n- **Trigger Execution**: Complex triggers running on each insert\n\n### **Performance Optimization Strategies:**\n\n#### **1. Index Optimization**\n- **Remove Unused Indexes**: Drop indexes that aren't used for queries\n- **Use Partial Indexes**: Create indexes only for frequently queried data\n- **Consider Index Types**: Use appropriate index types (B-tree, Hash, etc.)\n\n#### **2. Batch Operations**\n- **Bulk Inserts**: Use `INSERT INTO ... VALUES (...), (...), (...)`\n- **Batch Processing**: Insert multiple records in single transaction\n- **Prepared Statements**: Reduce parsing overhead\n\n#### **3. Database Configuration**\n- **Increase Buffer Pool**: Allocate more memory for caching\n- **Optimize Log Files**: Use faster storage for transaction logs\n- **Tune Write-Ahead Logging**: Optimize WAL settings\n\n#### **4. Table Design**\n- **Partitioning**: Split large tables into smaller partitions\n- **Denormalization**: Reduce JOIN operations for better performance\n- **Data Types**: Use appropriate data types to reduce storage\n\n#### **5. Hardware Optimization**\n- **SSD Storage**: Use solid-state drives for better I/O performance\n- **RAID Configuration**: Optimize disk array setup\n- **Memory**: Increase RAM for better caching\n\n### **Monitoring & Analysis:**\n- **Query Execution Plans**: Analyze INSERT performance\n- **Index Usage Statistics**: Monitor index utilization\n- **Lock Wait Times**: Identify contention issues\n- **Disk I/O Metrics**: Monitor storage performance",
          "code": "-- Example: Batch Insert Optimization\n-- Instead of multiple single inserts:\nINSERT INTO users (name, email) VALUES ('John', 'john@example.com');\nINSERT INTO users (name, email) VALUES ('Jane', 'jane@example.com');\nINSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com');\n\n-- Use batch insert:\nINSERT INTO users (name, email) VALUES \n    ('John', 'john@example.com'),\n    ('Jane', 'jane@example.com'),\n    ('Bob', 'bob@example.com');\n\n-- Example: Index Optimization\n-- Remove unused indexes\nDROP INDEX idx_unused_column ON large_table;\n\n-- Create partial index for active records only\nCREATE INDEX idx_active_users ON users(email) WHERE status = 'active';\n\n-- Example: Table Partitioning (PostgreSQL)\nCREATE TABLE orders (\n    id SERIAL,\n    order_date DATE,\n    customer_id INT,\n    amount DECIMAL\n) PARTITION BY RANGE (order_date);\n\nCREATE TABLE orders_2023 PARTITION OF orders\n    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');\n\n-- Example: Prepared Statement (MySQL)\nPREPARE stmt FROM 'INSERT INTO users (name, email) VALUES (?, ?)';\nSET @name = 'John', @email = 'john@example.com';\nEXECUTE stmt USING @name, @email;\nDEALLOCATE PREPARE stmt;"
        },
        {
          "name": "Query Optimization",
          "text": "# Database Query Optimization\n\n**Question:** How would you optimize a slow-running query that takes 30 seconds to return results?\n\n## **Answer:**\n\n### **Step 1: Analysis & Profiling**\n- **EXPLAIN PLAN**: Analyze query execution plan\n- **Identify Bottlenecks**: Look for full table scans, expensive joins\n- **Monitor Resources**: Check CPU, memory, and I/O usage\n- **Index Usage**: Verify if indexes are being used effectively\n\n### **Step 2: Query Structure Optimization**\n- **Rewrite Subqueries**: Convert to JOINs where possible\n- **Limit Result Set**: Use WHERE clauses to filter early\n- **Avoid SELECT ***: Only select needed columns\n- **Optimize JOINs**: Use appropriate JOIN types and order\n\n### **Step 3: Index Strategy**\n- **Create Missing Indexes**: Add indexes for WHERE and JOIN columns\n- **Composite Indexes**: Create multi-column indexes for complex queries\n- **Covering Indexes**: Include all needed columns in index\n- **Partial Indexes**: Create indexes for filtered data subsets\n\n### **Step 4: Database Configuration**\n- **Buffer Pool Size**: Increase memory allocation\n- **Query Cache**: Enable and tune query caching\n- **Connection Pooling**: Optimize connection management\n- **Statistics**: Update table statistics regularly\n\n### **Step 5: Application-Level Optimization**\n- **Pagination**: Implement cursor-based pagination\n- **Caching**: Cache frequently accessed data\n- **Read Replicas**: Use read replicas for reporting queries\n- **Data Archiving**: Move old data to archive tables",
          "code": "-- Example: Query Analysis\n-- Before optimization (slow query)\nEXPLAIN ANALYZE\nSELECT * FROM orders o\nJOIN customers c ON o.customer_id = c.id\nWHERE o.order_date > '2023-01-01'\nORDER BY o.total_amount DESC;\n\n-- After optimization (faster query)\n-- 1. Add covering index\nCREATE INDEX idx_orders_covering ON orders(customer_id, order_date, total_amount);\n\n-- 2. Optimized query with specific columns\nEXPLAIN ANALYZE\nSELECT o.id, o.order_date, o.total_amount, c.name\nFROM orders o\nJOIN customers c ON o.customer_id = c.id\nWHERE o.order_date > '2023-01-01'\nORDER BY o.total_amount DESC\nLIMIT 100;\n\n-- Example: Subquery to JOIN conversion\n-- Before (subquery)\nSELECT * FROM customers\nWHERE id IN (\n    SELECT customer_id FROM orders \n    WHERE order_date > '2023-01-01'\n);\n\n-- After (JOIN)\nSELECT DISTINCT c.*\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE o.order_date > '2023-01-01';\n\n-- Example: Composite Index\nCREATE INDEX idx_orders_composite ON orders(customer_id, order_date, status);\n\n-- Example: Partial Index\nCREATE INDEX idx_active_orders ON orders(order_date, total_amount)\nWHERE status = 'active';"
        },
        {
          "name": "Database Scaling",
          "text": "# Database Scaling Strategies\n\n**Question:** How would you scale a database that's experiencing performance issues due to high read/write load?\n\n## **Answer:**\n\n### **Vertical Scaling (Scale Up)**\n- **Hardware Upgrade**: Increase CPU, RAM, and storage\n- **Database Tuning**: Optimize configuration parameters\n- **Memory Allocation**: Increase buffer pool and cache sizes\n- **Storage Optimization**: Use faster SSDs and RAID configurations\n\n### **Horizontal Scaling (Scale Out)**\n\n#### **1. Read Replicas**\n- **Master-Slave**: One master for writes, multiple slaves for reads\n- **Load Balancing**: Distribute read queries across replicas\n- **Replication Lag**: Monitor and minimize replication delay\n- **Failover**: Implement automatic failover mechanisms\n\n#### **2. Database Sharding**\n- **Horizontal Partitioning**: Split data across multiple databases\n- **Shard Key Strategy**: Choose appropriate sharding keys\n- **Cross-Shard Queries**: Handle queries spanning multiple shards\n- **Data Rebalancing**: Implement shard rebalancing strategies\n\n#### **3. Caching Layer**\n- **Redis/Memcached**: Cache frequently accessed data\n- **Application-Level Caching**: Cache query results in application\n- **CDN**: Use content delivery networks for static data\n- **Cache Invalidation**: Implement proper cache invalidation\n\n### **Microservices Database Pattern**\n- **Database per Service**: Each service owns its data\n- **Event Sourcing**: Store events instead of current state\n- **CQRS**: Separate read and write models\n- **Saga Pattern**: Handle distributed transactions\n\n### **Cloud Database Solutions**\n- **Managed Services**: Use cloud provider database services\n- **Auto-Scaling**: Leverage automatic scaling features\n- **Multi-Region**: Deploy across multiple regions\n- **Backup & Recovery**: Implement robust backup strategies",
          "code": "-- Example: Read Replica Setup (PostgreSQL)\n-- Master configuration\n-- postgresql.conf\nwal_level = replica\nmax_wal_senders = 3\nmax_replication_slots = 3\n\n-- Slave configuration\n-- recovery.conf\nstandby_mode = 'on'\nprimary_conninfo = 'host=master_host port=5432 user=replicator'\n\n-- Example: Database Sharding (MySQL)\n-- Shard 1: Users 1-1000000\nCREATE TABLE users_shard_1 (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    email VARCHAR(100)\n);\n\n-- Shard 2: Users 1000001-2000000\nCREATE TABLE users_shard_2 (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    email VARCHAR(100)\n);\n\n-- Sharding function\nDELIMITER //\nCREATE FUNCTION get_shard_id(user_id INT) RETURNS INT\nBEGIN\n    RETURN (user_id - 1) DIV 1000000 + 1;\nEND //\nDELIMITER ;\n\n-- Example: Redis Caching\n-- Cache user data\nSET user:123 '{\"name\":\"John\",\"email\":\"john@example.com\"}' EX 3600\n\n-- Get cached data\nGET user:123\n\n-- Example: Connection Pooling (Java)\n// HikariCP configuration\nHikariConfig config = new HikariConfig();\nconfig.setMaximumPoolSize(20);\nconfig.setMinimumIdle(5);\nconfig.setConnectionTimeout(30000);\nconfig.setIdleTimeout(600000);\nconfig.setMaxLifetime(1800000);"
        }
      ]
    },
    {
      "id": "microservices-communication-qa",
      "title": "üîó Microservices Communication Q&A",
      "sections": [
        {
          "name": "Service Communication Failures",
          "text": "# Microservices Communication Failure Handling\n\n**Question:** What are the strategies you use to handle inter-service communication failures in mid-requests of microservices implementation?\n\n## **Answer:**\n\n### **1. Circuit Breaker Pattern**\n- **Purpose**: Prevent cascading failures by breaking the circuit when service is down\n- **States**: Closed (normal), Open (failing), Half-Open (testing)\n- **Implementation**: Hystrix, Resilience4j, or custom implementation\n- **Benefits**: Fast failure detection and recovery\n\n### **2. Retry Mechanisms**\n- **Exponential Backoff**: Gradually increase delay between retries\n- **Jitter**: Add randomness to prevent thundering herd\n- **Max Retries**: Limit number of retry attempts\n- **Retryable Errors**: Only retry on specific error types\n\n### **3. Timeout Configuration**\n- **Connection Timeout**: Time to establish connection\n- **Read Timeout**: Time to wait for response\n- **Circuit Breaker Timeout**: Time before trying failed service again\n- **Graceful Degradation**: Fallback to cached/default data\n\n### **4. Bulkhead Pattern**\n- **Resource Isolation**: Separate thread pools for different services\n- **Connection Pooling**: Dedicated connection pools per service\n- **Memory Isolation**: Prevent one service failure from affecting others\n- **CPU Isolation**: Use separate CPU cores for critical services\n\n### **5. Fallback Strategies**\n- **Default Values**: Return sensible defaults when service fails\n- **Cached Data**: Use stale but available cached data\n- **Alternative Services**: Route to backup services\n- **Graceful Degradation**: Reduce functionality but maintain core features\n\n### **6. Monitoring & Observability**\n- **Health Checks**: Regular service health monitoring\n- **Metrics**: Track success/failure rates, response times\n- **Distributed Tracing**: Track requests across services\n- **Alerting**: Immediate notification of service failures\n\n### **7. Event-Driven Architecture**\n- **Asynchronous Communication**: Use message queues/event streams\n- **Event Sourcing**: Store events instead of current state\n- **Saga Pattern**: Handle distributed transactions\n- **Compensating Actions**: Rollback operations across services",
          "code": "// Example: Circuit Breaker Implementation (Java)\n@Component\npublic class UserServiceClient {\n    \n    private final CircuitBreaker circuitBreaker;\n    \n    public UserServiceClient() {\n        this.circuitBreaker = CircuitBreaker.ofDefaults(\"userService\")\n            .toBuilder()\n            .failureRateThreshold(50)\n            .waitDurationInOpenState(Duration.ofSeconds(30))\n            .slidingWindowSize(10)\n            .build();\n    }\n    \n    public User getUser(String userId) {\n        return circuitBreaker.executeSupplier(() -> {\n            try {\n                return userService.getUser(userId);\n            } catch (Exception e) {\n                return getDefaultUser(userId); // Fallback\n            }\n        });\n    }\n    \n    private User getDefaultUser(String userId) {\n        return User.builder()\n            .id(userId)\n            .name(\"Unknown User\")\n            .email(\"unknown@example.com\")\n            .build();\n    }\n}\n\n// Example: Retry with Exponential Backoff\n@Retryable(\n    value = {ConnectException.class, SocketTimeoutException.class},\n    maxAttempts = 3,\n    backoff = @Backoff(delay = 1000, multiplier = 2)\n)\npublic ResponseEntity<String> callExternalService(String data) {\n    return restTemplate.postForEntity(\"/external-service\", data, String.class);\n}\n\n// Example: Timeout Configuration\n@Configuration\npublic class RestTemplateConfig {\n    \n    @Bean\n    public RestTemplate restTemplate() {\n        HttpComponentsClientHttpRequestFactory factory = \n            new HttpComponentsClientHttpRequestFactory();\n        factory.setConnectTimeout(5000); // 5 seconds\n        factory.setReadTimeout(10000);    // 10 seconds\n        \n        return new RestTemplate(factory);\n    }\n}\n\n// Example: Bulkhead Pattern\n@Service\npublic class OrderService {\n    \n    @Async(\"orderTaskExecutor\")\n    public CompletableFuture<Order> processOrder(OrderRequest request) {\n        // Process order in dedicated thread pool\n        return CompletableFuture.completedFuture(\n            orderProcessor.process(request)\n        );\n    }\n}\n\n@Configuration\n@EnableAsync\npublic class AsyncConfig {\n    \n    @Bean(\"orderTaskExecutor\")\n    public Executor orderTaskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(100);\n        executor.setThreadNamePrefix(\"OrderService-\");\n        executor.initialize();\n        return executor;\n    }\n}"
        },
        {
          "name": "Service Discovery",
          "text": "# Service Discovery & Load Balancing\n\n**Question:** How do you handle service discovery and load balancing in a microservices architecture?\n\n## **Answer:**\n\n### **Service Discovery Patterns**\n\n#### **1. Client-Side Discovery**\n- **Service Registry**: Central registry (Eureka, Consul, etcd)\n- **Client Responsibility**: Client queries registry and selects service instance\n- **Load Balancing**: Client implements load balancing logic\n- **Benefits**: Simple implementation, no additional network hop\n\n#### **2. Server-Side Discovery**\n- **Load Balancer**: Central load balancer (AWS ALB, NGINX, HAProxy)\n- **Service Registry**: Load balancer queries registry\n- **Client Simplicity**: Client only knows load balancer endpoint\n- **Benefits**: Centralized load balancing, client simplicity\n\n### **Service Registry Features**\n- **Health Checks**: Regular health monitoring of services\n- **Service Registration**: Automatic service registration/deregistration\n- **Metadata**: Store service metadata (version, tags, etc.)\n- **High Availability**: Multiple registry instances for fault tolerance\n\n### **Load Balancing Strategies**\n- **Round Robin**: Distribute requests evenly across instances\n- **Weighted Round Robin**: Assign different weights to instances\n- **Least Connections**: Route to instance with fewest active connections\n- **IP Hash**: Route based on client IP hash\n- **Geographic**: Route based on geographic location\n\n### **Service Mesh**\n- **Istio**: Service mesh for Kubernetes\n- **Envoy Proxy**: Sidecar proxy for service communication\n- **Traffic Management**: Advanced routing and load balancing\n- **Security**: mTLS, authentication, authorization\n- **Observability**: Metrics, logging, tracing\n\n### **Implementation Considerations**\n- **Service Registration**: Automatic registration on startup\n- **Health Checks**: Regular health monitoring\n- **Graceful Shutdown**: Proper deregistration on shutdown\n- **Configuration**: Externalized configuration management\n- **Security**: Secure service-to-service communication",
          "code": "// Example: Eureka Service Registration (Spring Boot)\n@SpringBootApplication\n@EnableEurekaClient\npublic class UserServiceApplication {\n    \n    public static void main(String[] args) {\n        SpringApplication.run(UserServiceApplication.class, args);\n    }\n}\n\n// application.yml\nspring:\n  application:\n    name: user-service\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        service-name: ${spring.application.name}\n        health-check-interval: 15s\n        health-check-critical-timeout: 30s\n\n// Example: Service Discovery Client\n@Service\npublic class OrderServiceClient {\n    \n    @Autowired\n    private DiscoveryClient discoveryClient;\n    \n    @Autowired\n    private RestTemplate restTemplate;\n    \n    public Order createOrder(OrderRequest request) {\n        List<ServiceInstance> instances = \n            discoveryClient.getInstances(\"order-service\");\n        \n        if (instances.isEmpty()) {\n            throw new ServiceUnavailableException(\"Order service not available\");\n        }\n        \n        ServiceInstance instance = instances.get(0);\n        String url = String.format(\"http://%s:%d/orders\", \n            instance.getHost(), instance.getPort());\n        \n        return restTemplate.postForObject(url, request, Order.class);\n    }\n}\n\n// Example: Load Balancer Configuration (NGINX)\nupstream user_service {\n    server user-service-1:8080 weight=3;\n    server user-service-2:8080 weight=2;\n    server user-service-3:8080 weight=1;\n    \n    # Health checks\n    health_check interval=10s fails=3 passes=2;\n}\n\nserver {\n    listen 80;\n    \n    location /api/users/ {\n        proxy_pass http://user_service;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n}\n\n// Example: Istio Service Mesh Configuration\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: user-service\nspec:\n  http:\n  - match:\n    - headers:\n        version:\n          exact: v2\n    route:\n    - destination:\n        host: user-service\n        subset: v2\n  - route:\n    - destination:\n        host: user-service\n        subset: v1\n      weight: 90\n    - destination:\n        host: user-service\n        subset: v2\n      weight: 10"
        },
        {
          "name": "Distributed Transactions",
          "text": "# Distributed Transactions in Microservices\n\n**Question:** How do you handle distributed transactions across multiple microservices?\n\n## **Answer:**\n\n### **Challenges with Distributed Transactions**\n- **ACID Properties**: Difficult to maintain across services\n- **Network Failures**: Network partitions and timeouts\n- **Performance**: Two-phase commit is slow and blocking\n- **Availability**: Reduces system availability\n- **Complexity**: Complex failure handling and recovery\n\n### **Saga Pattern**\n\n#### **1. Choreography-Based Saga**\n- **Event-Driven**: Services communicate via events\n- **Decentralized**: No central coordinator\n- **Eventual Consistency**: Eventually consistent state\n- **Benefits**: Loose coupling, high availability\n- **Drawbacks**: Complex debugging, difficult to track\n\n#### **2. Orchestration-Based Saga**\n- **Central Coordinator**: Central service orchestrates transactions\n- **Command Pattern**: Coordinator sends commands to services\n- **State Management**: Coordinator maintains transaction state\n- **Benefits**: Easy to understand, centralized control\n- **Drawbacks**: Single point of failure, tight coupling\n\n### **Compensating Actions**\n- **Compensating Transactions**: Actions that undo previous operations\n- **Idempotent Operations**: Safe to retry operations\n- **Event Sourcing**: Store events instead of current state\n- **CQRS**: Separate read and write models\n\n### **Event Sourcing**\n- **Event Store**: Store all events that happened\n- **Replay**: Replay events to reconstruct current state\n- **Audit Trail**: Complete history of all changes\n- **Temporal Queries**: Query state at any point in time\n\n### **Implementation Strategies**\n- **Idempotency**: Ensure operations can be safely retried\n- **Eventual Consistency**: Accept temporary inconsistency\n- **Compensation**: Implement compensating actions\n- **Monitoring**: Track transaction state and failures\n- **Testing**: Test failure scenarios and recovery\n\n### **Best Practices**\n- **Design for Failure**: Assume services will fail\n- **Idempotent Operations**: Make operations safe to retry\n- **Timeout Handling**: Implement proper timeouts\n- **Monitoring**: Track transaction success/failure rates\n- **Documentation**: Document transaction boundaries and compensation logic",
          "code": "// Example: Choreography-Based Saga\n// Order Service\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private ApplicationEventPublisher eventPublisher;\n    \n    public void createOrder(OrderRequest request) {\n        Order order = new Order(request);\n        orderRepository.save(order);\n        \n        // Publish event for payment service\n        eventPublisher.publishEvent(new OrderCreatedEvent(order.getId(), request.getAmount()));\n    }\n    \n    @EventListener\n    public void handlePaymentFailed(PaymentFailedEvent event) {\n        Order order = orderRepository.findById(event.getOrderId());\n        order.cancel();\n        orderRepository.save(order);\n        \n        // Publish compensation event\n        eventPublisher.publishEvent(new OrderCancelledEvent(order.getId()));\n    }\n}\n\n// Payment Service\n@Service\npublic class PaymentService {\n    \n    @Autowired\n    private ApplicationEventPublisher eventPublisher;\n    \n    @EventListener\n    public void handleOrderCreated(OrderCreatedEvent event) {\n        try {\n            Payment payment = processPayment(event.getAmount());\n            eventPublisher.publishEvent(new PaymentSucceededEvent(event.getOrderId(), payment.getId()));\n        } catch (PaymentException e) {\n            eventPublisher.publishEvent(new PaymentFailedEvent(event.getOrderId(), e.getMessage()));\n        }\n    }\n}\n\n// Example: Orchestration-Based Saga\n@Service\npublic class OrderSagaOrchestrator {\n    \n    @Autowired\n    private OrderServiceClient orderServiceClient;\n    \n    @Autowired\n    private PaymentServiceClient paymentServiceClient;\n    \n    @Autowired\n    private InventoryServiceClient inventoryServiceClient;\n    \n    public void processOrder(OrderRequest request) {\n        SagaContext context = new SagaContext();\n        \n        try {\n            // Step 1: Create Order\n            Order order = orderServiceClient.createOrder(request);\n            context.setOrderId(order.getId());\n            \n            // Step 2: Process Payment\n            Payment payment = paymentServiceClient.processPayment(order.getAmount());\n            context.setPaymentId(payment.getId());\n            \n            // Step 3: Reserve Inventory\n            inventoryServiceClient.reserveInventory(request.getItems());\n            \n            // All steps succeeded\n            context.setStatus(SagaStatus.COMPLETED);\n            \n        } catch (Exception e) {\n            // Compensate for completed steps\n            compensate(context);\n            context.setStatus(SagaStatus.FAILED);\n        }\n    }\n    \n    private void compensate(SagaContext context) {\n        // Compensate in reverse order\n        if (context.getPaymentId() != null) {\n            paymentServiceClient.refundPayment(context.getPaymentId());\n        }\n        \n        if (context.getOrderId() != null) {\n            orderServiceClient.cancelOrder(context.getOrderId());\n        }\n    }\n}\n\n// Example: Event Sourcing\n@Entity\npublic class OrderAggregate {\n    \n    @Id\n    private String id;\n    private List<DomainEvent> events = new ArrayList<>();\n    \n    public void createOrder(OrderRequest request) {\n        OrderCreatedEvent event = new OrderCreatedEvent(id, request);\n        events.add(event);\n        apply(event);\n    }\n    \n    public void cancelOrder() {\n        OrderCancelledEvent event = new OrderCancelledEvent(id);\n        events.add(event);\n        apply(event);\n    }\n    \n    private void apply(DomainEvent event) {\n        // Apply event to aggregate state\n        if (event instanceof OrderCreatedEvent) {\n            // Update aggregate state\n        } else if (event instanceof OrderCancelledEvent) {\n            // Update aggregate state\n        }\n    }\n    \n    public List<DomainEvent> getUncommittedEvents() {\n        return events;\n    }\n    \n    public void markEventsAsCommitted() {\n        events.clear();\n    }\n}"
        }
      ]
    },
    {
      "id": "system-design-qa",
      "title": "üèóÔ∏è System Design Q&A",
      "sections": [
        {
          "name": "Scalability Patterns",
          "text": "# System Scalability Patterns\n\n**Question:** How would you design a system to handle 1 million concurrent users?\n\n## **Answer:**\n\n### **1. Load Balancing**\n- **Multiple Load Balancers**: Use multiple load balancers for redundancy\n- **Geographic Distribution**: Deploy across multiple regions\n- **DNS Load Balancing**: Use DNS to distribute traffic\n- **Application Load Balancers**: Layer 7 load balancing for intelligent routing\n\n### **2. Horizontal Scaling**\n- **Stateless Services**: Design stateless services for easy scaling\n- **Auto-Scaling**: Implement automatic scaling based on metrics\n- **Container Orchestration**: Use Kubernetes for container management\n- **Microservices**: Break monolith into smaller services\n\n### **3. Caching Strategy**\n- **Multi-Level Caching**: Browser, CDN, Application, Database\n- **Cache Invalidation**: Implement proper cache invalidation\n- **Cache Warming**: Pre-populate cache with frequently accessed data\n- **Distributed Caching**: Use Redis or Memcached for shared cache\n\n### **4. Database Optimization**\n- **Read Replicas**: Use read replicas for read-heavy workloads\n- **Database Sharding**: Partition data across multiple databases\n- **Connection Pooling**: Optimize database connections\n- **Query Optimization**: Optimize slow queries and add indexes\n\n### **5. Asynchronous Processing**\n- **Message Queues**: Use message queues for asynchronous processing\n- **Event-Driven Architecture**: Implement event-driven patterns\n- **Background Jobs**: Move heavy processing to background\n- **WebSockets**: Use WebSockets for real-time communication\n\n### **6. CDN and Static Assets**\n- **Content Delivery Network**: Use CDN for static assets\n- **Asset Optimization**: Compress and optimize static files\n- **Edge Caching**: Cache content at edge locations\n- **Image Optimization**: Use appropriate image formats and sizes\n\n### **7. Monitoring and Observability**\n- **Application Metrics**: Track key performance indicators\n- **Distributed Tracing**: Track requests across services\n- **Log Aggregation**: Centralize and analyze logs\n- **Alerting**: Set up alerts for critical metrics\n\n### **8. Security Considerations**\n- **Rate Limiting**: Implement rate limiting to prevent abuse\n- **DDoS Protection**: Use DDoS protection services\n- **Authentication**: Implement secure authentication\n- **Data Encryption**: Encrypt data in transit and at rest",
          "code": "// Example: Auto-Scaling Configuration (Kubernetes)\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: user-service-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: user-service\n  minReplicas: 3\n  maxReplicas: 100\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n\n// Example: Load Balancer Configuration (NGINX)\nupstream backend {\n    least_conn;\n    server app1.example.com:8080 max_fails=3 fail_timeout=30s;\n    server app2.example.com:8080 max_fails=3 fail_timeout=30s;\n    server app3.example.com:8080 max_fails=3 fail_timeout=30s;\n}\n\nserver {\n    listen 80;\n    \n    location / {\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        \n        # Health checks\n        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;\n    }\n}\n\n// Example: Caching Strategy (Redis)\n@Service\npublic class UserService {\n    \n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n    \n    @Cacheable(value = \"users\", key = \"#userId\")\n    public User getUser(String userId) {\n        return userRepository.findById(userId);\n    }\n    \n    @CacheEvict(value = \"users\", key = \"#user.id\")\n    public User updateUser(User user) {\n        User updatedUser = userRepository.save(user);\n        \n        // Publish cache invalidation event\n        redisTemplate.convertAndSend(\"cache-invalidation\", \n            new CacheInvalidationEvent(\"users\", user.getId()));\n        \n        return updatedUser;\n    }\n}\n\n// Example: Message Queue (RabbitMQ)\n@Component\npublic class OrderProcessor {\n    \n    @RabbitListener(queues = \"order.queue\")\n    public void processOrder(OrderMessage message) {\n        try {\n            // Process order asynchronously\n            Order order = orderService.createOrder(message.getOrderRequest());\n            \n            // Send confirmation email\n            emailService.sendOrderConfirmation(order);\n            \n        } catch (Exception e) {\n            // Send to dead letter queue\n            rabbitTemplate.send(\"order.dlq\", message);\n        }\n    }\n}"
        },
        {
          "name": "Data Consistency",
          "text": "# Data Consistency in Distributed Systems\n\n**Question:** How do you ensure data consistency across multiple services in a distributed system?\n\n## **Answer:**\n\n### **Consistency Models**\n\n#### **1. Strong Consistency (ACID)**\n- **Immediate Consistency**: All nodes see the same data immediately\n- **Use Cases**: Financial transactions, critical business data\n- **Trade-offs**: Higher latency, reduced availability\n- **Implementation**: Two-phase commit, distributed locks\n\n#### **2. Eventual Consistency**\n- **Eventually Consistent**: Data becomes consistent over time\n- **Use Cases**: Social media, content management, analytics\n- **Trade-offs**: Temporary inconsistency, eventual consistency\n- **Implementation**: Event sourcing, CQRS, conflict resolution\n\n#### **3. Weak Consistency**\n- **No Guarantees**: No consistency guarantees\n- **Use Cases**: Real-time data, sensor data, logs\n- **Trade-offs**: Fast performance, no consistency guarantees\n- **Implementation**: Best-effort updates, eventual consistency\n\n### **Consistency Patterns**\n\n#### **1. Event Sourcing**\n- **Event Store**: Store all events that happened\n- **Replay**: Replay events to reconstruct current state\n- **Audit Trail**: Complete history of all changes\n- **Benefits**: Complete audit trail, temporal queries\n\n#### **2. CQRS (Command Query Responsibility Segregation)**\n- **Separate Models**: Different models for reads and writes\n- **Event-Driven**: Commands generate events, queries read from views\n- **Scalability**: Scale reads and writes independently\n- **Benefits**: Better performance, simpler models\n\n#### **3. Saga Pattern**\n- **Distributed Transactions**: Handle transactions across services\n- **Compensating Actions**: Actions that undo previous operations\n- **Eventual Consistency**: Accept temporary inconsistency\n- **Benefits**: Better availability, eventual consistency\n\n### **Conflict Resolution Strategies**\n- **Last Writer Wins**: Use timestamp to resolve conflicts\n- **Vector Clocks**: Use vector clocks for causality\n- **CRDTs**: Use Conflict-free Replicated Data Types\n- **Application Logic**: Use business logic to resolve conflicts\n\n### **Implementation Considerations**\n- **Idempotency**: Ensure operations can be safely retried\n- **Ordering**: Ensure proper ordering of operations\n- **Monitoring**: Track consistency metrics\n- **Testing**: Test consistency scenarios\n- **Documentation**: Document consistency guarantees",
          "code": "// Example: Event Sourcing Implementation\n@Entity\npublic class OrderAggregate {\n    \n    @Id\n    private String id;\n    private OrderStatus status;\n    private List<DomainEvent> events = new ArrayList<>();\n    \n    public void createOrder(OrderRequest request) {\n        OrderCreatedEvent event = new OrderCreatedEvent(id, request);\n        events.add(event);\n        apply(event);\n    }\n    \n    public void cancelOrder() {\n        OrderCancelledEvent event = new OrderCancelledEvent(id);\n        events.add(event);\n        apply(event);\n    }\n    \n    private void apply(DomainEvent event) {\n        if (event instanceof OrderCreatedEvent) {\n            this.status = OrderStatus.CREATED;\n        } else if (event instanceof OrderCancelledEvent) {\n            this.status = OrderStatus.CANCELLED;\n        }\n    }\n    \n    public List<DomainEvent> getUncommittedEvents() {\n        return events;\n    }\n}\n\n// Example: CQRS Implementation\n// Command Side\n@Service\npublic class OrderCommandService {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private EventPublisher eventPublisher;\n    \n    public void createOrder(OrderRequest request) {\n        Order order = new Order(request);\n        orderRepository.save(order);\n        \n        // Publish event for query side\n        eventPublisher.publishEvent(new OrderCreatedEvent(order));\n    }\n}\n\n// Query Side\n@Service\npublic class OrderQueryService {\n    \n    @Autowired\n    private OrderViewRepository orderViewRepository;\n    \n    @EventListener\n    public void handleOrderCreated(OrderCreatedEvent event) {\n        OrderView view = new OrderView(event.getOrder());\n        orderViewRepository.save(view);\n    }\n    \n    public List<OrderView> getOrdersByCustomer(String customerId) {\n        return orderViewRepository.findByCustomerId(customerId);\n    }\n}\n\n// Example: Conflict Resolution with Vector Clocks\npublic class VectorClock {\n    private Map<String, Long> clock = new HashMap<>();\n    \n    public void increment(String nodeId) {\n        clock.put(nodeId, clock.getOrDefault(nodeId, 0L) + 1);\n    }\n    \n    public boolean happensBefore(VectorClock other) {\n        boolean strictlyLess = false;\n        \n        for (String nodeId : clock.keySet()) {\n            long thisTime = clock.get(nodeId);\n            long otherTime = other.clock.getOrDefault(nodeId, 0L);\n            \n            if (thisTime > otherTime) {\n                return false;\n            }\n            if (thisTime < otherTime) {\n                strictlyLess = true;\n            }\n        }\n        \n        return strictlyLess;\n    }\n}\n\n// Example: CRDT Implementation (G-Counter)\npublic class GCounter {\n    private Map<String, Long> counters = new HashMap<>();\n    \n    public void increment(String nodeId) {\n        counters.put(nodeId, counters.getOrDefault(nodeId, 0L) + 1);\n    }\n    \n    public long getValue() {\n        return counters.values().stream().mapToLong(Long::longValue).sum();\n    }\n    \n    public void merge(GCounter other) {\n        for (Map.Entry<String, Long> entry : other.counters.entrySet()) {\n            String nodeId = entry.getKey();\n            long otherValue = entry.getValue();\n            long thisValue = counters.getOrDefault(nodeId, 0L);\n            \n            counters.put(nodeId, Math.max(thisValue, otherValue));\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "security-qa",
      "title": "üîí Security Q&A",
      "sections": [
        {
          "name": "Authentication & Authorization",
          "text": "# Authentication & Authorization\n\n**Question:** How would you implement secure authentication and authorization in a microservices architecture?\n\n## **Answer:**\n\n### **Authentication Strategies**\n\n#### **1. JWT (JSON Web Tokens)**\n- **Stateless**: No server-side session storage\n- **Self-Contained**: Contains user information and permissions\n- **Scalable**: Easy to scale across multiple services\n- **Security**: Signed and optionally encrypted\n\n#### **2. OAuth 2.0**\n- **Authorization Framework**: Industry standard for authorization\n- **Multiple Flows**: Authorization Code, Client Credentials, etc.\n- **Third-Party Integration**: Easy integration with external providers\n- **Granular Permissions**: Fine-grained access control\n\n#### **3. OIDC (OpenID Connect)**\n- **Identity Layer**: Built on top of OAuth 2.0\n- **Standardized**: Industry standard for authentication\n- **User Info**: Provides user information\n- **Single Sign-On**: Enables SSO across applications\n\n### **Authorization Patterns**\n\n#### **1. RBAC (Role-Based Access Control)**\n- **Roles**: Users are assigned roles\n- **Permissions**: Roles have specific permissions\n- **Hierarchical**: Roles can inherit from other roles\n- **Simple**: Easy to understand and implement\n\n#### **2. ABAC (Attribute-Based Access Control)**\n- **Attributes**: Decisions based on user, resource, and environment attributes\n- **Flexible**: More flexible than RBAC\n- **Complex**: More complex to implement\n- **Context-Aware**: Can consider context in decisions\n\n#### **3. Policy-Based Access Control**\n- **Policies**: Centralized policy definitions\n- **Externalized**: Policies defined outside application code\n- **Dynamic**: Policies can be changed without code changes\n- **Audit**: Easy to audit access decisions\n\n### **Security Best Practices**\n- **HTTPS**: Always use HTTPS in production\n- **Token Expiration**: Set appropriate token expiration times\n- **Refresh Tokens**: Use refresh tokens for long-lived sessions\n- **Rate Limiting**: Implement rate limiting to prevent abuse\n- **Input Validation**: Validate all inputs\n- **SQL Injection Prevention**: Use parameterized queries\n- **XSS Prevention**: Sanitize user inputs\n- **CSRF Protection**: Implement CSRF protection\n\n### **Microservices Security**\n- **Service-to-Service**: Secure communication between services\n- **mTLS**: Mutual TLS for service authentication\n- **API Gateway**: Centralized security enforcement\n- **Service Mesh**: Security policies in service mesh\n- **Secrets Management**: Secure storage of secrets\n- **Network Policies**: Network-level security policies",
          "code": "// Example: JWT Authentication (Spring Boot)\n@RestController\npublic class AuthController {\n    \n    @Autowired\n    private JwtTokenProvider jwtTokenProvider;\n    \n    @PostMapping(\"/login\")\n    public ResponseEntity<AuthResponse> login(@RequestBody LoginRequest request) {\n        // Authenticate user\n        UserDetails userDetails = userService.loadUserByUsername(request.getUsername());\n        \n        if (!passwordEncoder.matches(request.getPassword(), userDetails.getPassword())) {\n            throw new BadCredentialsException(\"Invalid credentials\");\n        }\n        \n        // Generate JWT token\n        String token = jwtTokenProvider.generateToken(userDetails);\n        String refreshToken = jwtTokenProvider.generateRefreshToken(userDetails);\n        \n        return ResponseEntity.ok(new AuthResponse(token, refreshToken));\n    }\n    \n    @PostMapping(\"/refresh\")\n    public ResponseEntity<AuthResponse> refresh(@RequestBody RefreshTokenRequest request) {\n        String refreshToken = request.getRefreshToken();\n        \n        if (jwtTokenProvider.validateToken(refreshToken)) {\n            String username = jwtTokenProvider.getUsernameFromToken(refreshToken);\n            UserDetails userDetails = userService.loadUserByUsername(username);\n            \n            String newToken = jwtTokenProvider.generateToken(userDetails);\n            String newRefreshToken = jwtTokenProvider.generateRefreshToken(userDetails);\n            \n            return ResponseEntity.ok(new AuthResponse(newToken, newRefreshToken));\n        }\n        \n        throw new BadCredentialsException(\"Invalid refresh token\");\n    }\n}\n\n// Example: JWT Token Provider\n@Component\npublic class JwtTokenProvider {\n    \n    private final String secretKey = \"mySecretKey\";\n    private final long validityInMilliseconds = 3600000; // 1 hour\n    private final long refreshValidityInMilliseconds = 86400000; // 24 hours\n    \n    public String generateToken(UserDetails userDetails) {\n        Date now = new Date();\n        Date validity = new Date(now.getTime() + validityInMilliseconds);\n        \n        return Jwts.builder()\n            .setSubject(userDetails.getUsername())\n            .setIssuedAt(now)\n            .setExpiration(validity)\n            .claim(\"roles\", userDetails.getAuthorities())\n            .signWith(SignatureAlgorithm.HS256, secretKey)\n            .compact();\n    }\n    \n    public boolean validateToken(String token) {\n        try {\n            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);\n            return true;\n        } catch (JwtException | IllegalArgumentException e) {\n            return false;\n        }\n    }\n    \n    public String getUsernameFromToken(String token) {\n        return Jwts.parser()\n            .setSigningKey(secretKey)\n            .parseClaimsJws(token)\n            .getBody()\n            .getSubject();\n    }\n}\n\n// Example: OAuth 2.0 Resource Server\n@Configuration\n@EnableResourceServer\npublic class ResourceServerConfig extends ResourceServerConfigurerAdapter {\n    \n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n            .antMatchers(\"/api/public/**\").permitAll()\n            .antMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n            .antMatchers(\"/api/user/**\").hasRole(\"USER\")\n            .anyRequest().authenticated()\n            .and()\n            .oauth2ResourceServer()\n            .jwt();\n    }\n}\n\n// Example: RBAC Implementation\n@Entity\npublic class User {\n    @Id\n    private String id;\n    private String username;\n    private String email;\n    \n    @ManyToMany(fetch = FetchType.EAGER)\n    private Set<Role> roles = new HashSet<>();\n}\n\n@Entity\npublic class Role {\n    @Id\n    private String id;\n    private String name;\n    \n    @ManyToMany(fetch = FetchType.EAGER)\n    private Set<Permission> permissions = new HashSet<>();\n}\n\n@Entity\npublic class Permission {\n    @Id\n    private String id;\n    private String name;\n    private String resource;\n    private String action;\n}\n\n// Example: Service-to-Service Authentication (mTLS)\n@Configuration\npublic class SecurityConfig {\n    \n    @Bean\n    public RestTemplate restTemplate() {\n        try {\n            // Load client certificate and key\n            KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n            keyStore.load(new FileInputStream(\"client.p12\"), \"password\".toCharArray());\n            \n            // Load trust store\n            KeyStore trustStore = KeyStore.getInstance(\"PKCS12\");\n            trustStore.load(new FileInputStream(\"truststore.p12\"), \"password\".toCharArray());\n            \n            // Create SSL context\n            SSLContext sslContext = SSLContextBuilder.create()\n                .loadKeyMaterial(keyStore, \"password\".toCharArray())\n                .loadTrustMaterial(trustStore, null)\n                .build();\n            \n            // Create HTTP client with SSL context\n            CloseableHttpClient httpClient = HttpClients.custom()\n                .setSSLContext(sslContext)\n                .build();\n            \n            HttpComponentsClientHttpRequestFactory factory = \n                new HttpComponentsClientHttpRequestFactory(httpClient);\n            \n            return new RestTemplate(factory);\n            \n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to create RestTemplate\", e);\n        }\n    }\n}"
        },
        {
          "name": "Data Security",
          "text": "# Data Security & Privacy\n\n**Question:** How do you ensure data security and privacy in a distributed system?\n\n## **Answer:**\n\n### **Data Encryption**\n\n#### **1. Encryption at Rest**\n- **Database Encryption**: Encrypt sensitive data in databases\n- **File System Encryption**: Encrypt files on disk\n- **Key Management**: Secure key storage and rotation\n- **Transparent Encryption**: Application-transparent encryption\n\n#### **2. Encryption in Transit**\n- **HTTPS/TLS**: Encrypt all network communication\n- **mTLS**: Mutual TLS for service-to-service communication\n- **VPN**: Virtual private networks for secure connections\n- **Certificate Management**: Proper certificate lifecycle management\n\n#### **3. Application-Level Encryption**\n- **Field-Level Encryption**: Encrypt specific fields\n- **Symmetric Encryption**: Use AES for bulk data encryption\n- **Asymmetric Encryption**: Use RSA for key exchange\n- **Hybrid Encryption**: Combine symmetric and asymmetric encryption\n\n### **Data Privacy**\n\n#### **1. Data Classification**\n- **Public Data**: No restrictions\n- **Internal Data**: Company-internal use only\n- **Confidential Data**: Restricted access\n- **Personal Data**: Subject to privacy regulations\n\n#### **2. Data Minimization**\n- **Collect Only What's Needed**: Minimize data collection\n- **Retention Policies**: Define data retention periods\n- **Data Deletion**: Secure data deletion\n- **Anonymization**: Remove personally identifiable information\n\n#### **3. Privacy Regulations**\n- **GDPR**: General Data Protection Regulation\n- **CCPA**: California Consumer Privacy Act\n- **HIPAA**: Health Insurance Portability and Accountability Act\n- **SOX**: Sarbanes-Oxley Act\n\n### **Access Control**\n- **Principle of Least Privilege**: Grant minimum necessary access\n- **Role-Based Access**: Assign access based on roles\n- **Attribute-Based Access**: Use attributes for access decisions\n- **Dynamic Access Control**: Context-aware access control\n\n### **Audit and Monitoring**\n- **Access Logging**: Log all data access\n- **Data Lineage**: Track data flow and transformations\n- **Compliance Monitoring**: Monitor compliance with regulations\n- **Incident Response**: Respond to security incidents\n\n### **Data Loss Prevention**\n- **DLP Solutions**: Implement data loss prevention tools\n- **Content Inspection**: Inspect data in transit and at rest\n- **Policy Enforcement**: Enforce data handling policies\n- **User Training**: Train users on data security\n\n### **Secure Development**\n- **Secure Coding**: Follow secure coding practices\n- **Code Review**: Review code for security issues\n- **Static Analysis**: Use static analysis tools\n- **Penetration Testing**: Regular security testing",
          "code": "// Example: Field-Level Encryption\n@Service\npublic class UserService {\n    \n    @Autowired\n    private AESUtil aesUtil;\n    \n    public User createUser(UserRequest request) {\n        User user = new User();\n        user.setUsername(request.getUsername());\n        \n        // Encrypt sensitive fields\n        user.setEmail(aesUtil.encrypt(request.getEmail()));\n        user.setPhoneNumber(aesUtil.encrypt(request.getPhoneNumber()));\n        user.setSsn(aesUtil.encrypt(request.getSsn()));\n        \n        return userRepository.save(user);\n    }\n    \n    public User getUser(String userId) {\n        User user = userRepository.findById(userId);\n        \n        // Decrypt sensitive fields\n        user.setEmail(aesUtil.decrypt(user.getEmail()));\n        user.setPhoneNumber(aesUtil.decrypt(user.getPhoneNumber()));\n        user.setSsn(aesUtil.decrypt(user.getSsn()));\n        \n        return user;\n    }\n}\n\n// Example: AES Encryption Utility\n@Component\npublic class AESUtil {\n    \n    private final String secretKey = \"MySecretKey12345\";\n    private final String salt = \"MySalt12345\";\n    \n    public String encrypt(String plainText) {\n        try {\n            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n            \n            byte[] encrypted = cipher.doFinal(plainText.getBytes());\n            return Base64.getEncoder().encodeToString(encrypted);\n            \n        } catch (Exception e) {\n            throw new RuntimeException(\"Encryption failed\", e);\n        }\n    }\n    \n    public String decrypt(String encryptedText) {\n        try {\n            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, keySpec);\n            \n            byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedText));\n            return new String(decrypted);\n            \n        } catch (Exception e) {\n            throw new RuntimeException(\"Decryption failed\", e);\n        }\n    }\n}\n\n// Example: Data Anonymization\n@Service\npublic class DataAnonymizationService {\n    \n    public User anonymizeUser(User user) {\n        User anonymizedUser = new User();\n        anonymizedUser.setId(user.getId());\n        anonymizedUser.setUsername(user.getUsername());\n        \n        // Anonymize sensitive fields\n        anonymizedUser.setEmail(anonymizeEmail(user.getEmail()));\n        anonymizedUser.setPhoneNumber(anonymizePhone(user.getPhoneNumber()));\n        anonymizedUser.setSsn(anonymizeSsn(user.getSsn()));\n        \n        return anonymizedUser;\n    }\n    \n    private String anonymizeEmail(String email) {\n        String[] parts = email.split(\"@\");\n        String username = parts[0];\n        String domain = parts[1];\n        \n        return username.substring(0, 2) + \"***@\" + domain;\n    }\n    \n    private String anonymizePhone(String phone) {\n        return phone.substring(0, 3) + \"-***-\" + phone.substring(phone.length() - 4);\n    }\n    \n    private String anonymizeSsn(String ssn) {\n        return \"***-**-\" + ssn.substring(ssn.length() - 4);\n    }\n}\n\n// Example: Audit Logging\n@Component\npublic class AuditLogger {\n    \n    @Autowired\n    private AuditRepository auditRepository;\n    \n    public void logDataAccess(String userId, String resource, String action, String data) {\n        AuditLog auditLog = new AuditLog();\n        auditLog.setUserId(userId);\n        auditLog.setResource(resource);\n        auditLog.setAction(action);\n        auditLog.setData(data);\n        auditLog.setTimestamp(LocalDateTime.now());\n        auditLog.setIpAddress(getClientIpAddress());\n        \n        auditRepository.save(auditLog);\n    }\n    \n    @EventListener\n    public void handleDataAccess(DataAccessEvent event) {\n        logDataAccess(\n            event.getUserId(),\n            event.getResource(),\n            event.getAction(),\n            event.getData()\n        );\n    }\n}\n\n// Example: Data Retention Policy\n@Service\npublic class DataRetentionService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Scheduled(cron = \"0 0 2 * * ?\") // Run daily at 2 AM\n    public void cleanupExpiredData() {\n        LocalDateTime cutoffDate = LocalDateTime.now().minusYears(7);\n        \n        List<User> expiredUsers = userRepository.findByLastLoginBefore(cutoffDate);\n        \n        for (User user : expiredUsers) {\n            // Anonymize user data\n            user.setEmail(\"deleted@example.com\");\n            user.setPhoneNumber(\"000-000-0000\");\n            user.setSsn(\"000-00-0000\");\n            user.setActive(false);\n            \n            userRepository.save(user);\n        }\n    }\n}"
        }
      ]
    }
  ]
}
