{
  "config": {
    "id": "mysql-advanced",
    "name": "MySQL Advanced",
    "description": "Advanced MySQL concepts, optimization, and administration",
    "icon": "üê¨",
    "enabled": true
  },
  "content": [
    {
      "id": "mysql-indexing",
      "title": "üóÑÔ∏è MySQL Indexing ‚Äî Performance Optimization",
      "sections": [
        {
          "name": "Index Types and Strategies",
          "text": "MySQL offers various index types optimized for different use cases. Understanding when to use each type is crucial for optimal performance.\n\n**B-Tree Index**: MySQL's default index type. Use for equality, range queries, and sorting. Perfect for primary keys, foreign keys, and frequently queried columns.\n\n**Composite Index**: Multiple columns in one index. Use when queries filter by multiple columns. Order matters - put most selective columns first.\n\n**Covering Index**: Includes all columns needed for a query. Eliminates table lookups, dramatically improving performance for read-heavy workloads.\n\n**Prefix Index**: Indexes only the first N characters of a column. Saves space for long text columns while maintaining performance.\n\n**Full-text Index**: For searching within text content. Excellent for search functionality, content management systems.\n\n**Spatial Index**: For geographic data using MySQL's spatial data types. Supports geometric operations and geographic queries.\n\n**Hash Index**: Only for equality comparisons in Memory storage engine. Faster than B-tree for exact matches but limited to Memory tables.\n\n**Functional Index**: Indexes computed values (MySQL 8.0+). Use when queries filter by calculated columns or functions.\n\n**Invisible Index**: Indexes that exist but aren't used by optimizer (MySQL 8.0+). Useful for testing index impact without dropping.\n\n**Descending Index**: Indexes with descending sort order (MySQL 8.0+). Optimizes queries with ORDER BY DESC.",
          "code": "-- B-Tree Index (MySQL default) - Use for: equality, ranges, sorting\n-- Benefits: Versatile, supports all comparison operators\n-- When to use: Primary keys, foreign keys, frequently queried columns\nCREATE INDEX idx_customer_email ON customers(email);\nCREATE INDEX idx_orders_date ON orders(order_date);\n\n-- Composite Index - Use for: multi-column queries\n-- Benefits: Single index covers multiple columns, faster than multiple indexes\n-- When to use: Queries that filter by multiple columns together\n-- Order matters: Most selective column first\nCREATE INDEX idx_customer_name_email ON customers(last_name, first_name, email);\n\n-- Covering Index (MySQL 5.6+) - Use for: read-heavy workloads\n-- Benefits: Eliminates table lookups, much faster SELECT queries\n-- When to use: Queries that only need indexed columns\nCREATE INDEX idx_order_summary ON orders(customer_id, order_date, total_amount);\n\n-- Unique Index - Use for: data integrity\n-- Benefits: Prevents duplicates, automatically creates constraint\n-- When to use: Columns that must be unique (emails, usernames)\nCREATE UNIQUE INDEX idx_customer_email_unique ON customers(email);\n\n-- Prefix Index (MySQL specific) - Use for: long text columns\n-- Benefits: Saves storage space, maintains performance\n-- When to use: Long VARCHAR/TEXT columns where prefix is sufficient\nCREATE INDEX idx_customer_name_prefix ON customers(last_name(10));\n\n-- Full-text Index (MySQL) - Use for: text search\n-- Benefits: Fast full-text search, relevance scoring\n-- When to use: Search functionality, content management\nCREATE FULLTEXT INDEX idx_product_description ON products(description);\n\n-- Spatial Index - Use for: geographic data\n-- Benefits: Fast geometric operations, geographic queries\n-- When to use: Location-based applications, mapping systems\nCREATE SPATIAL INDEX idx_locations_coordinates ON locations(coordinates);\n\n-- Hash Index (Memory storage engine) - Use for: exact equality only\n-- Benefits: Faster than B-tree for exact matches\n-- When to use: Simple equality lookups in Memory tables\nCREATE TABLE hash_table (\n    id INT PRIMARY KEY,\n    data VARCHAR(100),\n    INDEX idx_data_hash (data) USING HASH\n) ENGINE=MEMORY;\n\n-- Functional Index (MySQL 8.0+) - Use for: computed columns\n-- Benefits: Fast queries on calculated values\n-- When to use: Queries filter by functions or expressions\nCREATE INDEX idx_customer_name_lower ON customers((LOWER(last_name)));\n\n-- Invisible Index (MySQL 8.0+) - Use for: testing index impact\n-- Benefits: Test performance without dropping index\n-- When to use: Evaluating index necessity, A/B testing\nCREATE INDEX idx_customer_status ON customers(status) INVISIBLE;\n\n-- Descending Index (MySQL 8.0+) - Use for: ORDER BY DESC queries\n-- Benefits: Optimizes descending sort operations\n-- When to use: Queries with ORDER BY DESC, time-series data\nCREATE INDEX idx_orders_date_desc ON orders(order_date DESC);"
        },
        {
          "name": "Index Performance Analysis",
          "text": "Analyze index usage and performance to optimize MySQL queries and identify missing or unused indexes.\n\n**Why Monitor Index Usage in MySQL?**\n- **Identify Unused Indexes**: Remove indexes that consume space but aren't used\n- **Find Missing Indexes**: Discover queries that would benefit from new indexes\n- **Optimize Performance**: Understand which indexes are most valuable\n- **Cost-Benefit Analysis**: Balance query speed vs. storage and maintenance costs\n\n**Key Metrics to Monitor:**\n- **COUNT_READ**: Number of times index was read (higher = more valuable)\n- **COUNT_FETCH**: Rows fetched using index (indicates selectivity)\n- **COUNT_INSERT/UPDATE/DELETE**: Write operations using index (maintenance overhead)\n- **CARDINALITY**: Estimated number of unique values (affects selectivity)\n\n**Performance Analysis Benefits:**\n- **Storage Optimization**: Remove unused indexes to save space\n- **Query Optimization**: Add missing indexes for slow queries\n- **Maintenance Planning**: Focus on frequently used indexes\n- **Cost Reduction**: Eliminate unnecessary index maintenance overhead\n\n**MySQL-Specific Considerations:**\n- **Performance Schema**: Provides detailed index usage statistics\n- **Information Schema**: Shows index metadata and size information\n- **EXPLAIN Formats**: JSON format provides detailed execution information\n- **Index Cardinality**: Critical for MySQL query optimizer decisions",
          "code": "-- Check index usage (MySQL 5.7+) - Shows which indexes are actually being used\n-- COUNT_READ: Number of times index was read (higher = more valuable)\n-- COUNT_FETCH: Rows fetched using index (indicates selectivity)\n-- Use for: Identifying valuable vs. unused indexes\n-- Benefits: Data-driven index optimization decisions\nSELECT \n    TABLE_SCHEMA,\n    TABLE_NAME,\n    INDEX_NAME,\n    COUNT_READ,\n    COUNT_FETCH,\n    COUNT_INSERT,\n    COUNT_UPDATE,\n    COUNT_DELETE\nFROM performance_schema.table_io_waits_summary_by_index_usage\nWHERE TABLE_SCHEMA = 'mydb'\nORDER BY COUNT_READ DESC;\n\n-- Find unused indexes (MySQL) - Candidates for removal\n-- COUNT_READ = 0: Index never used for reads\n-- All counts = 0: Completely unused index\n-- Use for: Identifying indexes to remove\n-- Benefits: Free up storage space, reduce maintenance overhead\nSELECT \n    TABLE_SCHEMA,\n    TABLE_NAME,\n    INDEX_NAME\nFROM performance_schema.table_io_waits_summary_by_index_usage\nWHERE TABLE_SCHEMA = 'mydb'\n    AND COUNT_READ = 0\n    AND COUNT_FETCH = 0\n    AND COUNT_INSERT = 0\n    AND COUNT_UPDATE = 0\n    AND COUNT_DELETE = 0;\n\n-- Analyze query execution plan (MySQL) - Shows how MySQL uses indexes\n-- FORMAT=JSON: Detailed execution information\n-- Use for: Understanding query execution, identifying bottlenecks\n-- Benefits: Optimize query performance, verify index usage\nEXPLAIN FORMAT=JSON\nSELECT * FROM customers \nWHERE email = 'john@example.com';\n\n-- Traditional EXPLAIN format - Human-readable execution plan\n-- FORMAT=TRADITIONAL: Classic tabular format\n-- Use for: Quick analysis, familiar format\n-- Benefits: Easy to read, shows key execution details\nEXPLAIN FORMAT=TRADITIONAL\nSELECT * FROM customers \nWHERE email = 'john@example.com';\n\n-- Check index size (MySQL) - Monitor storage usage\n-- INDEX_LENGTH: Size of index in bytes\n-- Use for: Storage planning, identifying large indexes\n-- Benefits: Storage optimization, maintenance planning\nSELECT \n    TABLE_NAME,\n    INDEX_NAME,\n    ROUND(((INDEX_LENGTH) / 1024 / 1024), 2) AS 'Index Size (MB)'\nFROM information_schema.STATISTICS\nWHERE TABLE_SCHEMA = 'mydb'\n    AND TABLE_NAME = 'customers';\n\n-- Detailed index statistics - Comprehensive analysis\n-- CARDINALITY: Estimated unique values (critical for optimizer)\n-- SUB_PART: Prefix length for partial indexes\n-- Use for: Understanding index characteristics, optimization\n-- Benefits: Better index design, improved query performance\nSELECT \n    s.TABLE_NAME,\n    s.INDEX_NAME,\n    s.CARDINALITY,\n    s.SUB_PART,\n    s.PACKED,\n    s.NULLABLE,\n    s.INDEX_TYPE,\n    ROUND(((s.INDEX_LENGTH) / 1024 / 1024), 2) AS 'Index Size (MB)'\nFROM information_schema.STATISTICS s\nWHERE s.TABLE_SCHEMA = 'mydb'\n    AND s.TABLE_NAME = 'customers'\nORDER BY s.CARDINALITY DESC;"
        },
        {
          "name": "Index Maintenance",
          "text": "Regular index maintenance is essential for optimal MySQL performance. Learn how to monitor and maintain indexes.\n\n**Why Index Maintenance Matters in MySQL:**\n- **Prevents Fragmentation**: Indexes can become fragmented over time, reducing performance\n- **Updates Statistics**: Helps MySQL query optimizer make better decisions\n- **Maintains Performance**: Ensures indexes continue to provide optimal speed\n- **Prevents Degradation**: Regular maintenance prevents gradual performance decline\n\n**Key MySQL Maintenance Tasks:**\n- **ANALYZE TABLE**: Updates table statistics for better query planning\n- **OPTIMIZE TABLE**: Defragments tables and updates statistics\n- **SHOW TABLE STATUS**: Monitors table health and fragmentation\n- **Monitoring**: Tracks index usage and performance over time\n\n**MySQL-Specific Maintenance Benefits:**\n- **Consistent Performance**: Prevents gradual performance degradation\n- **Better Query Planning**: Updated statistics lead to better execution plans\n- **Storage Optimization**: Removes fragmentation and reclaims space\n- **Predictable Performance**: Regular maintenance ensures consistent response times\n\n**When to Perform MySQL Maintenance:**\n- **High-Volume Systems**: After heavy INSERT/UPDATE/DELETE operations\n- **Performance Issues**: When queries become slower than expected\n- **Scheduled Maintenance**: Regular intervals (weekly/monthly)\n- **After Bulk Operations**: Large data imports or updates\n\n**MySQL-Specific Considerations:**\n- **Storage Engine**: Different engines (InnoDB, MyISAM) have different maintenance needs\n- **Performance Schema**: Provides detailed monitoring capabilities\n- **Duplicate Index Detection**: MySQL can have redundant indexes that waste space",
          "code": "-- Analyze table (updates statistics) - Critical for query optimization\n-- ANALYZE TABLE: Updates statistics for MySQL query optimizer\n-- Use when: Query performance degrades, after data changes\n-- Benefits: Better query execution plans, improved performance\nANALYZE TABLE customers;\nANALYZE TABLE orders;\n\n-- Check table status - Monitor table health\n-- SHOW TABLE STATUS: Shows table size, row count, fragmentation\n-- Use for: Monitoring table health, identifying fragmentation\n-- Benefits: Proactive maintenance, performance monitoring\nSHOW TABLE STATUS LIKE 'customers';\n\n-- Optimize table (defragments and updates statistics) - Comprehensive maintenance\n-- OPTIMIZE TABLE: Defragments table and updates statistics\n-- Use when: Table becomes fragmented, performance degrades\n-- Benefits: Restores optimal performance, removes fragmentation\nOPTIMIZE TABLE customers;\nOPTIMIZE TABLE orders;\n\n-- Check index fragmentation - Monitor index efficiency\n-- CARDINALITY: Estimated unique values (critical for optimizer)\n-- INDEX_LENGTH: Size of index in bytes\n-- Use for: Identifying fragmented indexes, maintenance planning\n-- Benefits: Storage optimization, performance monitoring\nSELECT \n    TABLE_NAME,\n    INDEX_NAME,\n    CARDINALITY,\n    ROUND(((INDEX_LENGTH) / 1024 / 1024), 2) AS 'Index Size (MB)'\nFROM information_schema.STATISTICS\nWHERE TABLE_SCHEMA = 'mydb'\n    AND TABLE_NAME = 'customers';\n\n-- Monitor index usage over time (MySQL) - Track performance trends\n-- Creates historical record of index usage\n-- Helps identify performance patterns and degradation\n-- Benefits: Proactive maintenance, performance trend analysis\nCREATE TABLE index_usage_log (\n    log_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    table_name VARCHAR(100),\n    index_name VARCHAR(100),\n    reads BIGINT,\n    writes BIGINT\n);\n\n-- Log current index usage (MySQL 5.7+) - Capture current state\n-- Performance Schema provides detailed usage statistics\n-- Run regularly to track usage patterns\n-- Benefits: Historical analysis, maintenance planning\nINSERT INTO index_usage_log (table_name, index_name, reads, writes)\nSELECT \n    TABLE_NAME,\n    INDEX_NAME,\n    COUNT_READ,\n    COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE\nFROM performance_schema.table_io_waits_summary_by_index_usage\nWHERE TABLE_SCHEMA = 'mydb';\n\n-- Automated index maintenance procedure - Streamline maintenance\n-- Combines multiple maintenance tasks\n-- Can be scheduled with MySQL Event Scheduler\n-- Benefits: Consistent maintenance, reduced manual effort\nDELIMITER //\nCREATE PROCEDURE MaintainIndexes()\nBEGIN\n    -- Update statistics for all tables\n    ANALYZE TABLE customers, orders, order_items;\n    \n    -- Optimize tables\n    OPTIMIZE TABLE customers, orders, order_items;\n    \n    -- Log maintenance completion\n    INSERT INTO maintenance_log (task, completed_at)\n    VALUES ('index_maintenance', NOW());\nEND //\nDELIMITER ;\n\n-- Check for duplicate indexes - Identify redundant indexes\n-- Duplicate indexes waste storage and slow down writes\n-- Use for: Storage optimization, performance improvement\n-- Benefits: Reduced storage usage, faster write operations\nSELECT \n    a.TABLE_SCHEMA,\n    a.TABLE_NAME,\n    a.INDEX_NAME as first_index,\n    b.INDEX_NAME as duplicate_index,\n    a.COLUMN_NAME\nFROM information_schema.STATISTICS a\nJOIN information_schema.STATISTICS b ON \n    a.TABLE_SCHEMA = b.TABLE_SCHEMA\n    AND a.TABLE_NAME = b.TABLE_NAME\n    AND a.COLUMN_NAME = b.COLUMN_NAME\n    AND a.INDEX_NAME < b.INDEX_NAME\nWHERE a.TABLE_SCHEMA = 'mydb';"
        }
      ]
    },
    {
      "id": "mysql-query-optimization",
      "title": "‚ö° MySQL Query Optimization ‚Äî Performance Tuning",
      "sections": [
        {
          "name": "Query Execution Plans",
          "text": "Understanding MySQL query execution plans is crucial for identifying performance bottlenecks and optimizing queries.\n\n**Why Analyze Execution Plans in MySQL?**\n- **Identify Bottlenecks**: Find slow operations in query execution\n- **Verify Index Usage**: Ensure indexes are being used effectively\n- **Compare Approaches**: Test different query strategies\n- **Optimize Performance**: Make data-driven optimization decisions\n\n**Key MySQL EXPLAIN Options:**\n- **ANALYZE**: Shows actual execution time and row counts (MySQL 8.0+)\n- **FORMAT=JSON**: Machine-readable output with detailed information\n- **FORMAT=TRADITIONAL**: Classic tabular format (default)\n- **FORMAT=TREE**: Hierarchical tree format (MySQL 8.0+)\n\n**Common MySQL Performance Issues:**\n- **Full Table Scan**: Using ALL access type (slow for large tables)\n- **Using Filesort**: Expensive sorting operations\n- **Using Temporary**: Temporary table creation for complex queries\n- **Range Scan**: Can be optimized with better indexes\n\n**MySQL-Specific Optimization Benefits:**\n- **Faster Queries**: Identify and fix performance bottlenecks\n- **Better Resource Usage**: Reduce CPU and I/O overhead\n- **Scalability**: Ensure queries perform well as data grows\n- **Cost Reduction**: Lower infrastructure costs through efficiency\n\n**MySQL Version Considerations:**\n- **MySQL 8.0+**: Enhanced EXPLAIN ANALYZE with actual timing\n- **MySQL 5.7+**: Improved JSON format with more details\n- **Storage Engine**: Different engines (InnoDB, MyISAM) show different plans",
          "code": "-- Basic execution plan (MySQL) - Shows query structure and estimated costs\n-- Use for: Understanding query flow, identifying expensive operations\n-- Benefits: Quick analysis without executing query\nEXPLAIN SELECT * FROM customers WHERE email = 'john@example.com';\n\n-- Detailed execution plan with timing (MySQL 8.0+) - Most comprehensive analysis\n-- ANALYZE: Shows actual execution time and row counts\n-- Use for: Detailed performance analysis, identifying bottlenecks\n-- Benefits: Real performance data, optimization insights\nEXPLAIN ANALYZE SELECT * FROM customers WHERE email = 'john@example.com';\n\n-- JSON format execution plan (MySQL 5.6+) - Machine-readable output\n-- FORMAT=JSON: Detailed execution information\n-- Use for: Programmatic analysis, detailed optimization\n-- Benefits: Rich metadata, better tool integration\nEXPLAIN FORMAT=JSON\nSELECT c.*, o.order_date, o.total_amount\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE c.status = 'active'\nORDER BY o.order_date DESC\nLIMIT 10;\n\n-- Traditional format execution plan - Human-readable format\n-- FORMAT=TRADITIONAL: Classic tabular format\n-- Use for: Quick analysis, familiar format\n-- Benefits: Easy to read, shows key execution details\nEXPLAIN FORMAT=TRADITIONAL\nSELECT c.*, o.order_date, o.total_amount\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE c.status = 'active';\n\n-- Compare different query approaches (MySQL) - Test optimization strategies\n-- Approach 1: Subquery - Often slower due to repeated execution\n-- Approach 2: JOIN - Usually faster, single execution\n-- Use for: Choosing between different query patterns\n-- Benefits: Data-driven optimization decisions\nEXPLAIN FORMAT=JSON\n-- Approach 1: Subquery\nSELECT * FROM customers \nWHERE id IN (SELECT customer_id FROM orders WHERE order_date > '2023-01-01');\n\nEXPLAIN FORMAT=JSON\n-- Approach 2: JOIN\nSELECT DISTINCT c.* FROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE o.order_date > '2023-01-01';\n\n-- Check query costs (MySQL) - Estimate resource usage\n-- FORMAT=JSON: Shows detailed cost information\n-- Use for: Cost estimation, optimization planning\n-- Benefits: Understand resource requirements before execution\nEXPLAIN FORMAT=JSON\nSELECT COUNT(*) FROM orders WHERE order_date > '2023-01-01';\n\n-- Analyze query with different formats (MySQL 8.0+) - Check execution details\n-- FORMAT=TREE: Shows execution hierarchy\n-- Use for: Understanding complex query execution flow\n-- Benefits: Clear execution order, better visualization\nEXPLAIN FORMAT=TREE\nSELECT * FROM customers WHERE email = 'john@example.com';\n\n-- Check for index usage (MySQL) - Verify index utilization\n-- USE INDEX: Forces specific index usage\n-- Use for: Testing index effectiveness, troubleshooting\n-- Benefits: Verify index usage, optimize query performance\nEXPLAIN FORMAT=JSON\nSELECT * FROM customers USE INDEX (idx_customer_email)\nWHERE email = 'john@example.com';"
        },
        {
          "name": "Common Query Patterns",
          "text": "Learn efficient MySQL query patterns and avoid common performance pitfalls.\n\n**Pagination Patterns in MySQL:**\n- **OFFSET/LIMIT**: Simple but slow for large offsets (MySQL scans all skipped rows)\n- **Cursor-based**: Much faster for large datasets, uses indexed columns\n- **SQL_CALC_FOUND_ROWS**: MySQL-specific way to get total count with pagination\n\n**MySQL-Specific Aggregation Benefits:**\n- **DATE_FORMAT**: Efficient grouping by time periods\n- **Window Functions**: Powerful for ranking and analytical queries (MySQL 8.0+)\n- **CTEs**: Improve readability and enable complex logic (MySQL 8.0+)\n- **Derived Tables**: Alternative to CTEs in older MySQL versions\n\n**MySQL Performance Advantages:**\n- **Cursor Pagination**: O(log n) vs O(n) for large offsets\n- **STRAIGHT_JOIN**: Forces specific join order for optimization\n- **Window Functions**: Single pass through data for complex calculations\n- **Derived Tables**: Efficient subquery execution\n\n**When to Use Each MySQL Pattern:**\n- **Cursor Pagination**: Large datasets, real-time applications\n- **Window Functions**: Ranking, running totals, analytical queries (MySQL 8.0+)\n- **STRAIGHT_JOIN**: When MySQL chooses suboptimal join order\n- **SQL_CALC_FOUND_ROWS**: When you need total count with pagination\n- **CTEs**: Multi-step queries, recursive operations (MySQL 8.0+)\n- **Derived Tables**: Complex subqueries in older MySQL versions",
          "code": "-- Efficient pagination - Basic but can be slow for large offsets\n-- Problem: OFFSET scans all skipped rows (slow for large offsets)\n-- Use for: Small datasets, simple pagination needs\n-- Benefits: Simple to implement, works with any ORDER BY\nSELECT * FROM customers\nORDER BY id\nLIMIT 20 OFFSET 40;\n\n-- Better pagination with cursor - Much faster for large datasets\n-- Solution: Use indexed column values instead of OFFSET\n-- Use for: Large datasets, real-time applications, infinite scroll\n-- Benefits: Consistent performance, O(log n) complexity\nSELECT * FROM customers\nWHERE id > 1000  -- Last seen ID from previous page\nORDER BY id\nLIMIT 20;\n\n-- Efficient aggregation (MySQL) - Time-based grouping\n-- DATE_FORMAT: Groups by time periods efficiently\n-- Use for: Time-series analysis, reporting, dashboards\n-- Benefits: Fast grouping, flexible time periods\nSELECT \n    DATE_FORMAT(order_date, '%Y-%m-01') as month,\n    COUNT(*) as order_count,\n    SUM(total_amount) as total_revenue\nFROM orders\nWHERE order_date >= '2023-01-01'\nGROUP BY DATE_FORMAT(order_date, '%Y-%m-01')\nORDER BY month;\n\n-- Window functions for ranking (MySQL 8.0+) - Powerful analytical queries\n-- ROW_NUMBER: Assigns sequential numbers within partitions\n-- Use for: Top-N queries, ranking, analytical reports\n-- Benefits: Single pass through data, flexible partitioning\nSELECT \n    customer_id,\n    order_date,\n    total_amount,\n    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC) as rn\nFROM orders\nWHERE rn <= 5;  -- Top 5 orders per customer\n\n-- MySQL-specific optimizations - Force join order\n-- STRAIGHT_JOIN: Forces specific join order\n-- Use for: When MySQL chooses suboptimal join order\n-- Benefits: Better performance for specific query patterns\nSELECT STRAIGHT_JOIN c.*, o.order_date\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE c.status = 'active';\n\n-- Use SQL_CALC_FOUND_ROWS for pagination with total count (MySQL specific)\n-- SQL_CALC_FOUND_ROWS: Calculates total rows without LIMIT\n-- FOUND_ROWS(): Returns the total count\n-- Use for: Pagination with total count display\n-- Benefits: Single query for data and count\nSELECT SQL_CALC_FOUND_ROWS * FROM customers\nWHERE status = 'active'\nLIMIT 20 OFFSET 40;\nSELECT FOUND_ROWS() as total_count;\n\n-- Common Table Expressions (MySQL 8.0+) - Reusable query components\n-- WITH: Creates temporary named result sets\n-- Use for: Complex multi-step queries, recursive operations\n-- Benefits: Improved readability, better optimization, reusability\nWITH customer_totals AS (\n    SELECT customer_id, SUM(total_amount) as total_spent\n    FROM orders\n    GROUP BY customer_id\n)\nSELECT c.name, ct.total_spent\nFROM customers c\nJOIN customer_totals ct ON c.id = ct.customer_id\nORDER BY ct.total_spent DESC;\n\n-- Derived tables for complex queries - Alternative to CTEs\n-- Subquery in FROM clause: Creates temporary result set\n-- Use for: Complex subqueries in older MySQL versions\n-- Benefits: Efficient subquery execution, better than correlated subqueries\nSELECT c.name, recent_orders.order_count\nFROM customers c\nJOIN (\n    SELECT customer_id, COUNT(*) as order_count\n    FROM orders\n    WHERE order_date > DATE_SUB(NOW(), INTERVAL 30 DAY)\n    GROUP BY customer_id\n) recent_orders ON c.id = recent_orders.customer_id;"
        },
        {
          "name": "Query Optimization Techniques",
          "text": "Advanced MySQL techniques for optimizing database queries including hints, views, and query rewriting.",
          "code": "-- Use appropriate JOIN types\n-- INNER JOIN for exact matches\nSELECT c.name, o.order_date\nFROM customers c\nINNER JOIN orders o ON c.id = o.customer_id;\n\n-- LEFT JOIN to preserve all customers\nSELECT c.name, COUNT(o.id) as order_count\nFROM customers c\nLEFT JOIN orders o ON c.id = o.customer_id\nGROUP BY c.id, c.name;\n\n-- Create view for complex aggregations (MySQL doesn't have materialized views)\nCREATE VIEW customer_summary AS\nSELECT \n    c.id,\n    c.name,\n    c.email,\n    COUNT(o.id) as total_orders,\n    SUM(o.total_amount) as total_spent,\n    MAX(o.order_date) as last_order_date\nFROM customers c\nLEFT JOIN orders o ON c.id = o.customer_id\nGROUP BY c.id, c.name, c.email;\n\n-- MySQL query hints\n-- Force index usage\nSELECT * FROM customers USE INDEX (idx_customer_email)\nWHERE email = 'john@example.com';\n\n-- Ignore specific index\nSELECT * FROM customers IGNORE INDEX (idx_customer_email)\nWHERE email = 'john@example.com';\n\n-- Force specific join order\nSELECT STRAIGHT_JOIN c.*, o.order_date\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE c.status = 'active';\n\n-- Query cache configuration\n-- In my.cnf:\nquery_cache_type = 1\nquery_cache_size = 64M\nquery_cache_limit = 2M\n\n-- Check query cache status\nSHOW STATUS LIKE 'Qcache%';\n\n-- Optimizer hints (MySQL 8.0+)\nSELECT /*+ USE_INDEX(customers, idx_customer_email) */ *\nFROM customers\nWHERE email = 'john@example.com';\n\n-- Force specific join algorithm\nSELECT /*+ HASH_JOIN(c o) */ c.*, o.order_date\nFROM customers c\nJOIN orders o ON c.id = o.customer_id;"
        }
      ]
    },
    {
      "id": "mysql-transactions",
      "title": "üîÑ MySQL Transactions & Concurrency ‚Äî ACID Properties",
      "sections": [
        {
          "name": "Transaction Isolation Levels",
          "text": "Understanding MySQL isolation levels and their impact on concurrency and data consistency.",
          "code": "-- Set isolation level\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\nSTART TRANSACTION;\nSELECT * FROM customers WHERE id = 1;\n-- Other operations...\nCOMMIT;\n\n-- Serializable isolation (highest level)\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\nSTART TRANSACTION;\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\nCOMMIT;\n\n-- Check current isolation level\nSELECT @@transaction_isolation;\n\n-- Deadlock handling\nSTART TRANSACTION;\nUPDATE customers SET status = 'inactive' WHERE id = 1;\n-- If deadlock occurs, MySQL will rollback and retry\nUPDATE orders SET status = 'cancelled' WHERE customer_id = 1;\nCOMMIT;\n\n-- MySQL-specific transaction features\n-- Autocommit control\nSET autocommit = 0;  -- Disable autocommit\nSET autocommit = 1;  -- Enable autocommit\n\n-- Savepoints\nSTART TRANSACTION;\nINSERT INTO customers (name, email) VALUES ('John', 'john@example.com');\nSAVEPOINT sp1;\nINSERT INTO orders (customer_id, total_amount) VALUES (LAST_INSERT_ID(), 100);\nROLLBACK TO sp1;  -- Rollback to savepoint\nCOMMIT;\n\n-- Two-phase commit preparation\nSTART TRANSACTION;\n-- Prepare transaction (requires XA support)\nXA START 'txn_001';\nINSERT INTO customers (name, email) VALUES ('Jane', 'jane@example.com');\nXA END 'txn_001';\nXA PREPARE 'txn_001';\n-- Later: XA COMMIT 'txn_001'; or XA ROLLBACK 'txn_001';\n\n-- Transaction with consistent snapshot\nSTART TRANSACTION WITH CONSISTENT SNAPSHOT;\nSELECT * FROM customers;\n-- This transaction sees a consistent view of the database\nCOMMIT;\n\n-- Check transaction status\nSELECT \n    trx_id,\n    trx_state,\n    trx_started,\n    trx_mysql_thread_id,\n    trx_query\nFROM information_schema.innodb_trx;"
        },
        {
          "name": "Locking Mechanisms",
          "text": "Understanding MySQL locking mechanisms and how to avoid lock contention and deadlocks.",
          "code": "-- Explicit locking\nSTART TRANSACTION;\nSELECT * FROM customers WHERE id = 1 FOR UPDATE;\n-- This row is now locked for update\nUPDATE customers SET status = 'active' WHERE id = 1;\nCOMMIT;\n\n-- Row-level locking\nSTART TRANSACTION;\nSELECT * FROM customers WHERE email = 'john@example.com' LOCK IN SHARE MODE;\n-- Other transactions can read but not modify\nCOMMIT;\n\n-- MySQL-specific locking\n-- Lock with NOWAIT (MySQL 8.0+)\nSELECT * FROM customers WHERE id = 1 FOR UPDATE NOWAIT;\n\n-- Lock with SKIP LOCKED (MySQL 8.0+)\nSELECT * FROM customers WHERE status = 'pending' FOR UPDATE SKIP LOCKED;\n\n-- Check for locks (MySQL)\nSELECT \n    r.trx_id,\n    r.trx_state,\n    r.trx_started,\n    r.trx_mysql_thread_id,\n    r.trx_query,\n    l.lock_mode,\n    l.lock_type,\n    l.lock_table,\n    l.lock_index\nFROM information_schema.innodb_trx r\nLEFT JOIN information_schema.innodb_locks l ON r.trx_id = l.lock_trx_id;\n\n-- Check for lock waits\nSELECT \n    r.trx_id waiting_trx_id,\n    r.trx_mysql_thread_id waiting_thread,\n    r.trx_query waiting_query,\n    b.trx_id blocking_trx_id,\n    b.trx_mysql_thread_id blocking_thread,\n    b.trx_query blocking_query\nFROM information_schema.innodb_lock_waits w\nINNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id\nINNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;\n\n-- Lock timeout\nSET innodb_lock_wait_timeout = 5;\nSELECT * FROM customers WHERE id = 1 FOR UPDATE;\n\n-- Check for blocking queries\nSELECT \n    r.trx_id,\n    r.trx_state,\n    r.trx_started,\n    r.trx_mysql_thread_id,\n    r.trx_query,\n    l.lock_mode,\n    l.lock_type,\n    l.lock_table\nFROM information_schema.innodb_trx r\nLEFT JOIN information_schema.innodb_locks l ON r.trx_id = l.lock_trx_id\nWHERE r.trx_state = 'LOCK WAIT';\n\n-- Monitor lock contention\nSELECT \n    OBJECT_SCHEMA,\n    OBJECT_NAME,\n    COUNT(*) as lock_count\nFROM performance_schema.data_locks\nGROUP BY OBJECT_SCHEMA, OBJECT_NAME\nORDER BY lock_count DESC;"
        },
        {
          "name": "Concurrent Operations",
          "text": "Best practices for handling concurrent MySQL operations and maintaining data consistency.",
          "code": "-- Optimistic concurrency control\nUPDATE customers \nSET status = 'active', version = version + 1\nWHERE id = 1 AND version = 5;\n\n-- Check if update affected any rows\nSELECT ROW_COUNT();\n\n-- Pessimistic locking for critical operations\nSTART TRANSACTION;\nSELECT * FROM accounts WHERE id = 1 FOR UPDATE;\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n\n-- Batch operations for better concurrency\nINSERT INTO order_items (order_id, product_id, quantity, price)\nVALUES \n    (1, 101, 2, 29.99),\n    (1, 102, 1, 49.99),\n    (1, 103, 3, 19.99);\n\n-- Use UPSERT for concurrent inserts (MySQL 5.7+)\nINSERT INTO customers (email, name) \nVALUES ('john@example.com', 'John Doe')\nON DUPLICATE KEY UPDATE \n    name = VALUES(name),\n    updated_at = CURRENT_TIMESTAMP;\n\n-- MySQL-specific concurrent operations\n-- INSERT IGNORE for avoiding duplicate key errors\nINSERT IGNORE INTO customers (email, name) \nVALUES ('john@example.com', 'John Doe');\n\n-- REPLACE for upsert behavior\nREPLACE INTO customers (id, email, name) \nVALUES (1, 'john@example.com', 'John Doe');\n\n-- Multi-table INSERT (MySQL 8.0+)\nINSERT INTO customers (email, name) VALUES ('jane@example.com', 'Jane Doe');\nINSERT INTO orders (customer_id, total_amount) VALUES (LAST_INSERT_ID(), 100);\n\n-- Load data concurrently\nLOAD DATA INFILE '/path/to/data.csv'\nINTO TABLE customers\nFIELDS TERMINATED BY ','\nENCLOSED BY '\"'\nLINES TERMINATED BY '\\n'\nIGNORE 1 ROWS;\n\n-- Connection pooling considerations\n-- Use prepared statements for repeated queries\nPREPARE get_customer FROM 'SELECT * FROM customers WHERE id = ?';\nSET @customer_id = 1;\nEXECUTE get_customer USING @customer_id;\nDEALLOCATE PREPARE get_customer;\n\n-- Monitor concurrent connections\nSELECT \n    USER,\n    HOST,\n    COUNT(*) as connection_count\nFROM information_schema.PROCESSLIST\nWHERE COMMAND != 'Sleep'\nGROUP BY USER, HOST\nORDER BY connection_count DESC;"
        }
      ]
    },
    {
      "id": "mysql-stored-procedures",
      "title": "üìù MySQL Stored Procedures ‚Äî Business Logic in Database",
      "sections": [
        {
          "name": "Creating Stored Procedures",
          "text": "Learn how to create and use MySQL stored procedures to encapsulate business logic in the database.",
          "code": "-- Simple stored procedure\nDELIMITER //\nCREATE PROCEDURE GetCustomerOrders(\n    IN customer_email VARCHAR(255)\n)\nBEGIN\n    SELECT o.id as order_id, o.order_date, o.total_amount\n    FROM orders o\n    JOIN customers c ON o.customer_id = c.id\n    WHERE c.email = customer_email\n    ORDER BY o.order_date DESC;\nEND //\nDELIMITER ;\n\n-- Call the procedure\nCALL GetCustomerOrders('john@example.com');\n\n-- Procedure with parameters and return value\nDELIMITER //\nCREATE FUNCTION CalculateOrderTotal(\n    order_items JSON\n) RETURNS DECIMAL(10,2)\nREADS SQL DATA\nDETERMINISTIC\nBEGIN\n    DECLARE total DECIMAL(10,2) DEFAULT 0;\n    DECLARE i INT DEFAULT 0;\n    DECLARE item_count INT;\n    \n    SET item_count = JSON_LENGTH(order_items);\n    \n    WHILE i < item_count DO\n        SET total = total + \n            JSON_UNQUOTE(JSON_EXTRACT(order_items, CONCAT('$[', i, '].quantity'))) * \n            JSON_UNQUOTE(JSON_EXTRACT(order_items, CONCAT('$[', i, '].price')));\n        SET i = i + 1;\n    END WHILE;\n    \n    RETURN total;\nEND //\nDELIMITER ;\n\n-- Call the function\nSELECT CalculateOrderTotal('[{\"quantity\": 2, \"price\": 29.99}, {\"quantity\": 1, \"price\": 49.99}]');\n\n-- Procedure with default parameters\nDELIMITER //\nCREATE PROCEDURE GetCustomers(\n    IN status_filter VARCHAR(20),\n    IN limit_count INT\n)\nBEGIN\n    SELECT id, name, email\n    FROM customers\n    WHERE status = status_filter\n    LIMIT limit_count;\nEND //\nDELIMITER ;\n\n-- Call with parameters\nCALL GetCustomers('active', 100);\nCALL GetCustomers('inactive', 50);\n\n-- Procedure with OUT parameters\nDELIMITER //\nCREATE PROCEDURE GetCustomerStats(\n    IN customer_id INT,\n    OUT order_count INT,\n    OUT total_spent DECIMAL(10,2)\n)\nBEGIN\n    SELECT COUNT(*), COALESCE(SUM(total_amount), 0)\n    INTO order_count, total_spent\n    FROM orders\n    WHERE customer_id = customer_id;\nEND //\nDELIMITER ;\n\n-- Call procedure with OUT parameters\nCALL GetCustomerStats(1, @order_count, @total_spent);\nSELECT @order_count, @total_spent;"
        },
        {
          "name": "Advanced Stored Procedures",
          "text": "Advanced MySQL stored procedure techniques including error handling, cursors, and dynamic SQL.",
          "code": "-- Procedure with error handling\nDELIMITER //\nCREATE PROCEDURE TransferMoney(\n    IN from_account INT,\n    IN to_account INT,\n    IN amount DECIMAL(10,2),\n    OUT success BOOLEAN,\n    OUT error_message VARCHAR(255)\n)\nBEGIN\n    DECLARE from_balance DECIMAL(10,2) DEFAULT 0;\n    DECLARE EXIT HANDLER FOR SQLEXCEPTION\n    BEGIN\n        ROLLBACK;\n        SET success = FALSE;\n        SET error_message = 'Transaction failed';\n    END;\n    \n    START TRANSACTION;\n    \n    -- Check if accounts exist and have sufficient funds\n    SELECT balance INTO from_balance\n    FROM accounts\n    WHERE id = from_account;\n    \n    IF from_balance IS NULL THEN\n        SET success = FALSE;\n        SET error_message = 'Source account not found';\n        ROLLBACK;\n    ELSEIF from_balance < amount THEN\n        SET success = FALSE;\n        SET error_message = 'Insufficient funds';\n        ROLLBACK;\n    ELSE\n        -- Perform transfer\n        UPDATE accounts SET balance = balance - amount WHERE id = from_account;\n        UPDATE accounts SET balance = balance + amount WHERE id = to_account;\n        \n        -- Log transaction\n        INSERT INTO transactions (from_account, to_account, amount, timestamp)\n        VALUES (from_account, to_account, amount, NOW());\n        \n        SET success = TRUE;\n        SET error_message = 'Transfer successful';\n        COMMIT;\n    END IF;\nEND //\nDELIMITER ;\n\n-- Call the procedure\nCALL TransferMoney(1, 2, 100.00, @success, @error_message);\nSELECT @success, @error_message;\n\n-- Procedure with cursors\nDELIMITER //\nCREATE PROCEDURE ProcessOrdersBatch(\n    IN batch_size INT\n)\nBEGIN\n    DECLARE done INT DEFAULT FALSE;\n    DECLARE order_id INT;\n    DECLARE customer_id INT;\n    DECLARE total_amount DECIMAL(10,2);\n    DECLARE processed_count INT DEFAULT 0;\n    \n    DECLARE order_cursor CURSOR FOR \n        SELECT id, customer_id, total_amount \n        FROM orders \n        WHERE status = 'pending'\n        ORDER BY created_at;\n    \n    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n    \n    OPEN order_cursor;\n    \n    read_loop: LOOP\n        FETCH order_cursor INTO order_id, customer_id, total_amount;\n        IF done THEN\n            LEAVE read_loop;\n        END IF;\n        \n        -- Process order\n        UPDATE orders SET status = 'processed' WHERE id = order_id;\n        SET processed_count = processed_count + 1;\n        \n        IF processed_count >= batch_size THEN\n            LEAVE read_loop;\n        END IF;\n    END LOOP;\n    \n    CLOSE order_cursor;\n    SELECT processed_count as orders_processed;\nEND //\nDELIMITER ;\n\n-- Dynamic SQL procedure\nDELIMITER //\nCREATE PROCEDURE ExecuteDynamicQuery(\n    IN table_name VARCHAR(100),\n    IN where_clause TEXT\n)\nBEGIN\n    DECLARE query_text TEXT;\n    \n    SET @query_text = CONCAT('SELECT * FROM ', table_name, ' WHERE ', where_clause);\n    \n    PREPARE stmt FROM @query_text;\n    EXECUTE stmt;\n    DEALLOCATE PREPARE stmt;\nEND //\nDELIMITER ;\n\n-- Call dynamic procedure\nCALL ExecuteDynamicQuery('customers', 'status = \"active\"');"
        },
        {
          "name": "Triggers and Event Handling",
          "text": "Use MySQL triggers to automatically execute code when database events occur, maintaining data integrity and audit trails.",
          "code": "-- Create audit log table\nCREATE TABLE audit_log (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    table_name VARCHAR(50),\n    operation VARCHAR(10),\n    old_data JSON,\n    new_data JSON,\n    user_name VARCHAR(50),\n    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create trigger for INSERT\nDELIMITER //\nCREATE TRIGGER customers_audit_insert\n    AFTER INSERT ON customers\n    FOR EACH ROW\nBEGIN\n    INSERT INTO audit_log (table_name, operation, old_data, new_data, user_name)\n    VALUES ('customers', 'INSERT', NULL, JSON_OBJECT('id', NEW.id, 'name', NEW.name, 'email', NEW.email), USER());\nEND //\nDELIMITER ;\n\n-- Create trigger for UPDATE\nDELIMITER //\nCREATE TRIGGER customers_audit_update\n    AFTER UPDATE ON customers\n    FOR EACH ROW\nBEGIN\n    INSERT INTO audit_log (table_name, operation, old_data, new_data, user_name)\n    VALUES ('customers', 'UPDATE', \n        JSON_OBJECT('id', OLD.id, 'name', OLD.name, 'email', OLD.email),\n        JSON_OBJECT('id', NEW.id, 'name', NEW.name, 'email', NEW.email),\n        USER());\nEND //\nDELIMITER ;\n\n-- Create trigger for DELETE\nDELIMITER //\nCREATE TRIGGER customers_audit_delete\n    AFTER DELETE ON customers\n    FOR EACH ROW\nBEGIN\n    INSERT INTO audit_log (table_name, operation, old_data, new_data, user_name)\n    VALUES ('customers', 'DELETE', JSON_OBJECT('id', OLD.id, 'name', OLD.name, 'email', OLD.email), NULL, USER());\nEND //\nDELIMITER ;\n\n-- MySQL-specific trigger features\n-- Trigger with validation\nDELIMITER //\nCREATE TRIGGER validate_customer_email\n    BEFORE INSERT ON customers\n    FOR EACH ROW\nBEGIN\n    IF NEW.email NOT REGEXP '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$' THEN\n        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid email format';\n    END IF;\nEND //\nDELIMITER ;\n\n-- Conditional trigger\nDELIMITER //\nCREATE TRIGGER log_high_value_orders\n    AFTER INSERT ON orders\n    FOR EACH ROW\nBEGIN\n    IF NEW.total_amount > 1000 THEN\n        INSERT INTO high_value_orders_log (order_id, amount, timestamp)\n        VALUES (NEW.id, NEW.total_amount, NOW());\n    END IF;\nEND //\nDELIMITER ;\n\n-- Trigger with multiple conditions\nDELIMITER //\nCREATE TRIGGER update_customer_stats\n    AFTER INSERT ON orders\n    FOR EACH ROW\nBEGIN\n    UPDATE customers \n    SET \n        total_orders = total_orders + 1,\n        total_spent = total_spent + NEW.total_amount,\n        last_order_date = NEW.order_date\n    WHERE id = NEW.customer_id;\nEND //\nDELIMITER ;\n\n-- Event scheduler for automated tasks\n-- Enable event scheduler\nSET GLOBAL event_scheduler = ON;\n\n-- Create maintenance event\nDELIMITER //\nCREATE EVENT maintenance_event\nON SCHEDULE EVERY 1 WEEK\nSTARTS CURRENT_TIMESTAMP\nDO\nBEGIN\n    ANALYZE TABLE customers, orders, order_items;\n    OPTIMIZE TABLE customers, orders, order_items;\n    INSERT INTO maintenance_log (task, completed_at)\n    VALUES ('routine_maintenance', NOW());\nEND //\nDELIMITER ;"
        }
      ]
    },
    {
      "id": "mysql-security",
      "title": "üîí MySQL Security ‚Äî Access Control & Encryption",
      "sections": [
        {
          "name": "User Management & Roles",
          "text": "Implement proper user management and role-based access control for MySQL security.",
          "code": "-- Create users\nCREATE USER 'admin_user'@'localhost' IDENTIFIED BY 'secure_password';\nCREATE USER 'reader_user'@'localhost' IDENTIFIED BY 'readonly_password';\nCREATE USER 'writer_user'@'localhost' IDENTIFIED BY 'write_password';\n\n-- Grant privileges\nGRANT ALL PRIVILEGES ON mydb.* TO 'admin_user'@'localhost';\nGRANT SELECT ON mydb.* TO 'reader_user'@'localhost';\nGRANT SELECT, INSERT, UPDATE ON mydb.* TO 'writer_user'@'localhost';\n\n-- Create roles (MySQL 8.0+)\nCREATE ROLE 'db_admin', 'db_reader', 'db_writer';\n\n-- Grant privileges to roles\nGRANT ALL PRIVILEGES ON mydb.* TO 'db_admin';\nGRANT SELECT ON mydb.* TO 'db_reader';\nGRANT SELECT, INSERT, UPDATE ON mydb.* TO 'db_writer';\n\n-- Assign roles to users\nGRANT 'db_admin' TO 'admin_user'@'localhost';\nGRANT 'db_reader' TO 'reader_user'@'localhost';\nGRANT 'db_writer' TO 'writer_user'@'localhost';\n\n-- View current users and privileges\nSELECT \n    User,\n    Host,\n    Select_priv,\n    Insert_priv,\n    Update_priv,\n    Delete_priv,\n    Create_priv,\n    Drop_priv\nFROM mysql.user;\n\n-- View role assignments\nSELECT \n    User,\n    Host,\n    Default_role\nFROM mysql.default_roles;\n\n-- Grant schema-level privileges\nGRANT USAGE ON mydb.* TO 'reader_user'@'localhost';\nGRANT CREATE ON mydb.* TO 'writer_user'@'localhost';\n\n-- Grant table-level privileges\nGRANT SELECT ON mydb.customers TO 'reader_user'@'localhost';\nGRANT INSERT, UPDATE ON mydb.customers TO 'writer_user'@'localhost';\n\n-- Revoke privileges\nREVOKE SELECT ON mydb.customers FROM 'reader_user'@'localhost';\n\n-- Create group roles\nCREATE ROLE 'sales_team', 'marketing_team';\n\n-- Grant group privileges\nGRANT SELECT ON mydb.customers TO 'sales_team';\nGRANT SELECT ON mydb.orders TO 'sales_team';\nGRANT SELECT ON mydb.customers TO 'marketing_team';\n\n-- Add users to groups\nGRANT 'sales_team' TO 'sales_user1'@'localhost', 'sales_user2'@'localhost';\nGRANT 'marketing_team' TO 'marketing_user1'@'localhost';\n\n-- Password policy (MySQL 8.0+)\n-- In my.cnf:\nvalidate_password.policy = STRONG\nvalidate_password.length = 8\nvalidate_password.mixed_case_count = 1\nvalidate_password.number_count = 1\nvalidate_password.special_char_count = 1;"
        },
        {
          "name": "Data Encryption",
          "text": "Implement data encryption at rest and in transit to protect sensitive information in MySQL.",
          "code": "-- Enable SSL connections\n-- In my.cnf:\n[mysqld]\nssl-ca=/path/to/ca-cert.pem\nssl-cert=/path/to/server-cert.pem\nssl-key=/path/to/server-key.pem\n\n-- Encrypt sensitive columns\n-- Encrypt data on insert\nINSERT INTO users (username, password_hash, encrypted_email)\nVALUES (\n    'john_doe',\n    SHA2('password123', 256),\n    AES_ENCRYPT('john@example.com', 'encryption_key')\n);\n\n-- Decrypt data on select\nSELECT \n    username,\n    AES_DECRYPT(encrypted_email, 'encryption_key') as email\nFROM users\nWHERE username = 'john_doe';\n\n-- Hash passwords\n-- Using SHA2 (recommended)\nINSERT INTO users (username, password_hash)\nVALUES ('john_doe', SHA2('password123', 256));\n\n-- Using MD5 (not recommended for production)\nINSERT INTO users (username, password_hash)\nVALUES ('jane_doe', MD5('password123'));\n\n-- Verify password\nSELECT * FROM users \nWHERE username = 'john_doe' \nAND password_hash = SHA2('password123', 256);\n\n-- MySQL-specific encryption functions\n-- Encrypt with AES\nSELECT AES_ENCRYPT('sensitive_data', 'secret_key') as encrypted_data;\n\n-- Decrypt with AES\nSELECT AES_DECRYPT(encrypted_data, 'secret_key') as decrypted_data;\n\n-- Encrypt with DES (deprecated)\nSELECT DES_ENCRYPT('data', 'key') as encrypted_data;\n\n-- Decrypt with DES\nSELECT DES_DECRYPT(encrypted_data, 'key') as decrypted_data;\n\n-- Column-level encryption\nCREATE TABLE encrypted_users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(50),\n    encrypted_ssn VARBINARY(255),\n    encryption_key_id INT\n);\n\n-- Encrypt SSN\nINSERT INTO encrypted_users (username, encrypted_ssn, encryption_key_id)\nVALUES ('john', AES_ENCRYPT('123-45-6789', 'secret_key'), 1);\n\n-- Decrypt SSN\nSELECT username, AES_DECRYPT(encrypted_ssn, 'secret_key') as ssn\nFROM encrypted_users;\n\n-- Transparent Data Encryption (MySQL 8.0+)\n-- In my.cnf:\nearly-plugin-load=keyring_file.so\nkeyring_file_data=/var/lib/mysql-keyring/keyring\n\n-- Enable encryption for tablespace\nALTER TABLE sensitive_data ENCRYPTION='Y';\n\n-- Check encryption status\nSELECT \n    TABLE_SCHEMA,\n    TABLE_NAME,\n    CREATE_OPTIONS\nFROM information_schema.TABLES\nWHERE CREATE_OPTIONS LIKE '%ENCRYPTION%';"
        },
        {
          "name": "Security Monitoring",
          "text": "Monitor MySQL security events and implement logging for security auditing.",
          "code": "-- Enable connection logging\n-- In my.cnf:\n[mysqld]\nlog-error=/var/log/mysql/error.log\ngeneral-log=1\ngeneral-log-file=/var/log/mysql/general.log\nslow-query-log=1\nslow-query-log-file=/var/log/mysql/slow.log\nlog-queries-not-using-indexes=1\nlong_query_time=2\n\n-- Create security event log table\nCREATE TABLE security_events (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    event_type VARCHAR(50),\n    username VARCHAR(50),\n    database_name VARCHAR(50),\n    client_ip VARCHAR(45),\n    event_details JSON,\n    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Procedure to log security events\nDELIMITER //\nCREATE PROCEDURE LogSecurityEvent(\n    IN event_type VARCHAR(50),\n    IN username VARCHAR(50),\n    IN event_details JSON\n)\nBEGIN\n    INSERT INTO security_events (event_type, username, event_details)\n    VALUES (event_type, username, event_details);\nEND //\nDELIMITER ;\n\n-- Monitor failed login attempts\nSELECT \n    username,\n    COUNT(*) as failed_attempts,\n    MAX(timestamp) as last_attempt\nFROM security_events\nWHERE event_type = 'failed_login'\n    AND timestamp > DATE_SUB(NOW(), INTERVAL 1 HOUR)\nGROUP BY username\nHAVING COUNT(*) > 5;\n\n-- MySQL-specific security monitoring\n-- Check current connections\nSELECT \n    ID,\n    USER,\n    HOST,\n    DB,\n    COMMAND,\n    TIME,\n    STATE,\n    INFO\nFROM information_schema.PROCESSLIST;\n\n-- Monitor user privileges\nSELECT \n    User,\n    Host,\n    Select_priv,\n    Insert_priv,\n    Update_priv,\n    Delete_priv,\n    Create_priv,\n    Drop_priv,\n    Grant_priv\nFROM mysql.user;\n\n-- Check for suspicious activity\nSELECT \n    event_time,\n    user_host,\n    command_type,\n    argument\nFROM mysql.general_log\nWHERE event_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)\n    AND command_type = 'Connect'\nORDER BY event_time DESC;\n\n-- Monitor privilege changes\nDELIMITER //\nCREATE TRIGGER audit_user_changes\n    AFTER UPDATE ON mysql.user\n    FOR EACH ROW\nBEGIN\n    INSERT INTO security_events (event_type, username, event_details)\n    VALUES ('privilege_change', USER(), \n        JSON_OBJECT(\n            'old_user', OLD.User,\n            'new_user', NEW.User,\n            'old_host', OLD.Host,\n            'new_host', NEW.Host\n        )\n    );\nEND //\nDELIMITER ;\n\n-- Check for brute force attacks\nSELECT \n    SUBSTRING_INDEX(HOST, ':', 1) as client_ip,\n    COUNT(*) as connection_attempts,\n    MAX(event_time) as last_attempt\nFROM mysql.general_log\nWHERE event_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)\n    AND command_type = 'Connect'\nGROUP BY SUBSTRING_INDEX(HOST, ':', 1)\nHAVING COUNT(*) > 10\nORDER BY connection_attempts DESC;\n\n-- Monitor slow queries\nSELECT \n    start_time,\n    user_host,\n    query_time,\n    lock_time,\n    rows_sent,\n    rows_examined,\n    sql_text\nFROM mysql.slow_log\nWHERE start_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)\nORDER BY query_time DESC\nLIMIT 10;"
        }
      ]
    },
    {
      "id": "mysql-administration",
      "title": "‚öôÔ∏è MySQL Administration ‚Äî Maintenance & Monitoring",
      "sections": [
        {
          "name": "Backup & Recovery",
          "text": "Implement comprehensive backup and recovery strategies to protect your MySQL database.",
          "code": "-- Full database backup\nmysqldump -h localhost -u root -p mydb > backup_$(date +%Y%m%d_%H%M%S).sql\n\n-- Compressed backup\nmysqldump -h localhost -u root -p mydb | gzip > backup_$(date +%Y%m%d_%H%M%S).sql.gz\n\n-- Schema-only backup\nmysqldump -h localhost -u root -p --no-data mydb > schema_backup.sql\n\n-- Data-only backup\nmysqldump -h localhost -u root -p --no-create-info mydb > data_backup.sql\n\n-- Restore from backup\nmysql -h localhost -u root -p mydb < backup_20231201_120000.sql\n\n-- MySQL-specific backup options\n-- Backup with single transaction\nmysqldump -h localhost -u root -p --single-transaction mydb > backup.sql\n\n-- Backup with lock tables\nmysqldump -h localhost -u root -p --lock-tables mydb > backup.sql\n\n-- Backup specific tables\nmysqldump -h localhost -u root -p mydb table1 table2 > tables_backup.sql\n\n-- Binary backup (MySQL 8.0+)\nmysqlpump -h localhost -u root -p mydb > backup.sql\n\n-- Point-in-time recovery setup (MySQL)\n-- Enable binary logging\n-- In my.cnf:\n[mysqld]\nlog-bin=mysql-bin\nbinlog-format=ROW\nserver-id=1\n\n-- Create backup with binary log position\nmysqldump -h localhost -u root -p --master-data=2 mydb > backup.sql\n\n-- Restore and apply binary logs\nmysql -h localhost -u root -p mydb < backup.sql\nmysqlbinlog --start-position=4 mysql-bin.000001 | mysql -h localhost -u root -p\n\n-- InnoDB backup (Percona XtraBackup)\n-- Full backup\nxtrabackup --backup --target-dir=/backup/full\n\n-- Incremental backup\nxtrabackup --backup --target-dir=/backup/inc1 --incremental-basedir=/backup/full\n\n-- Restore from InnoDB backup\nxtrabackup --prepare --target-dir=/backup/full\nxtrabackup --copy-back --target-dir=/backup/full\n\n-- MySQL replication setup\n-- On master:\n-- In my.cnf:\nserver-id=1\nlog-bin=mysql-bin\nbinlog-format=ROW\n\n-- Create replication user\nCREATE USER 'replica_user'@'%' IDENTIFIED BY 'replica_password';\nGRANT REPLICATION SLAVE ON *.* TO 'replica_user'@'%';\n\n-- On replica:\n-- In my.cnf:\nserver-id=2\nrelay-log=mysql-relay-bin\nread-only=1\n\n-- Start replication\nCHANGE MASTER TO\n    MASTER_HOST='master_host',\n    MASTER_USER='replica_user',\n    MASTER_PASSWORD='replica_password',\n    MASTER_LOG_FILE='mysql-bin.000001',\n    MASTER_LOG_POS=4;\n\nSTART SLAVE;"
        },
        {
          "name": "Performance Monitoring",
          "text": "Monitor MySQL performance metrics and identify bottlenecks for optimization.",
          "code": "-- Check database size\nSELECT \n    table_schema as 'Database',\n    ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS 'Size (MB)'\nFROM information_schema.tables\nGROUP BY table_schema\nORDER BY SUM(data_length + index_length) DESC;\n\n-- Monitor active connections\nSELECT \n    ID,\n    USER,\n    HOST,\n    DB,\n    COMMAND,\n    TIME,\n    STATE,\n    INFO\nFROM information_schema.PROCESSLIST\nWHERE COMMAND != 'Sleep';\n\n-- Check slow queries (requires slow query log)\n-- In my.cnf:\nslow-query-log=1\nslow-query-log-file=/var/log/mysql/slow.log\nlong_query_time=2\n\n-- Analyze slow query log\nmysqldumpslow /var/log/mysql/slow.log\n\n-- Monitor table statistics\nSELECT \n    table_schema,\n    table_name,\n    table_rows,\n    ROUND(((data_length + index_length) / 1024 / 1024), 2) AS 'Size (MB)',\n    ROUND((data_length / 1024 / 1024), 2) AS 'Data Size (MB)',\n    ROUND((index_length / 1024 / 1024), 2) AS 'Index Size (MB)'\nFROM information_schema.tables\nWHERE table_schema = 'mydb'\nORDER BY (data_length + index_length) DESC;\n\n-- MySQL-specific performance monitoring\n-- Check InnoDB status\nSHOW ENGINE INNODB STATUS;\n\n-- Monitor buffer pool usage\nSELECT \n    POOL_ID,\n    POOL_SIZE,\n    FREE_BUFFERS,\n    DATABASE_PAGES,\n    OLD_DATABASE_PAGES,\n    MODIFIED_DATABASE_PAGES\nFROM information_schema.INNODB_BUFFER_POOL_STATS;\n\n-- Check for table locks\nSELECT \n    TABLE_SCHEMA,\n    TABLE_NAME,\n    ENGINE,\n    TABLE_ROWS,\n    AVG_ROW_LENGTH,\n    DATA_LENGTH,\n    MAX_DATA_LENGTH,\n    INDEX_LENGTH,\n    DATA_FREE,\n    AUTO_INCREMENT,\n    CREATE_TIME,\n    UPDATE_TIME,\n    CHECK_TIME,\n    TABLE_COLLATION,\n    CHECKSUM,\n    CREATE_OPTIONS,\n    TABLE_COMMENT\nFROM information_schema.TABLES\nWHERE TABLE_SCHEMA = 'mydb';\n\n-- Monitor replication lag\nSELECT \n    MASTER_HOST,\n    MASTER_PORT,\n    MASTER_USER,\n    MASTER_LOG_FILE,\n    READ_MASTER_LOG_POS,\n    RELAY_LOG_FILE,\n    RELAY_LOG_POS,\n    SLAVE_IO_RUNNING,\n    SLAVE_SQL_RUNNING,\n    SECONDS_BEHIND_MASTER\nFROM information_schema.SLAVE_STATUS;\n\n-- Check query cache status\nSHOW STATUS LIKE 'Qcache%';\n\n-- Monitor thread status\nSHOW STATUS LIKE 'Threads%';\n\n-- Check for long-running queries\nSELECT \n    ID,\n    USER,\n    HOST,\n    DB,\n    COMMAND,\n    TIME,\n    STATE,\n    INFO\nFROM information_schema.PROCESSLIST\nWHERE TIME > 300  -- 5 minutes\n    AND COMMAND != 'Sleep'\nORDER BY TIME DESC;"
        },
        {
          "name": "Maintenance Tasks",
          "text": "Regular maintenance tasks to keep your MySQL database running optimally.",
          "code": "-- Update table statistics\nANALYZE TABLE customers;\nANALYZE TABLE orders;\nANALYZE TABLE order_items;\n\n-- Check table status\nSHOW TABLE STATUS LIKE 'customers';\n\n-- Optimize table (defragments and updates statistics)\nOPTIMIZE TABLE customers;\nOPTIMIZE TABLE orders;\n\n-- Check table fragmentation\nSELECT \n    TABLE_NAME,\n    ENGINE,\n    TABLE_ROWS,\n    AVG_ROW_LENGTH,\n    DATA_LENGTH,\n    INDEX_LENGTH,\n    DATA_FREE,\n    ROUND((DATA_FREE / DATA_LENGTH) * 100, 2) AS 'Fragmentation %'\nFROM information_schema.TABLES\nWHERE TABLE_SCHEMA = 'mydb'\n    AND DATA_LENGTH > 0\nORDER BY DATA_FREE DESC;\n\n-- MySQL-specific maintenance tasks\n-- Check and repair tables\nCHECK TABLE customers, orders, order_items;\nREPAIR TABLE customers, orders, order_items;\n\n-- Flush logs\nFLUSH LOGS;\n\n-- Reset query cache\nRESET QUERY CACHE;\n\n-- Automated maintenance procedure\nDELIMITER //\nCREATE PROCEDURE MaintenanceRoutine()\nBEGIN\n    -- Update statistics\n    ANALYZE TABLE customers, orders, order_items;\n    \n    -- Optimize tables\n    OPTIMIZE TABLE customers, orders, order_items;\n    \n    -- Flush logs\n    FLUSH LOGS;\n    \n    -- Log maintenance completion\n    INSERT INTO maintenance_log (task, completed_at)\n    VALUES ('routine_maintenance', NOW());\nEND //\nDELIMITER ;\n\n-- Schedule maintenance (using MySQL Event Scheduler)\n-- Enable event scheduler\nSET GLOBAL event_scheduler = ON;\n\n-- Create maintenance event\nCREATE EVENT maintenance_event\nON SCHEDULE EVERY 1 WEEK\nSTARTS CURRENT_TIMESTAMP\nDO\n    CALL MaintenanceRoutine();\n\n-- View scheduled events\nSELECT \n    EVENT_NAME,\n    EVENT_DEFINITION,\n    INTERVAL_VALUE,\n    INTERVAL_FIELD,\n    STATUS\nFROM information_schema.EVENTS;\n\n-- Check for unused indexes\nSELECT \n    TABLE_SCHEMA,\n    TABLE_NAME,\n    INDEX_NAME\nFROM performance_schema.table_io_waits_summary_by_index_usage\nWHERE TABLE_SCHEMA = 'mydb'\n    AND COUNT_READ = 0\n    AND COUNT_FETCH = 0\n    AND COUNT_INSERT = 0\n    AND COUNT_UPDATE = 0\n    AND COUNT_DELETE = 0;\n\n-- Monitor InnoDB status\nSHOW ENGINE INNODB STATUS;\n\n-- Check for table locks\nSELECT \n    r.trx_id,\n    r.trx_state,\n    r.trx_started,\n    r.trx_mysql_thread_id,\n    r.trx_query,\n    l.lock_mode,\n    l.lock_type,\n    l.lock_table\nFROM information_schema.innodb_trx r\nLEFT JOIN information_schema.innodb_locks l ON r.trx_id = l.lock_trx_id;\n\n-- Monitor binary log size\nSHOW BINARY LOGS;\n\n-- Purge old binary logs\nPURGE BINARY LOGS TO 'mysql-bin.000010';\n\n-- Check for long-running transactions\nSELECT \n    trx_id,\n    trx_state,\n    trx_started,\n    trx_mysql_thread_id,\n    trx_query\nFROM information_schema.innodb_trx\nWHERE trx_started < DATE_SUB(NOW(), INTERVAL 1 HOUR);"
        }
      ]
    }
  ]
}
