{
  "config": {
    "id": "terraform",
    "name": "Terraform",
    "description": "Infrastructure as Code tool for building, changing, and versioning infrastructure",
    "icon": "üèóÔ∏è",
    "enabled": true
  },
  "content": [
    {
      "id": "terraform-basics",
      "title": "üèóÔ∏è Basics ‚Äî Getting Started",
      "sections": [
        {
          "name": "Installation & Setup",
          "text": "Terraform is an open-source Infrastructure as Code (IaC) tool that enables you to safely and predictably create, change, and improve infrastructure. This section covers installation and basic setup.",
          "code": "# Install Terraform on Ubuntu/Debian\nwget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list\nsudo apt update && sudo apt install terraform\n\n# Install Terraform on macOS\nbrew tap hashicorp/tap\nbrew install hashicorp/tap/terraform\n\n# Install Terraform on Windows\n# Download from: https://www.terraform.io/downloads\n\n# Verify installation\nterraform version\n\n# Initialize Terraform\nterraform init\n\n# Check configuration\nterraform validate\nterraform plan"
        },
        {
          "name": "Basic Configuration",
          "text": "Learn the fundamental structure of Terraform configuration files and how to define infrastructure resources.",
          "code": "# main.tf - Basic Terraform configuration\nterraform {\n  required_version = \">= 1.0\"\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\n# Configure AWS Provider\nprovider \"aws\" {\n  region = \"us-west-2\"\n}\n\n# Create a VPC\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = \"10.0.0.0/16\"\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n\n  tags = {\n    Name = \"main-vpc\"\n  }\n}\n\n# Create a subnet\nresource \"aws_subnet\" \"main\" {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = \"10.0.1.0/24\"\n\n  tags = {\n    Name = \"main-subnet\"\n  }\n}"
        },
        {
          "name": "Terraform Commands",
          "text": "Essential Terraform commands for managing infrastructure lifecycle and configuration.",
          "code": "# Initialize Terraform\nterraform init\n\n# Validate configuration\nterraform validate\n\n# Format configuration files\nterraform fmt\nterraform fmt -recursive  # Format all files\n\n# Plan changes\nterraform plan\nterraform plan -out=tfplan  # Save plan to file\n\n# Apply changes\nterraform apply\nterraform apply -auto-approve  # Skip confirmation\nterraform apply tfplan  # Apply saved plan\n\n# Show current state\nterraform show\nterraform state list\nterraform state show aws_vpc.main\n\n# Destroy infrastructure\nterraform destroy\nterraform destroy -target=aws_vpc.main  # Destroy specific resource\n\n# Refresh state\nterraform refresh\nterraform plan -refresh-only"
        },
        {
          "name": "Variables and Outputs",
          "text": "Use variables for configuration flexibility and outputs to expose important values.",
          "code": "# variables.tf\nvariable \"aws_region\" {\n  description = \"AWS region\"\n  type        = string\n  default     = \"us-west-2\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name\"\n  type        = string\n  validation {\n    condition     = contains([\"dev\", \"staging\", \"prod\"], var.environment)\n    error_message = \"Environment must be dev, staging, or prod.\"\n  }\n}\n\nvariable \"instance_count\" {\n  description = \"Number of instances\"\n  type        = number\n  default     = 1\n}\n\n# outputs.tf\noutput \"vpc_id\" {\n  description = \"ID of the VPC\"\n  value       = aws_vpc.main.id\n}\n\noutput \"subnet_id\" {\n  description = \"ID of the subnet\"\n  value       = aws_subnet.main.id\n}\n\noutput \"vpc_cidr\" {\n  description = \"CIDR block of the VPC\"\n  value       = aws_vpc.main.cidr_block\n}\n\n# terraform.tfvars\naws_region     = \"us-west-2\"\nenvironment    = \"dev\"\ninstance_count = 2"
        }
      ]
    },
    {
      "id": "terraform-providers",
      "title": "üîå Providers ‚Äî Cloud Integration",
      "sections": [
        {
          "name": "AWS Provider",
          "text": "Configure and use the AWS provider to manage AWS resources with Terraform.",
          "code": "# AWS Provider configuration\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Environment = var.environment\n      Project     = \"terraform-demo\"\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n\n# Create EC2 instance\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c02fb55956c7d316\"  # Amazon Linux 2\n  instance_type = \"t3.micro\"\n  subnet_id     = aws_subnet.main.id\n\n  vpc_security_group_ids = [aws_security_group.web.id]\n\n  user_data = <<-EOF\n    #!/bin/bash\n    yum update -y\n    yum install -y httpd\n    systemctl start httpd\n    systemctl enable httpd\n    echo \"<h1>Hello from Terraform!</h1>\" > /var/www/html/index.html\n  EOF\n\n  tags = {\n    Name = \"web-server\"\n  }\n}\n\n# Create security group\nresource \"aws_security_group\" \"web\" {\n  name_prefix = \"web-sg-\"\n  vpc_id      = aws_vpc.main.id\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"10.0.0.0/16\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
        },
        {
          "name": "Azure Provider",
          "text": "Configure and use the Azure provider to manage Azure resources with Terraform.",
          "code": "# Azure Provider configuration\nterraform {\n  required_providers {\n    azurerm = {\n      source  = \"hashicorp/azurerm\"\n      version = \"~> 3.0\"\n    }\n  }\n}\n\nprovider \"azurerm\" {\n  features {}\n}\n\n# Create resource group\nresource \"azurerm_resource_group\" \"main\" {\n  name     = \"rg-${var.environment}-${var.project_name}\"\n  location = var.azure_location\n\n  tags = {\n    Environment = var.environment\n    Project     = var.project_name\n  }\n}\n\n# Create virtual network\nresource \"azurerm_virtual_network\" \"main\" {\n  name                = \"vnet-${var.environment}\"\n  address_space       = [\"10.0.0.0/16\"]\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n}\n\n# Create subnet\nresource \"azurerm_subnet\" \"main\" {\n  name                 = \"subnet-${var.environment}\"\n  resource_group_name  = azurerm_resource_group.main.name\n  virtual_network_name = azurerm_virtual_network.main.name\n  address_prefixes     = [\"10.0.1.0/24\"]\n}\n\n# Create network security group\nresource \"azurerm_network_security_group\" \"main\" {\n  name                = \"nsg-${var.environment}\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n\n  security_rule {\n    name                       = \"AllowHTTP\"\n    priority                   = 1001\n    direction                  = \"Inbound\"\n    access                     = \"Allow\"\n    protocol                   = \"Tcp\"\n    source_port_range          = \"*\"\n    destination_port_range     = \"80\"\n    source_address_prefix      = \"*\"\n    destination_address_prefix = \"*\"\n  }\n}"
        },
        {
          "name": "Google Cloud Provider",
          "text": "Configure and use the Google Cloud provider to manage GCP resources with Terraform.",
          "code": "# Google Cloud Provider configuration\nterraform {\n  required_providers {\n    google = {\n      source  = \"hashicorp/google\"\n      version = \"~> 4.0\"\n    }\n  }\n}\n\nprovider \"google\" {\n  project = var.gcp_project_id\n  region  = var.gcp_region\n}\n\n# Create VPC network\nresource \"google_compute_network\" \"main\" {\n  name                    = \"vpc-${var.environment}\"\n  auto_create_subnetworks = false\n}\n\n# Create subnet\nresource \"google_compute_subnetwork\" \"main\" {\n  name          = \"subnet-${var.environment}\"\n  ip_cidr_range = \"10.0.1.0/24\"\n  region        = var.gcp_region\n  network       = google_compute_network.main.id\n}\n\n# Create firewall rule\nresource \"google_compute_firewall\" \"allow_http\" {\n  name    = \"allow-http-${var.environment}\"\n  network = google_compute_network.main.name\n\n  allow {\n    protocol = \"tcp\"\n    ports    = [\"80\"]\n  }\n\n  source_ranges = [\"0.0.0.0/0\"]\n  target_tags   = [\"http-server\"]\n}\n\n# Create compute instance\nresource \"google_compute_instance\" \"web\" {\n  name         = \"web-server-${var.environment}\"\n  machine_type = \"e2-micro\"\n  zone         = \"${var.gcp_region}-a\"\n\n  boot_disk {\n    initialize_params {\n      image = \"debian-cloud/debian-11\"\n    }\n  }\n\n  network_interface {\n    network    = google_compute_network.main.name\n    subnetwork = google_compute_subnetwork.main.name\n\n    access_config {\n      // Ephemeral public IP\n    }\n  }\n\n  metadata_startup_script = <<-EOF\n    #!/bin/bash\n    apt-get update\n    apt-get install -y apache2\n    systemctl start apache2\n    systemctl enable apache2\n    echo \"<h1>Hello from Terraform on GCP!</h1>\" > /var/www/html/index.html\n  EOF\n\n  tags = [\"http-server\"]\n}"
        },
        {
          "name": "Docker Provider",
          "text": "Use the Docker provider to manage Docker containers and images with Terraform.",
          "code": "# Docker Provider configuration\nterraform {\n  required_providers {\n    docker = {\n      source  = \"kreuzwerker/docker\"\n      version = \"~> 3.0\"\n    }\n  }\n}\n\nprovider \"docker\" {\n  host = \"unix:///var/run/docker.sock\"\n}\n\n# Pull Docker image\nresource \"docker_image\" \"nginx\" {\n  name = \"nginx:alpine\"\n}\n\n# Create Docker network\nresource \"docker_network\" \"main\" {\n  name = \"terraform-network\"\n}\n\n# Create Docker volume\nresource \"docker_volume\" \"main\" {\n  name = \"terraform-volume\"\n}\n\n# Create Docker container\nresource \"docker_container\" \"web\" {\n  image = docker_image.nginx.image_id\n  name  = \"web-container\"\n\n  ports {\n    internal = 80\n    external = 8080\n  }\n\n  volumes {\n    volume_name    = docker_volume.main.name\n    container_path = \"/usr/share/nginx/html\"\n  }\n\n  networks_advanced {\n    name = docker_network.main.name\n  }\n\n  restart = \"unless-stopped\"\n\n  env = [\n    \"NGINX_HOST=localhost\",\n    \"NGINX_PORT=80\"\n  ]\n}"
        }
      ]
    },
    {
      "id": "terraform-modules",
      "title": "üì¶ Modules ‚Äî Reusable Components",
      "sections": [
        {
          "name": "Creating Modules",
          "text": "Learn how to create reusable Terraform modules to organize and share infrastructure code.",
          "code": "# modules/vpc/main.tf\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for VPC\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name\"\n  type        = string\n}\n\nvariable \"availability_zones\" {\n  description = \"List of availability zones\"\n  type        = list(string)\n  default     = [\"us-west-2a\", \"us-west-2b\"]\n}\n\n# Create VPC\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n\n  tags = {\n    Name        = \"${var.environment}-vpc\"\n    Environment = var.environment\n  }\n}\n\n# Create Internet Gateway\nresource \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n\n  tags = {\n    Name        = \"${var.environment}-igw\"\n    Environment = var.environment\n  }\n}\n\n# Create subnets\nresource \"aws_subnet\" \"public\" {\n  count = length(var.availability_zones)\n\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index)\n  availability_zone       = var.availability_zones[count.index]\n  map_public_ip_on_launch = true\n\n  tags = {\n    Name        = \"${var.environment}-public-subnet-${count.index + 1}\"\n    Environment = var.environment\n    Type        = \"public\"\n  }\n}\n\nresource \"aws_subnet\" \"private\" {\n  count = length(var.availability_zones)\n\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = cidrsubnet(var.vpc_cidr, 8, count.index + 10)\n  availability_zone = var.availability_zones[count.index]\n\n  tags = {\n    Name        = \"${var.environment}-private-subnet-${count.index + 1}\"\n    Environment = var.environment\n    Type        = \"private\"\n  }\n}\n\n# modules/vpc/outputs.tf\noutput \"vpc_id\" {\n  description = \"ID of the VPC\"\n  value       = aws_vpc.main.id\n}\n\noutput \"vpc_cidr_block\" {\n  description = \"CIDR block of the VPC\"\n  value       = aws_vpc.main.cidr_block\n}\n\noutput \"public_subnet_ids\" {\n  description = \"IDs of the public subnets\"\n  value       = aws_subnet.public[*].id\n}\n\noutput \"private_subnet_ids\" {\n  description = \"IDs of the private subnets\"\n  value       = aws_subnet.private[*].id\n}\n\noutput \"internet_gateway_id\" {\n  description = \"ID of the Internet Gateway\"\n  value       = aws_internet_gateway.main.id\n}"
        },
        {
          "name": "Using Modules",
          "text": "Learn how to use Terraform modules in your configurations for better organization and reusability.",
          "code": "# main.tf - Using the VPC module\nmodule \"vpc\" {\n  source = \"./modules/vpc\"\n\n  vpc_cidr          = \"10.0.0.0/16\"\n  environment       = var.environment\n  availability_zones = [\"us-west-2a\", \"us-west-2b\", \"us-west-2c\"]\n}\n\n# Create security group using module outputs\nresource \"aws_security_group\" \"web\" {\n  name_prefix = \"web-sg-\"\n  vpc_id      = module.vpc.vpc_id\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name        = \"${var.environment}-web-sg\"\n    Environment = var.environment\n  }\n}\n\n# Create EC2 instance in public subnet\nresource \"aws_instance\" \"web\" {\n  count = var.instance_count\n\n  ami           = \"ami-0c02fb55956c7d316\"\n  instance_type = \"t3.micro\"\n  subnet_id     = module.vpc.public_subnet_ids[count.index % length(module.vpc.public_subnet_ids)]\n\n  vpc_security_group_ids = [aws_security_group.web.id]\n\n  user_data = <<-EOF\n    #!/bin/bash\n    yum update -y\n    yum install -y httpd\n    systemctl start httpd\n    systemctl enable httpd\n    echo \"<h1>Hello from Terraform Module!</h1>\" > /var/www/html/index.html\n  EOF\n\n  tags = {\n    Name        = \"${var.environment}-web-${count.index + 1}\"\n    Environment = var.environment\n  }\n}"
        },
        {
          "name": "Module Registry",
          "text": "Use modules from the Terraform Registry and publish your own modules for sharing.",
          "code": "# Using modules from Terraform Registry\nmodule \"vpc\" {\n  source = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 5.0\"\n\n  name = \"${var.environment}-vpc\"\n  cidr = \"10.0.0.0/16\"\n\n  azs             = [\"us-west-2a\", \"us-west-2b\", \"us-west-2c\"]\n  private_subnets = [\"10.0.1.0/24\", \"10.0.2.0/24\", \"10.0.3.0/24\"]\n  public_subnets  = [\"10.0.101.0/24\", \"10.0.102.0/24\", \"10.0.103.0/24\"]\n\n  enable_nat_gateway = true\n  enable_vpn_gateway = false\n\n  tags = {\n    Environment = var.environment\n    Terraform   = \"true\"\n  }\n}\n\n# Using EKS module\nmodule \"eks\" {\n  source = \"terraform-aws-modules/eks/aws\"\n  version = \"~> 19.0\"\n\n  cluster_name    = \"${var.environment}-eks\"\n  cluster_version = \"1.28\"\n\n  vpc_id                         = module.vpc.vpc_id\n  subnet_ids                     = module.vpc.private_subnets\n  cluster_endpoint_public_access = true\n\n  # EKS Managed Node Groups\n  eks_managed_node_groups = {\n    main = {\n      min_size     = 1\n      max_size     = 3\n      desired_size = 2\n\n      instance_types = [\"t3.medium\"]\n    }\n  }\n\n  tags = {\n    Environment = var.environment\n    Terraform   = \"true\"\n  }\n}\n\n# Using RDS module\nmodule \"rds\" {\n  source = \"terraform-aws-modules/rds/aws\"\n  version = \"~> 6.0\"\n\n  identifier = \"${var.environment}-rds\"\n\n  engine            = \"postgres\"\n  engine_version    = \"15.4\"\n  instance_class    = \"db.t3.micro\"\n  allocated_storage = 20\n\n  db_name  = \"myapp\"\n  username = \"dbuser\"\n  password = var.db_password\n\n  vpc_security_group_ids = [aws_security_group.rds.id]\n  db_subnet_group_name   = aws_db_subnet_group.main.name\n\n  backup_retention_period = 7\n  backup_window          = \"03:00-04:00\"\n  maintenance_window     = \"Mon:04:00-Mon:05:00\"\n\n  tags = {\n    Environment = var.environment\n    Terraform   = \"true\"\n  }\n}"
        },
        {
          "name": "Module Best Practices",
          "text": "Follow best practices when creating and using Terraform modules for maintainable infrastructure code.",
          "code": "# modules/ec2/variables.tf\nvariable \"instance_type\" {\n  description = \"EC2 instance type\"\n  type        = string\n  default     = \"t3.micro\"\n\n  validation {\n    condition     = can(regex(\"^[a-z][0-9]+\\.[a-z]+\", var.instance_type))\n    error_message = \"Instance type must be valid EC2 instance type.\"\n  }\n}\n\nvariable \"ami_id\" {\n  description = \"AMI ID for the instance\"\n  type        = string\n}\n\nvariable \"subnet_id\" {\n  description = \"Subnet ID where instance will be created\"\n  type        = string\n}\n\nvariable \"security_group_ids\" {\n  description = \"List of security group IDs\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"key_name\" {\n  description = \"EC2 Key Pair name\"\n  type        = string\n  default     = null\n}\n\nvariable \"user_data\" {\n  description = \"User data script\"\n  type        = string\n  default     = \"\"\n}\n\nvariable \"tags\" {\n  description = \"Tags to apply to the instance\"\n  type        = map(string)\n  default     = {}\n}\n\n# modules/ec2/main.tf\nresource \"aws_instance\" \"this\" {\n  ami                    = var.ami_id\n  instance_type          = var.instance_type\n  subnet_id              = var.subnet_id\n  vpc_security_group_ids = var.security_group_ids\n  key_name               = var.key_name\n  user_data              = var.user_data\n\n  root_block_device {\n    volume_type           = \"gp3\"\n    volume_size          = 20\n    delete_on_termination = true\n    encrypted            = true\n  }\n\n  tags = merge(\n    {\n      Name = \"${var.tags.Name}-instance\"\n    },\n    var.tags\n  )\n}\n\n# modules/ec2/outputs.tf\noutput \"instance_id\" {\n  description = \"ID of the EC2 instance\"\n  value       = aws_instance.this.id\n}\n\noutput \"instance_arn\" {\n  description = \"ARN of the EC2 instance\"\n  value       = aws_instance.this.arn\n}\n\noutput \"public_ip\" {\n  description = \"Public IP address of the instance\"\n  value       = aws_instance.this.public_ip\n}\n\noutput \"private_ip\" {\n  description = \"Private IP address of the instance\"\n  value       = aws_instance.this.private_ip\n}\n\n# modules/ec2/versions.tf\nterraform {\n  required_version = \">= 1.0\"\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}"
        }
      ]
    },
    {
      "id": "terraform-state",
      "title": "üíæ State ‚Äî State Management",
      "sections": [
        {
          "name": "State File Basics",
          "text": "Understand Terraform state files and how they track the current state of your infrastructure.",
          "code": "# Understanding Terraform state\n# State file location: terraform.tfstate\n\n# View current state\nterraform show\nterraform state list\nterraform state show aws_vpc.main\n\n# State file structure (terraform.tfstate)\n{\n  \"version\": 4,\n  \"terraform_version\": \"1.6.0\",\n  \"serial\": 1,\n  \"lineage\": \"abc123...\",\n  \"outputs\": {},\n  \"resources\": [\n    {\n      \"mode\": \"managed\",\n      \"type\": \"aws_vpc\",\n      \"name\": \"main\",\n      \"provider\": \"provider[\\\"registry.terraform.io/hashicorp/aws\\\"]\",\n      \"instances\": [\n        {\n          \"schema_version\": 1,\n          \"attributes\": {\n            \"arn\": \"arn:aws:ec2:us-west-2:123456789012:vpc/vpc-12345678\",\n            \"cidr_block\": \"10.0.0.0/16\",\n            \"enable_dns_hostnames\": true,\n            \"enable_dns_support\": true,\n            \"id\": \"vpc-12345678\",\n            \"tags\": {\n              \"Name\": \"main-vpc\"\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n\n# State operations\nterraform state mv aws_vpc.old aws_vpc.new  # Rename resource\nterraform state rm aws_vpc.main  # Remove from state\nterraform import aws_vpc.main vpc-12345678  # Import existing resource"
        },
        {
          "name": "Remote State Storage",
          "text": "Configure remote state storage using AWS S3, Azure Storage, or Google Cloud Storage for team collaboration.",
          "code": "# backend.tf - S3 backend configuration\nterraform {\n  backend \"s3\" {\n    bucket         = \"my-terraform-state-bucket\"\n    key            = \"dev/terraform.tfstate\"\n    region         = \"us-west-2\"\n    encrypt        = true\n    dynamodb_table = \"terraform-state-lock\"\n  }\n}\n\n# Initialize with backend\nterraform init\n\n# Azure Storage backend\nterraform {\n  backend \"azurerm\" {\n    resource_group_name  = \"terraform-state-rg\"\n    storage_account_name = \"terraformstate123\"\n    container_name       = \"tfstate\"\n    key                  = \"dev.terraform.tfstate\"\n  }\n}\n\n# Google Cloud Storage backend\nterraform {\n  backend \"gcs\" {\n    bucket = \"my-terraform-state-bucket\"\n    prefix = \"dev/terraform.tfstate\"\n  }\n}\n\n# Terraform Cloud backend\nterraform {\n  backend \"remote\" {\n    organization = \"my-org\"\n\n    workspaces {\n      name = \"dev\"\n    }\n  }\n}\n\n# State locking with DynamoDB\nresource \"aws_dynamodb_table\" \"terraform_state_lock\" {\n  name           = \"terraform-state-lock\"\n  billing_mode   = \"PAY_PER_REQUEST\"\n  hash_key       = \"LockID\"\n\n  attribute {\n    name = \"LockID\"\n    type = \"S\"\n  }\n\n  tags = {\n    Name        = \"Terraform State Lock Table\"\n    Environment = \"shared\"\n  }\n}"
        },
        {
          "name": "State Import and Migration",
          "text": "Import existing infrastructure into Terraform state and migrate resources between configurations.",
          "code": "# Import existing AWS VPC\nterraform import aws_vpc.main vpc-12345678\n\n# Import existing EC2 instance\nterraform import aws_instance.web i-1234567890abcdef0\n\n# Import existing S3 bucket\nterraform import aws_s3_bucket.my_bucket my-bucket-name\n\n# Import existing RDS instance\nterraform import aws_db_instance.main mydb\n\n# Import existing security group\nterraform import aws_security_group.web sg-12345678\n\n# State migration example\n# 1. Create new configuration\nresource \"aws_vpc\" \"new_vpc\" {\n  cidr_block = \"10.1.0.0/16\"\n  tags = {\n    Name = \"new-vpc\"\n  }\n}\n\n# 2. Move resource in state\nterraform state mv aws_vpc.main aws_vpc.new_vpc\n\n# 3. Update configuration to match new resource name\n\n# Import multiple resources with script\n#!/bin/bash\n\n# Import VPC\nterraform import aws_vpc.main vpc-12345678\n\n# Import subnets\nterraform import aws_subnet.public[0] subnet-12345678\nterraform import aws_subnet.public[1] subnet-87654321\n\n# Import security groups\nterraform import aws_security_group.web sg-12345678\n\n# Import EC2 instances\nterraform import aws_instance.web[0] i-1234567890abcdef0\nterraform import aws_instance.web[1] i-0987654321fedcba0"
        },
        {
          "name": "State Troubleshooting",
          "text": "Common state issues and how to resolve them when working with Terraform state.",
          "code": "# Common state issues and solutions\n\n# 1. State file corruption\n# Backup current state\ncp terraform.tfstate terraform.tfstate.backup\n\n# Refresh state from actual infrastructure\nterraform refresh\n\n# 2. Resource drift detection\nterraform plan -detailed-exitcode\n\n# Exit codes:\n# 0 = No changes\n# 1 = Error\n# 2 = Changes detected\n\n# 3. State lock issues\n# Check for locks\nterraform force-unlock <lock-id>\n\n# 4. Resource not found in state\n# Check if resource exists in AWS\naws ec2 describe-vpcs --vpc-ids vpc-12345678\n\n# Import if exists\nterraform import aws_vpc.main vpc-12345678\n\n# 5. State file too large\n# Split into multiple state files\n# Use modules and workspaces\n\n# 6. Concurrent modifications\n# Use state locking (DynamoDB)\n# Implement CI/CD with proper state management\n\n# State validation script\n#!/bin/bash\n\necho \"Validating Terraform state...\"\n\n# Check state file exists\nif [ ! -f \"terraform.tfstate\" ]; then\n  echo \"Error: terraform.tfstate not found\"\n  exit 1\nfi\n\n# Validate configuration\nterraform validate\nif [ $? -ne 0 ]; then\n  echo \"Error: Configuration validation failed\"\n  exit 1\nfi\n\n# Check for drift\nterraform plan -detailed-exitcode\ncase $? in\n  0)\n    echo \"No changes detected\"\n    ;;\n  1)\n    echo \"Error during plan\"\n    exit 1\n    ;;\n  2)\n    echo \"Changes detected - review plan\"\n    ;;\nesac\n\necho \"State validation complete\""
        }
      ]
    },
    {
      "id": "terraform-workspaces",
      "title": "üè¢ Workspaces ‚Äî Environment Management",
      "sections": [
        {
          "name": "Workspace Basics",
          "text": "Use Terraform workspaces to manage multiple environments (dev, staging, prod) with the same configuration.",
          "code": "# List workspaces\nterraform workspace list\n\n# Create new workspace\nterraform workspace new dev\nterraform workspace new staging\nterraform workspace new prod\n\n# Select workspace\nterraform workspace select dev\nterraform workspace select staging\nterraform workspace select prod\n\n# Show current workspace\nterraform workspace show\n\n# Delete workspace\nterraform workspace delete old-workspace\n\n# Workspace-specific variables\n# terraform.tfvars.dev\nenvironment = \"dev\"\ninstance_count = 1\ninstance_type = \"t3.micro\"\n\n# terraform.tfvars.staging\nenvironment = \"staging\"\ninstance_count = 2\ninstance_type = \"t3.small\"\n\n# terraform.tfvars.prod\nenvironment = \"prod\"\ninstance_count = 3\ninstance_type = \"t3.medium\"\n\n# Load workspace-specific variables\nterraform apply -var-file=\"terraform.tfvars.$(terraform workspace show)\"\n\n# Workspace-aware configuration\nresource \"aws_instance\" \"web\" {\n  count = var.instance_count\n\n  ami           = \"ami-0c02fb55956c7d316\"\n  instance_type = var.instance_type\n  subnet_id     = aws_subnet.main.id\n\n  tags = {\n    Name        = \"${terraform.workspace}-web-${count.index + 1}\"\n    Environment = terraform.workspace\n    Workspace   = terraform.workspace\n  }\n}"
        },
        {
          "name": "Environment-Specific Configurations",
          "text": "Create environment-specific configurations using workspaces and conditional logic.",
          "code": "# variables.tf\nvariable \"environment\" {\n  description = \"Environment name\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"instance_count\" {\n  description = \"Number of instances\"\n  type        = number\n  default     = 1\n}\n\nvariable \"instance_type\" {\n  description = \"EC2 instance type\"\n  type        = string\n  default     = \"t3.micro\"\n}\n\nvariable \"enable_monitoring\" {\n  description = \"Enable CloudWatch monitoring\"\n  type        = bool\n  default     = false\n}\n\n# Environment-specific configurations\nlocals {\n  environment_config = {\n    dev = {\n      instance_count = 1\n      instance_type  = \"t3.micro\"\n      enable_monitoring = false\n      backup_retention = 1\n    }\n    staging = {\n      instance_count = 2\n      instance_type  = \"t3.small\"\n      enable_monitoring = true\n      backup_retention = 7\n    }\n    prod = {\n      instance_count = 3\n      instance_type  = \"t3.medium\"\n      enable_monitoring = true\n      backup_retention = 30\n    }\n  }\n\n  config = local.environment_config[var.environment]\n}\n\n# Use environment-specific configuration\nresource \"aws_instance\" \"web\" {\n  count = local.config.instance_count\n\n  ami           = \"ami-0c02fb55956c7d316\"\n  instance_type = local.config.instance_type\n  subnet_id     = aws_subnet.main.id\n\n  monitoring = local.config.enable_monitoring\n\n  tags = {\n    Name        = \"${var.environment}-web-${count.index + 1}\"\n    Environment = var.environment\n    Monitoring  = local.config.enable_monitoring\n  }\n}\n\n# Conditional resources based on environment\nresource \"aws_cloudwatch_log_group\" \"web\" {\n  count = local.config.enable_monitoring ? 1 : 0\n\n  name              = \"/aws/ec2/${var.environment}-web\"\n  retention_in_days = 14\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\n# Environment-specific RDS configuration\nresource \"aws_db_instance\" \"main\" {\n  identifier = \"${var.environment}-database\"\n\n  engine         = \"postgres\"\n  engine_version = \"15.4\"\n  instance_class = var.environment == \"prod\" ? \"db.t3.medium\" : \"db.t3.micro\"\n  allocated_storage = var.environment == \"prod\" ? 100 : 20\n\n  db_name  = \"myapp\"\n  username = \"dbuser\"\n  password = var.db_password\n\n  backup_retention_period = local.config.backup_retention\n  backup_window          = \"03:00-04:00\"\n  maintenance_window      = \"Mon:04:00-Mon:05:00\"\n\n  skip_final_snapshot = var.environment != \"prod\"\n\n  tags = {\n    Environment = var.environment\n  }\n}"
        },
        {
          "name": "Workspace Automation",
          "text": "Automate workspace management using scripts and CI/CD pipelines for efficient environment management.",
          "code": "# deploy.sh - Automated workspace deployment\n#!/bin/bash\n\nset -e\n\nENVIRONMENT=$1\nif [ -z \"$ENVIRONMENT\" ]; then\n  echo \"Usage: $0 <environment>\"\n  echo \"Environments: dev, staging, prod\"\n  exit 1\nfi\n\n# Validate environment\nif [[ ! \"$ENVIRONMENT\" =~ ^(dev|staging|prod)$ ]]; then\n  echo \"Error: Invalid environment. Must be dev, staging, or prod\"\n  exit 1\nfi\n\necho \"Deploying to $ENVIRONMENT environment...\"\n\n# Select or create workspace\nterraform workspace select \"$ENVIRONMENT\" || terraform workspace new \"$ENVIRONMENT\"\n\n# Load environment-specific variables\nVAR_FILE=\"terraform.tfvars.$ENVIRONMENT\"\nif [ -f \"$VAR_FILE\" ]; then\n  echo \"Loading variables from $VAR_FILE\"\n  TF_VAR_FILE=\"-var-file=$VAR_FILE\"\nelse\n  echo \"Warning: $VAR_FILE not found, using default variables\"\n  TF_VAR_FILE=\"\"\nfi\n\n# Initialize Terraform\nterraform init\n\n# Validate configuration\nterraform validate\n\n# Plan changes\nterraform plan $TF_VAR_FILE -out=\"$ENVIRONMENT.tfplan\"\n\n# Apply changes (with confirmation for prod)\nif [ \"$ENVIRONMENT\" = \"prod\" ]; then\n  echo \"Production deployment requires manual confirmation\"\n  terraform apply \"$ENVIRONMENT.tfplan\"\nelse\n  echo \"Auto-applying changes for $ENVIRONMENT\"\n  terraform apply -auto-approve \"$ENVIRONMENT.tfplan\"\nfi\n\necho \"Deployment to $ENVIRONMENT completed successfully\"\n\n# Clean up plan file\nrm -f \"$ENVIRONMENT.tfplan\"\n\n# GitHub Actions workflow\nname: 'Terraform Deploy'\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  terraform:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment: [dev, staging]\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Setup Terraform\n      uses: hashicorp/setup-terraform@v2\n      with:\n        terraform_version: 1.6.0\n    \n    - name: Terraform Init\n      run: terraform init\n      env:\n        TF_WORKSPACE: ${{ matrix.environment }}\n    \n    - name: Terraform Validate\n      run: terraform validate\n    \n    - name: Terraform Plan\n      run: terraform plan -var-file=\"terraform.tfvars.${{ matrix.environment }}\"\n      env:\n        TF_WORKSPACE: ${{ matrix.environment }}\n    \n    - name: Terraform Apply\n      if: github.ref == 'refs/heads/main'\n      run: terraform apply -auto-approve -var-file=\"terraform.tfvars.${{ matrix.environment }}\"\n      env:\n        TF_WORKSPACE: ${{ matrix.environment }}\n        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}"
        },
        {
          "name": "Workspace Best Practices",
          "text": "Follow best practices when using Terraform workspaces for production-ready environment management.",
          "code": "# Workspace naming convention\n# Use descriptive names: dev, staging, prod, feature-branch-name\n\n# Workspace-specific state files\n# Each workspace maintains separate state\n# terraform.tfstate.d/dev/terraform.tfstate\n# terraform.tfstate.d/staging/terraform.tfstate\n# terraform.tfstate.d/prod/terraform.tfstate\n\n# Environment-specific variable files\n# terraform.tfvars.dev\nenvironment = \"dev\"\ninstance_count = 1\ninstance_type = \"t3.micro\"\nenable_monitoring = false\n\n# terraform.tfvars.staging\nenvironment = \"staging\"\ninstance_count = 2\ninstance_type = \"t3.small\"\nenable_monitoring = true\n\n# terraform.tfvars.prod\nenvironment = \"prod\"\ninstance_count = 3\ninstance_type = \"t3.medium\"\nenable_monitoring = true\n\n# Workspace-aware resource naming\nresource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n\n  tags = {\n    Name        = \"${terraform.workspace}-vpc\"\n    Environment = terraform.workspace\n    ManagedBy   = \"terraform\"\n  }\n}\n\n# Conditional resources based on workspace\nresource \"aws_cloudwatch_alarm\" \"high_cpu\" {\n  count = terraform.workspace == \"prod\" ? 1 : 0\n\n  alarm_name          = \"${terraform.workspace}-high-cpu\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = \"2\"\n  metric_name         = \"CPUUtilization\"\n  namespace           = \"AWS/EC2\"\n  period              = \"120\"\n  statistic           = \"Average\"\n  threshold           = \"80\"\n  alarm_description   = \"This metric monitors ec2 cpu utilization\"\n\n  dimensions = {\n    InstanceId = aws_instance.web[0].id\n  }\n\n  tags = {\n    Environment = terraform.workspace\n  }\n}\n\n# Workspace-specific outputs\noutput \"vpc_id\" {\n  description = \"ID of the VPC\"\n  value       = aws_vpc.main.id\n}\n\noutput \"environment\" {\n  description = \"Current environment\"\n  value       = terraform.workspace\n}\n\noutput \"instance_count\" {\n  description = \"Number of instances\"\n  value       = var.instance_count\n}\n\n# Workspace management script\n#!/bin/bash\n\n# workspace-manager.sh\n\ncase \"$1\" in\n  \"list\")\n    terraform workspace list\n    ;;\n  \"create\")\n    if [ -z \"$2\" ]; then\n      echo \"Usage: $0 create <workspace-name>\"\n      exit 1\n    fi\n    terraform workspace new \"$2\"\n    ;;\n  \"select\")\n    if [ -z \"$2\" ]; then\n      echo \"Usage: $0 select <workspace-name>\"\n      exit 1\n    fi\n    terraform workspace select \"$2\"\n    ;;\n  \"delete\")\n    if [ -z \"$2\" ]; then\n      echo \"Usage: $0 delete <workspace-name>\"\n      exit 1\n    fi\n    terraform workspace select default\n    terraform workspace delete \"$2\"\n    ;;\n  \"show\")\n    terraform workspace show\n    ;;\n  *)\n    echo \"Usage: $0 {list|create|select|delete|show}\"\n    echo \"  list   - List all workspaces\"\n    echo \"  create - Create new workspace\"\n    echo \"  select - Select workspace\"\n    echo \"  delete - Delete workspace\"\n    echo \"  show   - Show current workspace\"\n    exit 1\n    ;;\nesac"
        }
      ]
    },
    {
      "id": "terraform-security",
      "title": "üîí Security ‚Äî Best Practices",
      "sections": [
        {
          "name": "Secrets Management",
          "text": "Secure handling of sensitive data in Terraform configurations using proper secrets management practices.",
          "code": "# Never hardcode secrets in configuration files\n# ‚ùå Bad - Never do this\n# resource \"aws_db_instance\" \"main\" {\n#   password = \"mypassword123\"\n# }\n\n# ‚úÖ Good - Use variables\nvariable \"db_password\" {\n  description = \"Database password\"\n  type        = string\n  sensitive   = true\n}\n\nresource \"aws_db_instance\" \"main\" {\n  password = var.db_password\n}\n\n# Use environment variables\nexport TF_VAR_db_password=\"$(aws secretsmanager get-secret-value --secret-id db-password --query SecretString --output text)\"\n\n# Use AWS Secrets Manager\nresource \"aws_secretsmanager_secret\" \"db_password\" {\n  name = \"db-password\"\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\nresource \"aws_secretsmanager_secret_version\" \"db_password\" {\n  secret_id     = aws_secretsmanager_secret.db_password.id\n  secret_string = random_password.db_password.result\n}\n\nresource \"random_password\" \"db_password\" {\n  length  = 16\n  special = true\n}\n\n# Use AWS Systems Manager Parameter Store\nresource \"aws_ssm_parameter\" \"db_password\" {\n  name  = \"/${var.environment}/database/password\"\n  type  = \"SecureString\"\n  value = random_password.db_password.result\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\n# Reference parameter in configuration\ndata \"aws_ssm_parameter\" \"db_password\" {\n  name = \"/${var.environment}/database/password\"\n}\n\nresource \"aws_db_instance\" \"main\" {\n  password = data.aws_ssm_parameter.db_password.value\n}"
        },
        {
          "name": "IAM and Access Control",
          "text": "Implement proper IAM policies and access controls for Terraform-managed resources.",
          "code": "# Create IAM role for EC2 instances\nresource \"aws_iam_role\" \"ec2_role\" {\n  name = \"${var.environment}-ec2-role\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ec2.amazonaws.com\"\n        }\n      }\n    ]\n  })\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\n# Create IAM policy for S3 access\nresource \"aws_iam_policy\" \"s3_access\" {\n  name = \"${var.environment}-s3-access\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"s3:GetObject\",\n          \"s3:PutObject\",\n          \"s3:DeleteObject\"\n        ]\n        Resource = \"arn:aws:s3:::${var.environment}-bucket/*\"\n      },\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"s3:ListBucket\"\n        ]\n        Resource = \"arn:aws:s3:::${var.environment}-bucket\"\n      }\n    ]\n  })\n}\n\n# Attach policy to role\nresource \"aws_iam_role_policy_attachment\" \"ec2_s3\" {\n  role       = aws_iam_role.ec2_role.name\n  policy_arn = aws_iam_policy.s3_access.arn\n}\n\n# Create instance profile\nresource \"aws_iam_instance_profile\" \"ec2_profile\" {\n  name = \"${var.environment}-ec2-profile\"\n  role = aws_iam_role.ec2_role.name\n}\n\n# Use instance profile in EC2 instance\nresource \"aws_instance\" \"web\" {\n  ami                  = \"ami-0c02fb55956c7d316\"\n  instance_type        = \"t3.micro\"\n  iam_instance_profile = aws_iam_instance_profile.ec2_profile.name\n\n  tags = {\n    Name        = \"${var.environment}-web\"\n    Environment = var.environment\n  }\n}\n\n# Terraform execution role (for CI/CD)\nresource \"aws_iam_role\" \"terraform_execution\" {\n  name = \"${var.environment}-terraform-execution\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          AWS = \"arn:aws:iam::${var.aws_account_id}:root\"\n        }\n        Condition = {\n          StringEquals = {\n            \"sts:ExternalId\" = var.terraform_external_id\n          }\n        }\n      }\n    ]\n  })\n}\n\n# Terraform execution policy\nresource \"aws_iam_policy\" \"terraform_execution\" {\n  name = \"${var.environment}-terraform-execution\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"ec2:*\",\n          \"s3:*\",\n          \"rds:*\",\n          \"iam:*\"\n        ]\n        Resource = \"*\"\n      }\n    ]\n  })\n}"
        },
        {
          "name": "Network Security",
          "text": "Implement network security best practices with Terraform for secure infrastructure deployment.",
          "code": "# Security group with least privilege access\nresource \"aws_security_group\" \"web\" {\n  name_prefix = \"${var.environment}-web-sg-\"\n  vpc_id      = aws_vpc.main.id\n\n  # Allow HTTP traffic\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n    description = \"HTTP access\"\n  }\n\n  # Allow HTTPS traffic\n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n    description = \"HTTPS access\"\n  }\n\n  # Allow SSH from specific IP ranges\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = var.allowed_ssh_cidrs\n    description = \"SSH access from allowed IPs\"\n  }\n\n  # Allow all outbound traffic\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n    description = \"All outbound traffic\"\n  }\n\n  tags = {\n    Name        = \"${var.environment}-web-sg\"\n    Environment = var.environment\n  }\n}\n\n# Database security group\nresource \"aws_security_group\" \"database\" {\n  name_prefix = \"${var.environment}-db-sg-\"\n  vpc_id      = aws_vpc.main.id\n\n  # Allow database access from web tier\n  ingress {\n    from_port       = 5432\n    to_port         = 5432\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.web.id]\n    description     = \"PostgreSQL access from web tier\"\n  }\n\n  # Allow database access from application tier\n  ingress {\n    from_port       = 5432\n    to_port         = 5432\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.app.id]\n    description     = \"PostgreSQL access from app tier\"\n  }\n\n  tags = {\n    Name        = \"${var.environment}-db-sg\"\n    Environment = var.environment\n  }\n}\n\n# Network ACL for additional security\nresource \"aws_network_acl\" \"main\" {\n  vpc_id = aws_vpc.main.id\n\n  # Allow HTTP traffic\n  ingress {\n    protocol   = \"tcp\"\n    rule_no    = 100\n    action     = \"allow\"\n    cidr_block = \"0.0.0.0/0\"\n    from_port  = 80\n    to_port    = 80\n  }\n\n  # Allow HTTPS traffic\n  ingress {\n    protocol   = \"tcp\"\n    rule_no    = 110\n    action     = \"allow\"\n    cidr_block = \"0.0.0.0/0\"\n    from_port  = 443\n    to_port    = 443\n  }\n\n  # Allow ephemeral ports for responses\n  ingress {\n    protocol   = \"tcp\"\n    rule_no    = 120\n    action     = \"allow\"\n    cidr_block = \"0.0.0.0/0\"\n    from_port  = 1024\n    to_port    = 65535\n  }\n\n  # Allow all outbound traffic\n  egress {\n    protocol   = \"-1\"\n    rule_no    = 100\n    action     = \"allow\"\n    cidr_block = \"0.0.0.0/0\"\n    from_port  = 0\n    to_port    = 0\n  }\n\n  tags = {\n    Name        = \"${var.environment}-nacl\"\n    Environment = var.environment\n  }\n}\n\n# Associate NACL with subnets\nresource \"aws_network_acl_association\" \"public\" {\n  count          = length(aws_subnet.public)\n  network_acl_id = aws_network_acl.main.id\n  subnet_id      = aws_subnet.public[count.index].id\n}"
        },
        {
          "name": "Compliance and Auditing",
          "text": "Implement compliance and auditing features to ensure infrastructure meets security standards.",
          "code": "# Enable CloudTrail for API auditing\nresource \"aws_cloudtrail\" \"main\" {\n  name                          = \"${var.environment}-cloudtrail\"\n  s3_bucket_name               = aws_s3_bucket.cloudtrail.bucket\n  include_global_service_events = true\n  is_multi_region_trail        = true\n  enable_logging               = true\n\n  event_selector {\n    read_write_type                 = \"All\"\n    include_management_events       = true\n    data_resource {\n      type   = \"AWS::S3::Object\"\n      values = [\"arn:aws:s3:::\"]\n    }\n  }\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\n# S3 bucket for CloudTrail logs\nresource \"aws_s3_bucket\" \"cloudtrail\" {\n  bucket = \"${var.environment}-cloudtrail-logs-${random_string.bucket_suffix.result}\"\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\nresource \"aws_s3_bucket_versioning\" \"cloudtrail\" {\n  bucket = aws_s3_bucket.cloudtrail.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"cloudtrail\" {\n  bucket = aws_s3_bucket.cloudtrail.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"AES256\"\n    }\n  }\n}\n\n# Enable AWS Config for compliance monitoring\nresource \"aws_config_configuration_recorder\" \"main\" {\n  name     = \"${var.environment}-config-recorder\"\n  role_arn = aws_iam_role.config.arn\n\n  recording_group {\n    all_supported                 = true\n    include_global_resource_types = true\n  }\n}\n\nresource \"aws_config_delivery_channel\" \"main\" {\n  name           = \"${var.environment}-config-delivery\"\n  s3_bucket_name = aws_s3_bucket.config.bucket\n}\n\n# S3 bucket for Config\nresource \"aws_s3_bucket\" \"config\" {\n  bucket = \"${var.environment}-config-logs-${random_string.bucket_suffix.result}\"\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\n# IAM role for Config\nresource \"aws_iam_role\" \"config\" {\n  name = \"${var.environment}-config-role\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"config.amazonaws.com\"\n        }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"config\" {\n  role       = aws_iam_role.config.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/ConfigRole\"\n}\n\n# Enable GuardDuty for threat detection\nresource \"aws_guardduty_detector\" \"main\" {\n  enable = true\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\n# Random string for unique bucket names\nresource \"random_string\" \"bucket_suffix\" {\n  length  = 8\n  special = false\n  upper   = false\n}\n\n# Security Hub for centralized security findings\nresource \"aws_securityhub_account\" \"main\" {\n  enable_default_standards = true\n}\n\n# Enable security standards\nresource \"aws_securityhub_standards_subscription\" \"cis\" {\n  standards_arn = \"arn:aws:securityhub:${data.aws_region.current.name}::standards/cis-aws-foundations-benchmark/v/1.2.0\"\n  depends_on    = [aws_securityhub_account.main]\n}\n\nresource \"aws_securityhub_standards_subscription\" \"pci\" {\n  standards_arn = \"arn:aws:securityhub:${data.aws_region.current.name}::standards/pci-dss/v/3.2.1\"\n  depends_on    = [aws_securityhub_account.main]\n}\n\ndata \"aws_region\" \"current\" {}"
        }
      ]
    },
    {
      "id": "terraform-production",
      "title": "üöÄ Production ‚Äî Enterprise Deployment",
      "sections": [
        {
          "name": "CI/CD Integration",
          "text": "Integrate Terraform into CI/CD pipelines for automated infrastructure deployment and management.",
          "code": "# GitHub Actions Terraform workflow\nname: 'Terraform CI/CD'\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\nenv:\n  TF_VERSION: '1.6.0'\n  TF_WORKSPACE: 'prod'\n\njobs:\n  terraform-plan:\n    name: 'Terraform Plan'\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n    \n    - name: Setup Terraform\n      uses: hashicorp/setup-terraform@v2\n      with:\n        terraform_version: ${{ env.TF_VERSION }}\n    \n    - name: Configure AWS Credentials\n      uses: aws-actions/configure-aws-credentials@v2\n      with:\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: us-west-2\n    \n    - name: Terraform Init\n      run: terraform init\n      env:\n        TF_WORKSPACE: ${{ env.TF_WORKSPACE }}\n    \n    - name: Terraform Validate\n      run: terraform validate\n    \n    - name: Terraform Plan\n      run: terraform plan -var-file=\"terraform.tfvars.${{ env.TF_WORKSPACE }}\"\n      env:\n        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}\n    \n    - name: Comment PR\n      if: github.event_name == 'pull_request'\n      uses: actions/github-script@v6\n      with:\n        script: |\n          const output = `\n          ## Terraform Plan Results\n          \n          **Workspace:** ${{ env.TF_WORKSPACE }}\n          **Terraform Version:** ${{ env.TF_VERSION }}\n          \n          <details>\n          <summary>Show Plan Output</summary>\n          \n          \\`\\`\\`\n          ${{ steps.terraform-plan.outputs.stdout }}\n          \\`\\`\\`\n          \n          </details>\n          `\n          \n          github.rest.issues.createComment({\n            issue_number: context.issue.number,\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            body: output\n          })\n\n  terraform-apply:\n    name: 'Terraform Apply'\n    runs-on: ubuntu-latest\n    needs: terraform-plan\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n    \n    - name: Setup Terraform\n      uses: hashicorp/setup-terraform@v2\n      with:\n        terraform_version: ${{ env.TF_VERSION }}\n    \n    - name: Configure AWS Credentials\n      uses: aws-actions/configure-aws-credentials@v2\n      with:\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: us-west-2\n    \n    - name: Terraform Init\n      run: terraform init\n      env:\n        TF_WORKSPACE: ${{ env.TF_WORKSPACE }}\n    \n    - name: Terraform Apply\n      run: terraform apply -auto-approve -var-file=\"terraform.tfvars.${{ env.TF_WORKSPACE }}\"\n      env:\n        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}\n    \n    - name: Notify Slack\n      if: always()\n      uses: 8398a7/action-slack@v3\n      with:\n        status: ${{ job.status }}\n        channel: '#deployments'\n        webhook_url: ${{ secrets.SLACK_WEBHOOK }}"
        },
        {
          "name": "Infrastructure Testing",
          "text": "Implement testing strategies for Terraform configurations to ensure infrastructure reliability.",
          "code": "# terraform-compliance testing\n# Install terraform-compliance\npip install terraform-compliance\n\n# Create compliance test file\n# tests/security.feature\nFeature: Security\n  Scenario: Ensure all resources have proper tags\n    Given I have resource that supports tags defined\n    When it has tags\n    Then it must contain Environment\n    And it must contain ManagedBy\n    And its value must match the \".*\" regex\n\n  Scenario: Ensure security groups are properly configured\n    Given I have aws_security_group defined\n    When it contains ingress\n    Then it must not have 0.0.0.0/0\n    And it must not have port 22\n\n# Run compliance tests\nterraform-compliance -f tests/ -p terraform.tfplan\n\n# Terratest for Go-based testing\n# test/terraform_test.go\npackage test\n\nimport (\n    \"testing\"\n    \"github.com/gruntwork-io/terratest/modules/terraform\"\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTerraformBasicExample(t *testing.T) {\n    terraformOptions := &terraform.Options{\n        TerraformDir: \"../examples/basic\",\n        VarFiles:     []string{\"terraform.tfvars\"},\n    }\n\n    defer terraform.Destroy(t, terraformOptions)\n    terraform.InitAndApply(t, terraformOptions)\n\n    vpcId := terraform.Output(t, terraformOptions, \"vpc_id\")\n    assert.NotEmpty(t, vpcId)\n\n    subnetId := terraform.Output(t, terraformOptions, \"subnet_id\")\n    assert.NotEmpty(t, subnetId)\n}\n\n# Kitchen-Terraform for integration testing\n# kitchen.yml\n---\ndriver:\n  name: terraform\n  root_module_directory: test/fixtures/basic\n\nprovisioner:\n  name: terraform\n\nplatforms:\n  - name: basic\n\nverifier:\n  name: terraform\n  systems:\n    - name: basic\n      backend: aws\n      controls:\n        - aws_vpc\n        - aws_subnet\n\nsuites:\n  - name: basic\n\n# Run Kitchen tests\nkitchen test\n\n# Custom validation script\n#!/bin/bash\n# validate.sh\n\nset -e\n\necho \"Running Terraform validation...\"\n\n# Check Terraform version\nterraform version\n\n# Validate configuration\nterraform validate\n\n# Check formatting\nterraform fmt -check -recursive\n\n# Run security scan\nif command -v tfsec &> /dev/null; then\n  echo \"Running tfsec security scan...\"\n  tfsec .\nfi\n\n# Run compliance tests\nif command -v terraform-compliance &> /dev/null; then\n  echo \"Running compliance tests...\"\n  terraform plan -out=tfplan\n  terraform-compliance -f tests/ -p tfplan\nfi\n\necho \"Validation completed successfully\""
        },
        {
          "name": "Monitoring and Alerting",
          "text": "Set up monitoring and alerting for Terraform-managed infrastructure to ensure reliability and performance.",
          "code": "# CloudWatch alarms for infrastructure monitoring\nresource \"aws_cloudwatch_metric_alarm\" \"high_cpu\" {\n  alarm_name          = \"${var.environment}-high-cpu\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = \"2\"\n  metric_name         = \"CPUUtilization\"\n  namespace           = \"AWS/EC2\"\n  period              = \"120\"\n  statistic           = \"Average\"\n  threshold           = \"80\"\n  alarm_description   = \"This metric monitors ec2 cpu utilization\"\n\n  dimensions = {\n    InstanceId = aws_instance.web.id\n  }\n\n  alarm_actions = [aws_sns_topic.alerts.arn]\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"low_disk_space\" {\n  alarm_name          = \"${var.environment}-low-disk-space\"\n  comparison_operator = \"LessThanThreshold\"\n  evaluation_periods  = \"2\"\n  metric_name         = \"DiskSpaceUtilization\"\n  namespace           = \"System/Linux\"\n  period              = \"300\"\n  statistic           = \"Average\"\n  threshold           = \"20\"\n  alarm_description   = \"This metric monitors disk space utilization\"\n\n  dimensions = {\n    InstanceId = aws_instance.web.id\n    Filesystem = \"/dev/xvda1\"\n  }\n\n  alarm_actions = [aws_sns_topic.alerts.arn]\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\n# SNS topic for alerts\nresource \"aws_sns_topic\" \"alerts\" {\n  name = \"${var.environment}-alerts\"\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\nresource \"aws_sns_topic_subscription\" \"email\" {\n  topic_arn = aws_sns_topic.alerts.arn\n  protocol  = \"email\"\n  endpoint  = var.alert_email\n}\n\nresource \"aws_sns_topic_subscription\" \"slack\" {\n  topic_arn = aws_sns_topic.alerts.arn\n  protocol  = \"https\"\n  endpoint  = var.slack_webhook_url\n}\n\n# CloudWatch dashboard\nresource \"aws_cloudwatch_dashboard\" \"main\" {\n  dashboard_name = \"${var.environment}-dashboard\"\n\n  dashboard_body = jsonencode({\n    widgets = [\n      {\n        type   = \"metric\"\n        x      = 0\n        y      = 0\n        width  = 12\n        height = 6\n\n        properties = {\n          metrics = [\n            [\"AWS/EC2\", \"CPUUtilization\", \"InstanceId\", aws_instance.web.id],\n            [\".\", \"NetworkIn\", \".\", \".\"],\n            [\".\", \"NetworkOut\", \".\", \".\"]\n          ]\n          view    = \"timeSeries\"\n          stacked = false\n          region  = var.aws_region\n          title   = \"EC2 Metrics\"\n          period  = 300\n        }\n      },\n      {\n        type   = \"log\"\n        x      = 0\n        y      = 6\n        width  = 12\n        height = 6\n\n        properties = {\n          query   = \"SOURCE '/aws/ec2/${var.environment}-web' | fields @timestamp, @message | sort @timestamp desc | limit 100\"\n          region  = var.aws_region\n          title   = \"Application Logs\"\n        }\n      }\n    ]\n  })\n}\n\n# CloudWatch log group\nresource \"aws_cloudwatch_log_group\" \"web\" {\n  name              = \"/aws/ec2/${var.environment}-web\"\n  retention_in_days = 14\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\n# Log stream for application logs\nresource \"aws_cloudwatch_log_stream\" \"web\" {\n  name           = \"web-logs\"\n  log_group_name = aws_cloudwatch_log_group.web.name\n}"
        },
        {
          "name": "Disaster Recovery",
          "text": "Implement disaster recovery strategies for Terraform-managed infrastructure to ensure business continuity.",
          "code": "# Multi-region deployment for disaster recovery\n# Primary region (us-west-2)\nmodule \"primary\" {\n  source = \"./modules/infrastructure\"\n\n  providers = {\n    aws = aws.primary\n  }\n\n  environment = var.environment\n  region      = \"us-west-2\"\n\n  # Primary region configuration\n  instance_count = var.instance_count\n  enable_backup  = true\n}\n\n# Secondary region (us-east-1)\nmodule \"secondary\" {\n  source = \"./modules/infrastructure\"\n\n  providers = {\n    aws = aws.secondary\n  }\n\n  environment = var.environment\n  region      = \"us-east-1\"\n\n  # Secondary region configuration\n  instance_count = var.environment == \"prod\" ? var.instance_count : 1\n  enable_backup  = var.environment == \"prod\"\n}\n\n# Provider configuration for multi-region\nprovider \"aws\" {\n  alias  = \"primary\"\n  region = \"us-west-2\"\n}\n\nprovider \"aws\" {\n  alias  = \"secondary\"\n  region = \"us-east-1\"\n}\n\n# Cross-region replication for RDS\nresource \"aws_db_instance\" \"primary\" {\n  provider = aws.primary\n\n  identifier = \"${var.environment}-primary-db\"\n  engine     = \"postgres\"\n  engine_version = \"15.4\"\n  instance_class = \"db.t3.micro\"\n\n  # Enable automated backups\n  backup_retention_period = 7\n  backup_window          = \"03:00-04:00\"\n  maintenance_window     = \"Mon:04:00-Mon:05:00\"\n\n  # Enable cross-region read replica\n  replicate_source_db = aws_db_instance.secondary.identifier\n\n  tags = {\n    Environment = var.environment\n    Region      = \"primary\"\n  }\n}\n\nresource \"aws_db_instance\" \"secondary\" {\n  provider = aws.secondary\n\n  identifier = \"${var.environment}-secondary-db\"\n  engine     = \"postgres\"\n  engine_version = \"15.4\"\n  instance_class = \"db.t3.micro\"\n\n  # Enable automated backups\n  backup_retention_period = 7\n  backup_window          = \"03:00-04:00\"\n  maintenance_window     = \"Mon:04:00-Mon:05:00\"\n\n  tags = {\n    Environment = var.environment\n    Region      = \"secondary\"\n  }\n}\n\n# S3 cross-region replication\nresource \"aws_s3_bucket\" \"primary\" {\n  provider = aws.primary\n  bucket   = \"${var.environment}-primary-bucket\"\n\n  versioning {\n    enabled = true\n  }\n\n  replication_configuration {\n    role = aws_iam_role.replication.arn\n\n    rules {\n      id     = \"replicate-to-secondary\"\n      status = \"Enabled\"\n\n      destination {\n        bucket        = aws_s3_bucket.secondary.arn\n        storage_class = \"STANDARD_IA\"\n      }\n    }\n  }\n\n  tags = {\n    Environment = var.environment\n    Region      = \"primary\"\n  }\n}\n\nresource \"aws_s3_bucket\" \"secondary\" {\n  provider = aws.secondary\n  bucket   = \"${var.environment}-secondary-bucket\"\n\n  versioning {\n    enabled = true\n  }\n\n  tags = {\n    Environment = var.environment\n    Region      = \"secondary\"\n  }\n}\n\n# IAM role for S3 replication\nresource \"aws_iam_role\" \"replication\" {\n  name = \"${var.environment}-s3-replication-role\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"s3.amazonaws.com\"\n        }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"replication\" {\n  name = \"${var.environment}-s3-replication-policy\"\n  role = aws_iam_role.replication.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"s3:GetObjectVersionForReplication\",\n          \"s3:GetObjectVersionAcl\",\n          \"s3:GetObjectVersionTagging\"\n        ]\n        Resource = \"${aws_s3_bucket.primary.arn}/*\"\n      },\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"s3:ReplicateObject\",\n          \"s3:ReplicateDelete\",\n          \"s3:ReplicateTags\"\n        ]\n        Resource = \"${aws_s3_bucket.secondary.arn}/*\"\n      }\n    ]\n  })\n}\n\n# Backup and restore automation\nresource \"aws_lambda_function\" \"backup\" {\n  filename         = \"backup.zip\"\n  function_name    = \"${var.environment}-backup\"\n  role            = aws_iam_role.lambda_backup.arn\n  handler         = \"index.handler\"\n  runtime         = \"python3.9\"\n  timeout         = 300\n\n  environment {\n    variables = {\n      PRIMARY_REGION   = \"us-west-2\"\n      SECONDARY_REGION = \"us-east-1\"\n    }\n  }\n\n  tags = {\n    Environment = var.environment\n  }\n}\n\n# CloudWatch Events for scheduled backups\nresource \"aws_cloudwatch_event_rule\" \"backup_schedule\" {\n  name                = \"${var.environment}-backup-schedule\"\n  description         = \"Trigger backup Lambda function\"\n  schedule_expression = \"cron(0 2 * * ? *)\"  # Daily at 2 AM\n}\n\nresource \"aws_cloudwatch_event_target\" \"backup_target\" {\n  rule      = aws_cloudwatch_event_rule.backup_schedule.name\n  target_id = \"BackupTarget\"\n  arn       = aws_lambda_function.backup.arn\n}\n\nresource \"aws_lambda_permission\" \"allow_cloudwatch\" {\n  statement_id  = \"AllowExecutionFromCloudWatch\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.backup.function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.backup_schedule.arn\n}"
        }
      ]
    }
  ]
}
