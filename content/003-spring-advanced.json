{
  "config": {
    "id": "spring-advanced",
    "name": "Spring Advanced",
    "description": "Advanced Spring Framework concepts, patterns, and best practices.",
    "icon": "ðŸŒ±",
    "enabled": true
  },
  "content": [
    {
      "id": "spring-core-advanced",
      "title": "ðŸ”§ Core Advanced Concepts",
      "sections": [
        {
          "name": "Bean Lifecycle Management",
          "text": "# Spring Bean Lifecycle Management\n\n**Understanding the complete bean lifecycle in Spring Framework.**\n\n## **Bean Lifecycle Phases:**\n\n### **1. Instantiation**\n- **Bean Factory**: Creates bean instance using constructor or factory method\n- **Dependency Injection**: Injects dependencies into the bean\n- **Aware Interfaces**: Calls setter methods for aware interfaces\n\n### **2. Initialization**\n- **@PostConstruct**: Method called after dependency injection\n- **InitializingBean**: afterPropertiesSet() method\n- **Custom Init Method**: init-method or @Bean(initMethod)\n\n### **3. Destruction**\n- **@PreDestroy**: Method called before bean destruction\n- **DisposableBean**: destroy() method\n- **Custom Destroy Method**: destroy-method or @Bean(destroyMethod)\n\n## **Lifecycle Callback Order:**\n1. Constructor\n2. Dependency Injection\n3. Aware Interface Methods\n4. @PostConstruct\n5. InitializingBean.afterPropertiesSet()\n6. Custom init method\n7. Bean ready for use\n8. @PreDestroy\n9. DisposableBean.destroy()\n10. Custom destroy method",
          "code": "// Example: Complete Bean Lifecycle\n@Component\npublic class UserService implements InitializingBean, DisposableBean {\n    \n    private final UserRepository userRepository;\n    \n    public UserService(UserRepository userRepository) {\n        System.out.println(\"1. Constructor called\");\n        this.userRepository = userRepository;\n    }\n    \n    @PostConstruct\n    public void postConstruct() {\n        System.out.println(\"4. @PostConstruct called\");\n        // Initialize resources\n    }\n    \n    @Override\n    public void afterPropertiesSet() {\n        System.out.println(\"5. InitializingBean.afterPropertiesSet() called\");\n        // Additional initialization\n    }\n    \n    public void customInit() {\n        System.out.println(\"6. Custom init method called\");\n        // Custom initialization logic\n    }\n    \n    @PreDestroy\n    public void preDestroy() {\n        System.out.println(\"8. @PreDestroy called\");\n        // Cleanup resources\n    }\n    \n    @Override\n    public void destroy() {\n        System.out.println(\"9. DisposableBean.destroy() called\");\n        // Additional cleanup\n    }\n    \n    public void customDestroy() {\n        System.out.println(\"10. Custom destroy method called\");\n        // Custom cleanup logic\n    }\n}\n\n// Configuration with custom lifecycle methods\n@Configuration\npublic class AppConfig {\n    \n    @Bean(initMethod = \"customInit\", destroyMethod = \"customDestroy\")\n    public UserService userService(UserRepository userRepository) {\n        return new UserService(userRepository);\n    }\n}\n\n// Example: Aware Interfaces\n@Component\npublic class DatabaseService implements BeanNameAware, ApplicationContextAware {\n    \n    private String beanName;\n    private ApplicationContext applicationContext;\n    \n    @Override\n    public void setBeanName(String name) {\n        System.out.println(\"3. BeanNameAware.setBeanName() called: \" + name);\n        this.beanName = name;\n    }\n    \n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        System.out.println(\"3. ApplicationContextAware.setApplicationContext() called\");\n        this.applicationContext = applicationContext;\n    }\n}"
        },
        {
          "name": "Advanced Dependency Injection",
          "text": "# Advanced Dependency Injection Patterns\n\n**Advanced patterns and techniques for dependency injection in Spring.**\n\n## **Injection Types:**\n\n### **1. Constructor Injection**\n- **Recommended**: Immutable dependencies, mandatory dependencies\n- **Benefits**: Thread-safe, testable, immutable\n- **Use Case**: Required dependencies\n\n### **2. Setter Injection**\n- **Use Case**: Optional dependencies, circular dependencies\n- **Benefits**: Flexible, allows optional dependencies\n- **Drawbacks**: Mutable state, not thread-safe by default\n\n### **3. Field Injection**\n- **Use Case**: Simple cases, legacy code\n- **Benefits**: Concise, easy to use\n- **Drawbacks**: Hard to test, not recommended\n\n## **Advanced Injection Patterns:**\n\n### **1. @Qualifier for Multiple Beans**\n- **Problem**: Multiple beans of same type\n- **Solution**: Use @Qualifier to specify which bean\n- **Example**: Different database configurations\n\n### **2. @Primary for Default Bean**\n- **Problem**: Multiple beans, need default\n- **Solution**: Mark one as @Primary\n- **Use Case**: Default implementation\n\n### **3. @Conditional for Conditional Beans**\n- **Problem**: Create beans based on conditions\n- **Solution**: Use @Conditional annotations\n- **Use Case**: Environment-specific beans\n\n### **4. @Lazy for Lazy Initialization**\n- **Problem**: Expensive bean creation\n- **Solution**: Use @Lazy annotation\n- **Use Case**: Heavy resources, optional features",
          "code": "// Example: Constructor Injection (Recommended)\n@Service\npublic class OrderService {\n    \n    private final OrderRepository orderRepository;\n    private final PaymentService paymentService;\n    private final NotificationService notificationService;\n    \n    // Constructor injection - immutable, thread-safe\n    public OrderService(OrderRepository orderRepository,\n                       PaymentService paymentService,\n                       NotificationService notificationService) {\n        this.orderRepository = orderRepository;\n        this.paymentService = paymentService;\n        this.notificationService = notificationService;\n    }\n}\n\n// Example: @Qualifier for Multiple Beans\n@Configuration\npublic class DatabaseConfig {\n    \n    @Bean\n    @Qualifier(\"primary\")\n    public DataSource primaryDataSource() {\n        return new HikariDataSource();\n    }\n    \n    @Bean\n    @Qualifier(\"secondary\")\n    public DataSource secondaryDataSource() {\n        return new HikariDataSource();\n    }\n}\n\n@Service\npublic class UserService {\n    \n    private final DataSource primaryDataSource;\n    private final DataSource secondaryDataSource;\n    \n    public UserService(@Qualifier(\"primary\") DataSource primaryDataSource,\n                      @Qualifier(\"secondary\") DataSource secondaryDataSource) {\n        this.primaryDataSource = primaryDataSource;\n        this.secondaryDataSource = secondaryDataSource;\n    }\n}\n\n// Example: @Primary for Default Bean\n@Configuration\npublic class CacheConfig {\n    \n    @Bean\n    @Primary\n    public CacheManager defaultCacheManager() {\n        return new ConcurrentMapCacheManager();\n    }\n    \n    @Bean\n    @ConditionalOnProperty(name = \"cache.redis.enabled\", havingValue = \"true\")\n    public CacheManager redisCacheManager() {\n        return new RedisCacheManager();\n    }\n}\n\n// Example: @Conditional Beans\n@Configuration\npublic class ConditionalConfig {\n    \n    @Bean\n    @ConditionalOnProperty(name = \"feature.email.enabled\", havingValue = \"true\")\n    public EmailService emailService() {\n        return new EmailService();\n    }\n    \n    @Bean\n    @ConditionalOnClass(name = \"com.example.ExternalService\")\n    public ExternalService externalService() {\n        return new ExternalService();\n    }\n    \n    @Bean\n    @ConditionalOnMissingBean(NotificationService.class)\n    public NotificationService defaultNotificationService() {\n        return new DefaultNotificationService();\n    }\n}\n\n// Example: @Lazy Initialization\n@Configuration\npublic class LazyConfig {\n    \n    @Bean\n    @Lazy\n    public HeavyResource heavyResource() {\n        System.out.println(\"Creating heavy resource...\");\n        return new HeavyResource();\n    }\n    \n    @Bean\n    public LightService lightService() {\n        return new LightService();\n    }\n}\n\n// Example: Circular Dependency Resolution\n@Service\npublic class UserService {\n    \n    private final OrderService orderService;\n    \n    public UserService(@Lazy OrderService orderService) {\n        this.orderService = orderService;\n    }\n}\n\n@Service\npublic class OrderService {\n    \n    private final UserService userService;\n    \n    public OrderService(@Lazy UserService userService) {\n        this.userService = userService;\n    }\n}"
        },
        {
          "name": "Spring AOP Advanced",
          "text": "# Spring AOP Advanced Concepts\n\n**Advanced Aspect-Oriented Programming with Spring Framework.**\n\n## **AOP Concepts:**\n\n### **1. Join Points**\n- **Definition**: Points in program execution where aspects can be applied\n- **Examples**: Method execution, constructor execution, field access\n- **Spring AOP**: Only method execution join points\n\n### **2. Pointcuts**\n- **Definition**: Expressions that define where aspects should be applied\n- **Types**: Execution, within, args, target, @annotation\n- **Examples**: Method signatures, package patterns, annotations\n\n### **3. Advice**\n- **Definition**: Action taken at a join point\n- **Types**: @Before, @After, @AfterReturning, @AfterThrowing, @Around\n- **Order**: @Around > @Before > @After > @AfterReturning/@AfterThrowing\n\n### **4. Aspects**\n- **Definition**: Modularization of cross-cutting concerns\n- **Implementation**: @Aspect classes with advice methods\n- **Benefits**: Separation of concerns, reusable code\n\n## **Advanced AOP Patterns:**\n\n### **1. Transaction Management**\n- **@Transactional**: Declarative transaction management\n- **Propagation**: REQUIRED, REQUIRES_NEW, SUPPORTS, etc.\n- **Isolation**: READ_COMMITTED, REPEATABLE_READ, etc.\n\n### **2. Security Aspects**\n- **Method Security**: @PreAuthorize, @PostAuthorize\n- **Custom Security**: Custom aspects for authorization\n- **Audit Logging**: Track method calls and parameters\n\n### **3. Performance Monitoring**\n- **Execution Time**: Measure method execution time\n- **Caching**: Cache method results\n- **Rate Limiting**: Limit method calls per time period\n\n### **4. Error Handling**\n- **Exception Translation**: Convert checked exceptions\n- **Retry Logic**: Retry failed method calls\n- **Circuit Breaker**: Prevent cascading failures",
          "code": "// Example: Basic AOP Setup\n@Aspect\n@Component\npublic class LoggingAspect {\n    \n    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);\n    \n    // Pointcut for all public methods in service package\n    @Pointcut(\"execution(public * com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n    \n    // Pointcut for methods annotated with @Audit\n    @Pointcut(\"@annotation(com.example.annotation.Audit)\")\n    public void auditMethods() {}\n    \n    // Before advice\n    @Before(\"serviceMethods()\")\n    public void logBefore(JoinPoint joinPoint) {\n        logger.info(\"Before: {} with args: {}\", \n            joinPoint.getSignature().getName(), \n            Arrays.toString(joinPoint.getArgs()));\n    }\n    \n    // After returning advice\n    @AfterReturning(pointcut = \"serviceMethods()\", returning = \"result\")\n    public void logAfterReturning(JoinPoint joinPoint, Object result) {\n        logger.info(\"After: {} returned: {}\", \n            joinPoint.getSignature().getName(), result);\n    }\n    \n    // After throwing advice\n    @AfterThrowing(pointcut = \"serviceMethods()\", throwing = \"exception\")\n    public void logAfterThrowing(JoinPoint joinPoint, Exception exception) {\n        logger.error(\"Exception in: {} - {}\", \n            joinPoint.getSignature().getName(), exception.getMessage());\n    }\n    \n    // Around advice for performance monitoring\n    @Around(\"serviceMethods()\")\n    public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        \n        try {\n            Object result = joinPoint.proceed();\n            long endTime = System.currentTimeMillis();\n            \n            logger.info(\"Method: {} executed in {} ms\", \n                joinPoint.getSignature().getName(), (endTime - startTime));\n            \n            return result;\n        } catch (Exception e) {\n            long endTime = System.currentTimeMillis();\n            logger.error(\"Method: {} failed after {} ms\", \n                joinPoint.getSignature().getName(), (endTime - startTime));\n            throw e;\n        }\n    }\n}\n\n// Example: Transaction Management Aspect\n@Aspect\n@Component\npublic class TransactionAspect {\n    \n    @Autowired\n    private PlatformTransactionManager transactionManager;\n    \n    @Around(\"@annotation(com.example.annotation.Transactional)\")\n    public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {\n        TransactionDefinition definition = new DefaultTransactionDefinition();\n        TransactionStatus status = transactionManager.getTransaction(definition);\n        \n        try {\n            Object result = joinPoint.proceed();\n            transactionManager.commit(status);\n            return result;\n        } catch (Exception e) {\n            transactionManager.rollback(status);\n            throw e;\n        }\n    }\n}\n\n// Example: Security Aspect\n@Aspect\n@Component\npublic class SecurityAspect {\n    \n    @Autowired\n    private SecurityService securityService;\n    \n    @Before(\"@annotation(com.example.annotation.RequireRole)\")\n    public void checkRole(JoinPoint joinPoint) {\n        RequireRole annotation = ((MethodSignature) joinPoint.getSignature())\n            .getMethod().getAnnotation(RequireRole.class);\n        \n        String requiredRole = annotation.value();\n        \n        if (!securityService.hasRole(requiredRole)) {\n            throw new SecurityException(\"Access denied. Required role: \" + requiredRole);\n        }\n    }\n}\n\n// Example: Caching Aspect\n@Aspect\n@Component\npublic class CachingAspect {\n    \n    @Autowired\n    private CacheManager cacheManager;\n    \n    @Around(\"@annotation(com.example.annotation.Cacheable)\")\n    public Object cacheResult(ProceedingJoinPoint joinPoint) throws Throwable {\n        Cacheable annotation = ((MethodSignature) joinPoint.getSignature())\n            .getMethod().getAnnotation(Cacheable.class);\n        \n        String cacheName = annotation.value();\n        String key = generateKey(joinPoint);\n        \n        Cache cache = cacheManager.getCache(cacheName);\n        Cache.ValueWrapper wrapper = cache.get(key);\n        \n        if (wrapper != null) {\n            return wrapper.get();\n        }\n        \n        Object result = joinPoint.proceed();\n        cache.put(key, result);\n        \n        return result;\n    }\n    \n    private String generateKey(ProceedingJoinPoint joinPoint) {\n        return joinPoint.getSignature().getName() + \":\" + \n               Arrays.hashCode(joinPoint.getArgs());\n    }\n}\n\n// Example: Retry Aspect\n@Aspect\n@Component\npublic class RetryAspect {\n    \n    @Around(\"@annotation(com.example.annotation.Retryable)\")\n    public Object retryMethod(ProceedingJoinPoint joinPoint) throws Throwable {\n        Retryable annotation = ((MethodSignature) joinPoint.getSignature())\n            .getMethod().getAnnotation(Retryable.class);\n        \n        int maxAttempts = annotation.maxAttempts();\n        long delay = annotation.delay();\n        \n        Exception lastException = null;\n        \n        for (int attempt = 1; attempt <= maxAttempts; attempt++) {\n            try {\n                return joinPoint.proceed();\n            } catch (Exception e) {\n                lastException = e;\n                \n                if (attempt < maxAttempts) {\n                    Thread.sleep(delay);\n                }\n            }\n        }\n        \n        throw lastException;\n    }\n}"
        }
      ]
    },
    {
      "id": "spring-boot-advanced",
      "title": "ðŸš€ Boot Advanced Features",
      "sections": [
        {
          "name": "Auto-Configuration",
          "text": "# Spring Boot Auto-Configuration\n\n**Understanding and customizing Spring Boot's auto-configuration mechanism.**\n\n## **Auto-Configuration Concepts:**\n\n### **1. @EnableAutoConfiguration**\n- **Purpose**: Enables Spring Boot's auto-configuration\n- **Process**: Scans classpath for auto-configuration classes\n- **Order**: Conditional evaluation and ordering\n\n### **2. @ConditionalOn*** Annotations**\n- **@ConditionalOnClass**: Enable when class is present\n- **@ConditionalOnMissingClass**: Enable when class is absent\n- **@ConditionalOnBean**: Enable when bean exists\n- **@ConditionalOnMissingBean**: Enable when bean is missing\n- **@ConditionalOnProperty**: Enable based on property value\n\n### **3. Auto-Configuration Classes**\n- **Structure**: @Configuration classes with @ConditionalOn* annotations\n- **Ordering**: Use @AutoConfigureOrder, @Order, @AutoConfigureBefore, @AutoConfigureAfter\n- **Exclusion**: Use @EnableAutoConfiguration(exclude = ...)\n\n## **Custom Auto-Configuration:**\n\n### **1. Creating Auto-Configuration**\n- **@Configuration**: Mark as configuration class\n- **@ConditionalOn***: Add conditions\n- **@Bean**: Define beans conditionally\n- **spring.factories**: Register auto-configuration\n\n### **2. Testing Auto-Configuration**\n- **@AutoConfigureTestDatabase**: Test database configuration\n- **@MockBean**: Mock beans for testing\n- **@TestPropertySource**: Override properties\n- **ApplicationContextRunner**: Test context loading\n\n### **3. Debugging Auto-Configuration**\n- **debug=true**: Enable auto-configuration report\n- **@ConditionalOn***: Check condition evaluation\n- **@EnableAutoConfiguration**: Use exclude parameter",
          "code": "// Example: Custom Auto-Configuration\n@Configuration\n@ConditionalOnClass(RedisTemplate.class)\n@ConditionalOnMissingBean(RedisTemplate.class)\n@EnableConfigurationProperties(RedisProperties.class)\n@AutoConfigureAfter(RedisAutoConfiguration.class)\npublic class CustomRedisAutoConfiguration {\n    \n    @Autowired\n    private RedisProperties redisProperties;\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public RedisConnectionFactory redisConnectionFactory() {\n        LettuceConnectionFactory factory = new LettuceConnectionFactory(\n            new RedisStandaloneConfiguration(redisProperties.getHost(), redisProperties.getPort())\n        );\n        factory.setDatabase(redisProperties.getDatabase());\n        return factory;\n    }\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(connectionFactory);\n        template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());\n        return template;\n    }\n}\n\n// Example: Conditional Configuration\n@Configuration\n@ConditionalOnProperty(name = \"app.feature.cache.enabled\", havingValue = \"true\")\npublic class CacheAutoConfiguration {\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager();\n    }\n    \n    @Bean\n    @ConditionalOnClass(RedisTemplate.class)\n    @ConditionalOnProperty(name = \"app.cache.type\", havingValue = \"redis\")\n    public CacheManager redisCacheManager(RedisTemplate<String, Object> redisTemplate) {\n        RedisCacheManager.Builder builder = RedisCacheManager\n            .RedisCacheManagerBuilder\n            .fromConnectionFactory(redisTemplate.getConnectionFactory())\n            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig());\n        \n        return builder.build();\n    }\n}\n\n// Example: Auto-Configuration Properties\n@ConfigurationProperties(prefix = \"app.custom\")\npublic class CustomProperties {\n    \n    private String name;\n    private int timeout = 5000;\n    private List<String> features = new ArrayList<>();\n    \n    // Getters and setters\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    \n    public int getTimeout() { return timeout; }\n    public void setTimeout(int timeout) { this.timeout = timeout; }\n    \n    public List<String> getFeatures() { return features; }\n    public void setFeatures(List<String> features) { this.features = features; }\n}\n\n// Example: Testing Auto-Configuration\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n@TestPropertySource(properties = {\n    \"app.feature.cache.enabled=true\",\n    \"app.cache.type=redis\"\n})\npublic class AutoConfigurationTest {\n    \n    @Autowired\n    private ApplicationContext applicationContext;\n    \n    @Test\n    public void testCacheManagerBean() {\n        assertThat(applicationContext.getBean(CacheManager.class)).isNotNull();\n    }\n    \n    @Test\n    public void testRedisTemplateBean() {\n        assertThat(applicationContext.getBean(RedisTemplate.class)).isNotNull();\n    }\n}\n\n// Example: Debugging Auto-Configuration\n@SpringBootApplication\n@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})\npublic class Application {\n    \n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(Application.class);\n        app.setAdditionalProfiles(\"debug\");\n        app.run(args);\n    }\n}\n\n// application-debug.properties\ndebug=true\nlogging.level.org.springframework.boot.autoconfigure=DEBUG"
        },
        {
          "name": "Spring Boot Actuator",
          "text": "# Spring Boot Actuator\n\n**Production-ready features for monitoring and managing Spring Boot applications.**\n\n## **Actuator Endpoints:**\n\n### **1. Health Endpoints**\n- **/actuator/health**: Application health status\n- **Custom Health Indicators**: Implement HealthIndicator\n- **Health Groups**: Group related health checks\n- **Health Details**: Expose detailed health information\n\n### **2. Metrics Endpoints**\n- **/actuator/metrics**: Application metrics\n- **Custom Metrics**: Create custom metrics\n- **Micrometer Integration**: Use Micrometer for metrics\n- **Prometheus**: Export metrics to Prometheus\n\n### **3. Info Endpoints**\n- **/actuator/info**: Application information\n- **Build Information**: Maven/Gradle build info\n- **Git Information**: Git commit information\n- **Custom Info**: Add custom information\n\n### **4. Management Endpoints**\n- **/actuator/env**: Environment properties\n- **/actuator/configprops**: Configuration properties\n- **/actuator/beans**: Spring beans\n- **/actuator/mappings**: Request mappings\n\n## **Security and Configuration:**\n\n### **1. Endpoint Security**\n- **Sensitive Endpoints**: Protect sensitive endpoints\n- **Authentication**: Require authentication\n- **Authorization**: Role-based access\n- **HTTPS**: Use HTTPS for production\n\n### **2. Custom Endpoints**\n- **@Endpoint**: Create custom endpoints\n- **@ReadOperation**: Read operations\n- **@WriteOperation**: Write operations\n- **@DeleteOperation**: Delete operations\n\n### **3. Monitoring Integration**\n- **Prometheus**: Metrics export\n- **Grafana**: Dashboards\n- **ELK Stack**: Log aggregation\n- **APM Tools**: Application performance monitoring",
          "code": "// Example: Custom Health Indicator\n@Component\npublic class DatabaseHealthIndicator implements HealthIndicator {\n    \n    @Autowired\n    private DataSource dataSource;\n    \n    @Override\n    public Health health() {\n        try (Connection connection = dataSource.getConnection()) {\n            if (connection.isValid(1)) {\n                return Health.up()\n                    .withDetail(\"database\", \"Available\")\n                    .withDetail(\"validationQuery\", \"SELECT 1\")\n                    .build();\n            }\n        } catch (SQLException e) {\n            return Health.down()\n                .withDetail(\"database\", \"Unavailable\")\n                .withDetail(\"error\", e.getMessage())\n                .build();\n        }\n        \n        return Health.down()\n            .withDetail(\"database\", \"Connection failed\")\n            .build();\n    }\n}\n\n// Example: Custom Metrics\n@Component\npublic class CustomMetrics {\n    \n    private final MeterRegistry meterRegistry;\n    private final Counter requestCounter;\n    private final Timer requestTimer;\n    private final Gauge activeUsers;\n    \n    public CustomMetrics(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n        this.requestCounter = Counter.builder(\"app.requests.total\")\n            .description(\"Total number of requests\")\n            .register(meterRegistry);\n        \n        this.requestTimer = Timer.builder(\"app.requests.duration\")\n            .description(\"Request duration\")\n            .register(meterRegistry);\n        \n        this.activeUsers = Gauge.builder(\"app.users.active\")\n            .description(\"Number of active users\")\n            .register(meterRegistry, this, CustomMetrics::getActiveUsers);\n    }\n    \n    public void incrementRequestCounter() {\n        requestCounter.increment();\n    }\n    \n    public void recordRequestDuration(Duration duration) {\n        requestTimer.record(duration);\n    }\n    \n    private double getActiveUsers() {\n        // Return actual active users count\n        return 42.0;\n    }\n}\n\n// Example: Custom Endpoint\n@Component\n@Endpoint(id = \"custom\")\npublic class CustomEndpoint {\n    \n    @Autowired\n    private ApplicationContext applicationContext;\n    \n    @ReadOperation\n    public Map<String, Object> getInfo() {\n        Map<String, Object> info = new HashMap<>();\n        info.put(\"application\", applicationContext.getApplicationName());\n        info.put(\"beans\", applicationContext.getBeanDefinitionCount());\n        info.put(\"timestamp\", Instant.now());\n        return info;\n    }\n    \n    @WriteOperation\n    public String updateConfig(@Selector String key, String value) {\n        // Update configuration logic\n        return \"Configuration updated: \" + key + \" = \" + value;\n    }\n    \n    @DeleteOperation\n    public String clearCache() {\n        // Clear cache logic\n        return \"Cache cleared\";\n    }\n}\n\n// Example: Actuator Configuration\n@Configuration\n@EnableWebMvc\npublic class ActuatorConfig {\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public SecurityFilterChain actuatorSecurityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .requestMatcher(EndpointRequest.toAnyEndpoint())\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(EndpointRequest.to(\"health\", \"info\")).permitAll()\n                .requestMatchers(EndpointRequest.toAnyEndpoint()).hasRole(\"ACTUATOR\")\n            )\n            .httpBasic(withDefaults());\n        \n        return http.build();\n    }\n}\n\n// Example: Application Properties for Actuator\n# application.yml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics,prometheus\n      base-path: /actuator\n  endpoint:\n    health:\n      show-details: when-authorized\n      show-components: always\n    info:\n      env:\n        enabled: true\n      java:\n        enabled: true\n      git:\n        enabled: true\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n    distribution:\n      percentiles-histogram:\n        http.server.requests: true\n      percentiles:\n        http.server.requests: 0.5, 0.95, 0.99\n\n# Example: Health Groups\nmanagement:\n  endpoint:\n    health:\n      group:\n        database:\n          include: db,redis\n        external:\n          include: http,mail\n\n# Example: Custom Info\ninfo:\n  app:\n    name: @project.name@\n    version: @project.version@\n    description: @project.description@\n  build:\n    artifact: @project.artifactId@\n    group: @project.groupId@\n    time: @maven.build.timestamp@"
        },
        {
          "name": "Spring Boot Testing",
          "text": "# Spring Boot Testing Strategies\n\n**Comprehensive testing approaches for Spring Boot applications.**\n\n## **Testing Layers:**\n\n### **1. Unit Testing**\n- **@MockBean**: Mock Spring beans in tests\n- **@TestConfiguration**: Test-specific configurations\n- **@WebMvcTest**: Test web layer only\n- **@DataJpaTest**: Test JPA repositories\n\n### **2. Integration Testing**\n- **@SpringBootTest**: Full application context\n- **@AutoConfigureTestDatabase**: Test database configuration\n- **@TestPropertySource**: Override properties\n- **@MockBean**: Mock external dependencies\n\n### **3. Web Testing**\n- **MockMvc**: Test web endpoints\n- **TestRestTemplate**: Test HTTP clients\n- **@WebMvcTest**: Test controllers\n- **@AutoConfigureWebMvc**: Configure web layer\n\n### **4. Test Slices**\n- **@JsonTest**: Test JSON serialization\n- **@DataJpaTest**: Test JPA repositories\n- **@JdbcTest**: Test JDBC repositories\n- **@DataRedisTest**: Test Redis repositories\n\n## **Advanced Testing Patterns:**\n\n### **1. Test Containers**\n- **@Testcontainers**: Use real databases in tests\n- **@Container**: Define test containers\n- **Dynamic Properties**: Configure test properties\n- **Lifecycle Management**: Container lifecycle\n\n### **2. Test Profiles**\n- **@ActiveProfiles**: Activate test profiles\n- **Test-specific Properties**: Override configurations\n- **Environment Isolation**: Separate test environments\n- **Profile-specific Beans**: Test-specific bean configurations\n\n### **3. Performance Testing**\n- **@Timed**: Measure test execution time\n- **Load Testing**: Test under load\n- **Memory Testing**: Test memory usage\n- **Concurrent Testing**: Test thread safety",
          "code": "// Example: Unit Testing with @MockBean\n@SpringBootTest\nclass UserServiceTest {\n    \n    @Autowired\n    private UserService userService;\n    \n    @MockBean\n    private UserRepository userRepository;\n    \n    @MockBean\n    private EmailService emailService;\n    \n    @Test\n    void shouldCreateUser() {\n        // Given\n        User user = new User(\"john\", \"john@example.com\");\n        when(userRepository.save(any(User.class))).thenReturn(user);\n        \n        // When\n        User result = userService.createUser(user);\n        \n        // Then\n        assertThat(result).isNotNull();\n        assertThat(result.getUsername()).isEqualTo(\"john\");\n        verify(emailService).sendWelcomeEmail(user.getEmail());\n    }\n}\n\n// Example: Web Layer Testing\n@WebMvcTest(UserController.class)\nclass UserControllerTest {\n    \n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private UserService userService;\n    \n    @Test\n    void shouldReturnUser() throws Exception {\n        // Given\n        User user = new User(\"john\", \"john@example.com\");\n        when(userService.getUser(\"john\")).thenReturn(user);\n        \n        // When & Then\n        mockMvc.perform(get(\"/users/john\"))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.username\").value(\"john\"))\n            .andExpect(jsonPath(\"$.email\").value(\"john@example.com\"));\n    }\n}\n\n// Example: Test Containers\n@Testcontainers\n@SpringBootTest\nclass DatabaseIntegrationTest {\n    \n    @Container\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:13\")\n            .withDatabaseName(\"testdb\")\n            .withUsername(\"test\")\n            .withPassword(\"test\");\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @DynamicPropertySource\n    static void configureProperties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.datasource.url\", postgres::getJdbcUrl);\n        registry.add(\"spring.datasource.username\", postgres::getUsername);\n        registry.add(\"spring.datasource.password\", postgres::getPassword);\n    }\n    \n    @Test\n    void shouldSaveAndRetrieveUser() {\n        // Given\n        User user = new User(\"john\", \"john@example.com\");\n        \n        // When\n        User saved = userRepository.save(user);\n        User retrieved = userRepository.findById(saved.getId()).orElse(null);\n        \n        // Then\n        assertThat(retrieved).isNotNull();\n        assertThat(retrieved.getUsername()).isEqualTo(\"john\");\n    }\n}\n\n// Example: Test Configuration\n@TestConfiguration\npublic class TestConfig {\n    \n    @Bean\n    @Primary\n    public EmailService mockEmailService() {\n        return mock(EmailService.class);\n    }\n    \n    @Bean\n    public TestDataBuilder testDataBuilder() {\n        return new TestDataBuilder();\n    }\n}\n\n// Example: Performance Testing\n@SpringBootTest\nclass PerformanceTest {\n    \n    @Autowired\n    private UserService userService;\n    \n    @Test\n    @Timed(millis = 1000)\n    void shouldCreateUserWithinTimeLimit() {\n        User user = new User(\"john\", \"john@example.com\");\n        userService.createUser(user);\n    }\n    \n    @Test\n    void shouldHandleConcurrentUsers() throws InterruptedException {\n        int threadCount = 10;\n        CountDownLatch latch = new CountDownLatch(threadCount);\n        \n        for (int i = 0; i < threadCount; i++) {\n            final int userId = i;\n            new Thread(() -> {\n                try {\n                    User user = new User(\"user\" + userId, \"user\" + userId + \"@example.com\");\n                    userService.createUser(user);\n                } finally {\n                    latch.countDown();\n                }\n            }).start();\n        }\n        \n        assertThat(latch.await(5, TimeUnit.SECONDS)).isTrue();\n    }\n}"
        },
        {
          "name": "Spring Boot Profiles & Configuration",
          "text": "# Spring Boot Profiles & Configuration\n\n**Advanced configuration management and profile handling in Spring Boot.**\n\n## **Profile Management:**\n\n### **1. Profile Activation**\n- **@ActiveProfiles**: Activate specific profiles\n- **@Profile**: Profile-specific beans\n- **spring.profiles.active**: Active profiles property\n- **Environment Variables**: Profile activation via env vars\n\n### **2. Profile-specific Properties**\n- **application-{profile}.properties**: Profile-specific config\n- **application-{profile}.yml**: YAML configuration\n- **@ConfigurationProperties**: Type-safe configuration\n- **@Value**: Property injection\n\n### **3. Conditional Configuration**\n- **@ConditionalOnProfile**: Profile-based conditions\n- **@ConditionalOnProperty**: Property-based conditions\n- **@ConditionalOnClass**: Class-based conditions\n- **@ConditionalOnMissingBean**: Bean-based conditions\n\n## **Advanced Configuration Patterns:**\n\n### **1. External Configuration**\n- **Config Server**: Centralized configuration\n- **Environment Variables**: Runtime configuration\n- **Command Line Arguments**: Startup configuration\n- **JNDI Properties**: JNDI-based configuration\n\n### **2. Configuration Validation**\n- **@Validated**: Validate configuration properties\n- **@NotNull, @NotBlank**: Validation annotations\n- **@Min, @Max**: Numeric validation\n- **@Pattern**: Regex validation\n\n### **3. Dynamic Configuration**\n- **@RefreshScope**: Refreshable beans\n- **@ConfigurationProperties**: Dynamic properties\n- **Environment Change Events**: Configuration change handling\n- **Property Sources**: Multiple property sources",
          "code": "// Example: Profile-specific Configuration\n@Configuration\n@Profile(\"dev\")\npublic class DevConfig {\n    \n    @Bean\n    public DataSource devDataSource() {\n        HikariDataSource dataSource = new HikariDataSource();\n        dataSource.setJdbcUrl(\"jdbc:h2:mem:devdb\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");\n        return dataSource;\n    }\n    \n    @Bean\n    public LoggingService devLoggingService() {\n        return new ConsoleLoggingService();\n    }\n}\n\n@Configuration\n@Profile(\"prod\")\npublic class ProdConfig {\n    \n    @Bean\n    public DataSource prodDataSource() {\n        HikariDataSource dataSource = new HikariDataSource();\n        dataSource.setJdbcUrl(\"jdbc:postgresql://prod-db:5432/mydb\");\n        dataSource.setUsername(\"${DB_USERNAME}\");\n        dataSource.setPassword(\"${DB_PASSWORD}\");\n        return dataSource;\n    }\n    \n    @Bean\n    public LoggingService prodLoggingService() {\n        return new FileLoggingService();\n    }\n}\n\n// Example: Configuration Properties\n@ConfigurationProperties(prefix = \"app.database\")\n@Validated\npublic class DatabaseProperties {\n    \n    @NotBlank\n    private String url;\n    \n    @NotBlank\n    private String username;\n    \n    @NotBlank\n    private String password;\n    \n    @Min(1)\n    @Max(100)\n    private int maxConnections = 10;\n    \n    @Pattern(regexp = \"^(true|false)$\")\n    private String sslEnabled = \"false\";\n    \n    // Getters and setters\n    public String getUrl() { return url; }\n    public void setUrl(String url) { this.url = url; }\n    \n    public String getUsername() { return username; }\n    public void setUsername(String username) { this.username = username; }\n    \n    public String getPassword() { return password; }\n    public void setPassword(String password) { this.password = password; }\n    \n    public int getMaxConnections() { return maxConnections; }\n    public void setMaxConnections(int maxConnections) { this.maxConnections = maxConnections; }\n    \n    public String getSslEnabled() { return sslEnabled; }\n    public void setSslEnabled(String sslEnabled) { this.sslEnabled = sslEnabled; }\n}\n\n// Example: Conditional Configuration\n@Configuration\npublic class ConditionalConfig {\n    \n    @Bean\n    @ConditionalOnProperty(name = \"app.cache.enabled\", havingValue = \"true\")\n    @ConditionalOnClass(RedisTemplate.class)\n    public CacheManager redisCacheManager() {\n        return new RedisCacheManager();\n    }\n    \n    @Bean\n    @ConditionalOnMissingBean(CacheManager.class)\n    public CacheManager defaultCacheManager() {\n        return new ConcurrentMapCacheManager();\n    }\n    \n    @Bean\n    @ConditionalOnProfile(\"cloud\")\n    public CloudConfig cloudConfig() {\n        return new CloudConfig();\n    }\n}\n\n// Example: Dynamic Configuration\n@Component\n@RefreshScope\n@ConfigurationProperties(prefix = \"app.dynamic\")\npublic class DynamicConfig {\n    \n    private String message;\n    private int timeout;\n    \n    @EventListener\n    public void handleRefreshEvent(RefreshEvent event) {\n        System.out.println(\"Configuration refreshed: \" + event.getEventType());\n    }\n    \n    // Getters and setters\n    public String getMessage() { return message; }\n    public void setMessage(String message) { this.message = message; }\n    \n    public int getTimeout() { return timeout; }\n    public void setTimeout(int timeout) { this.timeout = timeout; }\n}\n\n// Example: Multiple Property Sources\n@Configuration\n@PropertySource(\"classpath:default.properties\")\n@PropertySource(value = \"classpath:${spring.profiles.active}.properties\", ignoreResourceNotFound = true)\npublic class PropertySourceConfig {\n    \n    @Value(\"${app.name:DefaultApp}\")\n    private String appName;\n    \n    @Value(\"${app.version:1.0.0}\")\n    private String appVersion;\n    \n    @Bean\n    public AppInfo appInfo() {\n        return new AppInfo(appName, appVersion);\n    }\n}\n\n// Example: Environment-specific Configuration\n@Configuration\n@Profile(\"!test\")\npublic class EnvironmentConfig {\n    \n    @Autowired\n    private Environment environment;\n    \n    @Bean\n    public DataSource dataSource() {\n        HikariDataSource dataSource = new HikariDataSource();\n        \n        // Use environment variables or properties\n        dataSource.setJdbcUrl(environment.getProperty(\"DB_URL\", \"jdbc:h2:mem:defaultdb\"));\n        dataSource.setUsername(environment.getProperty(\"DB_USERNAME\", \"sa\"));\n        dataSource.setPassword(environment.getProperty(\"DB_PASSWORD\", \"\"));\n        \n        return dataSource;\n    }\n}"
        }
      ]
    },
    {
      "id": "spring-data-advanced",
      "title": "ðŸ“Š Data Advanced",
      "sections": [
        {
          "name": "Spring Data JPA Advanced",
          "text": "# Spring Data JPA Advanced Features\n\n**Advanced JPA features and patterns with Spring Data.**\n\n## **Advanced Query Methods:**\n\n### **1. Custom Query Methods**\n- **@Query**: Custom JPQL/SQL queries\n- **@Modifying**: Modify queries (UPDATE/DELETE)\n- **@Param**: Named parameters\n- **@Query with SpEL**: Spring Expression Language\n\n### **2. Native Queries**\n- **@Query(nativeQuery = true)**: Native SQL queries\n- **@SqlResultSetMapping**: Result set mapping\n- **@NamedNativeQuery**: Named native queries\n- **Dynamic Native Queries**: Runtime query building\n\n### **3. Specification & Criteria API**\n- **JpaSpecificationExecutor**: Dynamic queries\n- **Specification**: Query specifications\n- **CriteriaBuilder**: Type-safe queries\n- **Predicate**: Query conditions\n\n## **Advanced JPA Patterns:**\n\n### **1. Entity Relationships**\n- **@OneToMany, @ManyToOne**: Bidirectional relationships\n- **@ManyToMany**: Many-to-many relationships\n- **@JoinColumn**: Custom join columns\n- **@JoinTable**: Custom join tables\n\n### **2. Entity Lifecycle**\n- **@PrePersist, @PostPersist**: Persistence callbacks\n- **@PreUpdate, @PostUpdate**: Update callbacks\n- **@PreRemove, @PostRemove**: Removal callbacks\n- **@PostLoad**: Load callbacks\n\n### **3. Advanced Mapping**\n- **@Embedded, @Embeddable**: Embedded objects\n- **@AttributeOverride**: Override embedded attributes\n- **@Inheritance**: Entity inheritance\n- **@DiscriminatorColumn**: Inheritance discrimination\n\n### **4. Performance Optimization**\n- **@EntityGraph**: Fetch strategies\n- **@BatchSize**: Batch loading\n- **@Fetch**: Fetch modes\n- **@Lazy, @Eager**: Lazy/eager loading",
          "code": "// Example: Custom Query Methods\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {\n    \n    // Custom JPQL query\n    @Query(\"SELECT u FROM User u WHERE u.email = :email AND u.active = true\")\n    Optional<User> findActiveUserByEmail(@Param(\"email\") String email);\n    \n    // Custom query with SpEL\n    @Query(\"SELECT u FROM User u WHERE u.createdDate >= :#{#date}\")\n    List<User> findUsersCreatedAfter(@Param(\"date\") LocalDateTime date);\n    \n    // Modifying query\n    @Modifying\n    @Query(\"UPDATE User u SET u.lastLogin = :loginTime WHERE u.id = :userId\")\n    int updateLastLogin(@Param(\"userId\") Long userId, @Param(\"loginTime\") LocalDateTime loginTime);\n    \n    // Native query\n    @Query(value = \"SELECT * FROM users WHERE age > :age\", nativeQuery = true)\n    List<User> findUsersOlderThan(@Param(\"age\") int age);\n    \n    // Named native query\n    @Query(nativeQuery = true)\n    List<User> findUsersByRole(@Param(\"role\") String role);\n}\n\n// Example: Specification Pattern\npublic class UserSpecifications {\n    \n    public static Specification<User> hasEmail(String email) {\n        return (root, query, cb) -> {\n            if (email == null) return cb.conjunction();\n            return cb.equal(root.get(\"email\"), email);\n        };\n    }\n    \n    public static Specification<User> isActive() {\n        return (root, query, cb) -> cb.equal(root.get(\"active\"), true);\n    }\n    \n    public static Specification<User> createdAfter(LocalDateTime date) {\n        return (root, query, cb) -> {\n            if (date == null) return cb.conjunction();\n            return cb.greaterThanOrEqualTo(root.get(\"createdDate\"), date);\n        };\n    }\n    \n    public static Specification<User> hasRole(String role) {\n        return (root, query, cb) -> {\n            if (role == null) return cb.conjunction();\n            return cb.equal(root.join(\"roles\").get(\"name\"), role);\n        };\n    }\n}\n\n// Example: Advanced Entity Relationships\n@Entity\n@Table(name = \"users\")\npublic class User {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(unique = true, nullable = false)\n    private String email;\n    \n    @Embedded\n    @AttributeOverrides({\n        @AttributeOverride(name = \"firstName\", column = @Column(name = \"first_name\")),\n        @AttributeOverride(name = \"lastName\", column = @Column(name = \"last_name\"))\n    })\n    private Name name;\n    \n    @OneToMany(mappedBy = \"user\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    @BatchSize(size = 10)\n    private List<Order> orders = new ArrayList<>();\n    \n    @ManyToMany(fetch = FetchType.LAZY)\n    @JoinTable(\n        name = \"user_roles\",\n        joinColumns = @JoinColumn(name = \"user_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"role_id\")\n    )\n    private Set<Role> roles = new HashSet<>();\n    \n    @OneToOne(mappedBy = \"user\", cascade = CascadeType.ALL)\n    private UserProfile profile;\n    \n    @PrePersist\n    public void prePersist() {\n        if (createdDate == null) {\n            createdDate = LocalDateTime.now();\n        }\n    }\n    \n    @PostLoad\n    public void postLoad() {\n        // Post-load processing\n    }\n}\n\n// Example: Entity Graph\n@Entity\n@NamedEntityGraph(\n    name = \"User.withOrders\",\n    attributeNodes = @NamedAttributeNode(\"orders\")\n)\npublic class User {\n    // ... entity definition\n}\n\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    @EntityGraph(\"User.withOrders\")\n    List<User> findByActiveTrue();\n    \n    @EntityGraph(attributePaths = {\"orders\", \"roles\"})\n    Optional<User> findWithOrdersAndRolesById(Long id);\n}\n\n// Example: Custom Repository Implementation\n@Repository\npublic class UserRepositoryImpl implements UserRepositoryCustom {\n    \n    @PersistenceContext\n    private EntityManager entityManager;\n    \n    @Override\n    public List<User> findUsersWithComplexCriteria(UserSearchCriteria criteria) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<User> query = cb.createQuery(User.class);\n        Root<User> root = query.from(User.class);\n        \n        List<Predicate> predicates = new ArrayList<>();\n        \n        if (criteria.getEmail() != null) {\n            predicates.add(cb.like(root.get(\"email\"), \"%\" + criteria.getEmail() + \"%\"));\n        }\n        \n        if (criteria.getMinAge() != null) {\n            predicates.add(cb.greaterThanOrEqualTo(root.get(\"age\"), criteria.getMinAge()));\n        }\n        \n        if (criteria.getRoles() != null && !criteria.getRoles().isEmpty()) {\n            predicates.add(root.join(\"roles\").get(\"name\").in(criteria.getRoles()));\n        }\n        \n        query.where(predicates.toArray(new Predicate[0]));\n        \n        return entityManager.createQuery(query).getResultList();\n    }\n}"
        },
        {
          "name": "Spring Data Redis Advanced",
          "text": "# Spring Data Redis Advanced Features\n\n**Advanced Redis features and patterns with Spring Data.**\n\n## **Redis Data Structures:**\n\n### **1. String Operations**\n- **StringRedisTemplate**: String operations\n- **Value Operations**: Basic key-value operations\n- **Atomic Operations**: Atomic increments/decrements\n- **Expiration**: TTL and expiration policies\n\n### **2. Hash Operations**\n- **HashRedisTemplate**: Hash operations\n- **Field Operations**: Hash field operations\n- **Batch Operations**: Multiple hash operations\n- **Serialization**: Custom serialization\n\n### **3. List Operations**\n- **ListRedisTemplate**: List operations\n- **Queue Operations**: Queue-like operations\n- **Blocking Operations**: Blocking list operations\n- **Range Operations**: List range operations\n\n### **4. Set Operations**\n- **SetRedisTemplate**: Set operations\n- **Set Operations**: Union, intersection, difference\n- **Membership**: Set membership operations\n- **Random Operations**: Random set operations\n\n### **5. Sorted Set Operations**\n- **ZSetRedisTemplate**: Sorted set operations\n- **Score Operations**: Score-based operations\n- **Range Operations**: Score range operations\n- **Rank Operations**: Rank-based operations\n\n## **Advanced Redis Patterns:**\n\n### **1. Caching Patterns**\n- **Cache-aside**: Application-managed cache\n- **Write-through**: Synchronous cache updates\n- **Write-behind**: Asynchronous cache updates\n- **Refresh-ahead**: Proactive cache refresh\n\n### **2. Session Management**\n- **Session Storage**: Redis-based sessions\n- **Session Clustering**: Multi-node sessions\n- **Session Expiration**: Automatic expiration\n- **Session Serialization**: Custom serialization\n\n### **3. Pub/Sub Messaging**\n- **Message Publishing**: Publish messages\n- **Message Subscription**: Subscribe to channels\n- **Pattern Matching**: Pattern-based subscriptions\n- **Message Serialization**: Custom message formats\n\n### **4. Distributed Locking**\n- **Redis Lock**: Distributed locks\n- **Lock Expiration**: Automatic lock release\n- **Lock Renewal**: Lock extension\n- **Deadlock Prevention**: Lock ordering\n\n### **5. Rate Limiting**\n- **Token Bucket**: Token bucket algorithm\n- **Sliding Window**: Sliding window algorithm\n- **Fixed Window**: Fixed window algorithm\n- **Distributed Rate Limiting**: Multi-node rate limiting",
          "code": "// Example: Redis Configuration\n@Configuration\n@EnableRedisRepositories\npublic class RedisConfig {\n    \n    @Bean\n    public LettuceConnectionFactory redisConnectionFactory() {\n        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();\n        config.setHostName(\"localhost\");\n        config.setPort(6379);\n        config.setDatabase(0);\n        \n        LettuceConnectionFactory factory = new LettuceConnectionFactory(config);\n        factory.setValidateConnection(true);\n        return factory;\n    }\n    \n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(connectionFactory);\n        template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        return template;\n    }\n    \n    @Bean\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {\n        return new StringRedisTemplate(connectionFactory);\n    }\n}\n\n// Example: Redis Repository\n@Repository\npublic interface UserRedisRepository extends CrudRepository<User, String> {\n    \n    List<User> findByEmail(String email);\n    \n    List<User> findByActiveTrue();\n    \n    @Query(\"*\")\n    List<User> findByEmailContaining(String email);\n}\n\n// Example: Redis Service\n@Service\npublic class RedisService {\n    \n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n    \n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    \n    // String operations\n    public void setString(String key, String value, Duration expiration) {\n        stringRedisTemplate.opsForValue().set(key, value, expiration);\n    }\n    \n    public String getString(String key) {\n        return stringRedisTemplate.opsForValue().get(key);\n    }\n    \n    public Long increment(String key) {\n        return stringRedisTemplate.opsForValue().increment(key);\n    }\n    \n    // Hash operations\n    public void setHash(String key, String field, Object value) {\n        redisTemplate.opsForHash().put(key, field, value);\n    }\n    \n    public Object getHash(String key, String field) {\n        return redisTemplate.opsForHash().get(key, field);\n    }\n    \n    public Map<Object, Object> getAllHash(String key) {\n        return redisTemplate.opsForHash().entries(key);\n    }\n    \n    // List operations\n    public void pushToList(String key, Object value) {\n        redisTemplate.opsForList().rightPush(key, value);\n    }\n    \n    public Object popFromList(String key) {\n        return redisTemplate.opsForList().leftPop(key);\n    }\n    \n    public List<Object> getListRange(String key, long start, long end) {\n        return redisTemplate.opsForList().range(key, start, end);\n    }\n    \n    // Set operations\n    public void addToSet(String key, Object value) {\n        redisTemplate.opsForSet().add(key, value);\n    }\n    \n    public Set<Object> getSetMembers(String key) {\n        return redisTemplate.opsForSet().members(key);\n    }\n    \n    public Set<Object> setIntersection(String key1, String key2) {\n        return redisTemplate.opsForSet().intersect(key1, key2);\n    }\n    \n    // Sorted set operations\n    public void addToSortedSet(String key, Object value, double score) {\n        redisTemplate.opsForZSet().add(key, value, score);\n    }\n    \n    public Set<Object> getSortedSetRange(String key, long start, long end) {\n        return redisTemplate.opsForZSet().range(key, start, end);\n    }\n    \n    public Set<Object> getSortedSetRangeByScore(String key, double min, double max) {\n        return redisTemplate.opsForZSet().rangeByScore(key, min, max);\n    }\n}\n\n// Example: Distributed Lock\n@Component\npublic class DistributedLockService {\n    \n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    \n    private static final String LOCK_PREFIX = \"lock:\";\n    private static final String LOCK_VALUE = \"locked\";\n    private static final Duration DEFAULT_TIMEOUT = Duration.ofSeconds(30);\n    \n    public boolean acquireLock(String lockKey, Duration timeout) {\n        String key = LOCK_PREFIX + lockKey;\n        Boolean acquired = stringRedisTemplate.opsForValue()\n            .setIfAbsent(key, LOCK_VALUE, timeout);\n        return Boolean.TRUE.equals(acquired);\n    }\n    \n    public void releaseLock(String lockKey) {\n        String key = LOCK_PREFIX + lockKey;\n        stringRedisTemplate.delete(key);\n    }\n    \n    public boolean tryWithLock(String lockKey, Duration timeout, Runnable task) {\n        if (acquireLock(lockKey, timeout)) {\n            try {\n                task.run();\n                return true;\n            } finally {\n                releaseLock(lockKey);\n            }\n        }\n        return false;\n    }\n}\n\n// Example: Rate Limiting\n@Component\npublic class RateLimitingService {\n    \n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    \n    public boolean isAllowed(String key, int limit, Duration window) {\n        String script = \"\"\"\n            local key = KEYS[1]\n            local limit = tonumber(ARGV[1])\n            local window = tonumber(ARGV[2])\n            local current = redis.call('GET', key)\n            if current == false then\n                redis.call('SET', key, 1)\n                redis.call('EXPIRE', key, window)\n                return 1\n            end\n            if tonumber(current) < limit then\n                return redis.call('INCR', key)\n            end\n            return 0\n        \"\"\";\n        \n        Long result = stringRedisTemplate.execute(\n            RedisScript.of(script, Long.class),\n            Collections.singletonList(key),\n            String.valueOf(limit),\n            String.valueOf(window.getSeconds())\n        );\n        \n        return result != null && result > 0;\n    }\n}\n\n// Example: Pub/Sub Messaging\n@Component\npublic class RedisMessagingService {\n    \n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n    \n    public void publish(String channel, Object message) {\n        redisTemplate.convertAndSend(channel, message);\n    }\n    \n    @EventListener\n    public void handleMessage(RedisMessageEvent event) {\n        // Handle received message\n        System.out.println(\"Received message: \" + event.getMessage());\n    }\n}\n\n// Example: Cache Service\n@Service\npublic class CacheService {\n    \n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n    \n    public <T> T get(String key, Class<T> type) {\n        Object value = redisTemplate.opsForValue().get(key);\n        if (value != null) {\n            return type.cast(value);\n        }\n        return null;\n    }\n    \n    public void set(String key, Object value, Duration expiration) {\n        redisTemplate.opsForValue().set(key, value, expiration);\n    }\n    \n    public void evict(String key) {\n        redisTemplate.delete(key);\n    }\n    \n    public void evictPattern(String pattern) {\n        Set<String> keys = redisTemplate.keys(pattern);\n        if (keys != null && !keys.isEmpty()) {\n            redisTemplate.delete(keys);\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "spring-batch-advanced",
      "title": "âš¡ Batch Advanced",
      "sections": [
        {
          "name": "Spring Batch Core Concepts",
          "text": "# Spring Batch Core Concepts\n\n**Advanced batch processing concepts and patterns with Spring Batch.**\n\n## **Batch Architecture:**\n\n### **1. Job & Step Structure**\n- **Job**: Top-level batch process\n- **Step**: Individual processing unit\n- **JobInstance**: Logical job execution\n- **JobExecution**: Physical job execution\n\n### **2. Item Processing**\n- **ItemReader**: Read input data\n- **ItemProcessor**: Process data items\n- **ItemWriter**: Write output data\n- **Chunk Processing**: Process items in chunks\n\n### **3. Job Repository**\n- **JobRepository**: Store job metadata\n- **JobExplorer**: Query job information\n- **JobOperator**: Control job execution\n- **JobRegistry**: Register job definitions\n\n## **Advanced Batch Patterns:**\n\n### **1. Parallel Processing**\n- **Parallel Steps**: Execute steps in parallel\n- **Partitioning**: Split data into partitions\n- **Multi-threading**: Thread-based processing\n- **Remote Chunking**: Distributed processing\n\n### **2. Error Handling**\n- **Skip Policy**: Skip failed items\n- **Retry Policy**: Retry failed operations\n- **Exception Handling**: Custom exception handling\n- **Rollback Strategy**: Transaction rollback\n\n### **3. Monitoring & Metrics**\n- **Job Monitoring**: Monitor job execution\n- **Step Metrics**: Track step performance\n- **Custom Metrics**: Application-specific metrics\n- **Alerting**: Failure notifications\n\n### **4. Job Scheduling**\n- **Cron Scheduling**: Time-based scheduling\n- **Event-driven**: Event-triggered jobs\n- **Dependency Management**: Job dependencies\n- **Conditional Execution**: Conditional job execution",
          "code": "// Example: Basic Job Configuration\n@Configuration\n@EnableBatchProcessing\npublic class BatchConfig {\n    \n    @Autowired\n    private JobBuilderFactory jobBuilderFactory;\n    \n    @Autowired\n    private StepBuilderFactory stepBuilderFactory;\n    \n    @Bean\n    public Job userProcessingJob() {\n        return jobBuilderFactory.get(\"userProcessingJob\")\n            .incrementer(new RunIdIncrementer())\n            .start(processUsersStep())\n            .next(sendNotificationStep())\n            .build();\n    }\n    \n    @Bean\n    public Step processUsersStep() {\n        return stepBuilderFactory.get(\"processUsersStep\")\n            .<User, ProcessedUser>chunk(100)\n            .reader(userReader())\n            .processor(userProcessor())\n            .writer(userWriter())\n            .faultTolerant()\n            .skipLimit(10)\n            .skip(DataAccessException.class)\n            .retryLimit(3)\n            .retry(DataAccessException.class)\n            .build();\n    }\n    \n    @Bean\n    public ItemReader<User> userReader() {\n        return new JdbcCursorItemReaderBuilder<User>()\n            .dataSource(dataSource)\n            .sql(\"SELECT * FROM users WHERE processed = false\")\n            .rowMapper(new BeanPropertyRowMapper<>(User.class))\n            .build();\n    }\n    \n    @Bean\n    public ItemProcessor<User, ProcessedUser> userProcessor() {\n        return new UserProcessor();\n    }\n    \n    @Bean\n    public ItemWriter<ProcessedUser> userWriter() {\n        return new JdbcBatchItemWriterBuilder<ProcessedUser>()\n            .dataSource(dataSource)\n            .sql(\"INSERT INTO processed_users (id, name, email, processed_date) VALUES (?, ?, ?, ?)\")\n            .itemPreparedStatementSetter(new ProcessedUserPreparedStatementSetter())\n            .build();\n    }\n}\n\n// Example: Parallel Processing\n@Configuration\npublic class ParallelBatchConfig {\n    \n    @Bean\n    public Job parallelProcessingJob() {\n        return jobBuilderFactory.get(\"parallelProcessingJob\")\n            .start(partitionStep())\n            .build();\n    }\n    \n    @Bean\n    public Step partitionStep() {\n        return stepBuilderFactory.get(\"partitionStep\")\n            .partitioner(\"slaveStep\", partitioner())\n            .step(slaveStep())\n            .gridSize(4)\n            .taskExecutor(taskExecutor())\n            .build();\n    }\n    \n    @Bean\n    public Step slaveStep() {\n        return stepBuilderFactory.get(\"slaveStep\")\n            .<User, ProcessedUser>chunk(50)\n            .reader(userReader())\n            .processor(userProcessor())\n            .writer(userWriter())\n            .build();\n    }\n    \n    @Bean\n    public Partitioner partitioner() {\n        return new UserPartitioner();\n    }\n    \n    @Bean\n    public TaskExecutor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(4);\n        executor.setMaxPoolSize(8);\n        executor.setQueueCapacity(100);\n        executor.setThreadNamePrefix(\"batch-\");\n        executor.initialize();\n        return executor;\n    }\n}\n\n// Example: Custom Item Processor\n@Component\npublic class UserProcessor implements ItemProcessor<User, ProcessedUser> {\n    \n    @Override\n    public ProcessedUser process(User user) throws Exception {\n        // Validate user data\n        if (user.getEmail() == null || !user.getEmail().contains(\"@\")) {\n            throw new ValidationException(\"Invalid email: \" + user.getEmail());\n        }\n        \n        // Transform user data\n        ProcessedUser processedUser = new ProcessedUser();\n        processedUser.setId(user.getId());\n        processedUser.setName(user.getFirstName() + \" \" + user.getLastName());\n        processedUser.setEmail(user.getEmail().toLowerCase());\n        processedUser.setProcessedDate(LocalDateTime.now());\n        \n        return processedUser;\n    }\n}\n\n// Example: Custom Partitioner\n@Component\npublic class UserPartitioner implements Partitioner {\n    \n    @Autowired\n    private DataSource dataSource;\n    \n    @Override\n    public Map<String, ExecutionContext> partition(int gridSize) {\n        Map<String, ExecutionContext> partitions = new HashMap<>();\n        \n        // Get total count of users to process\n        int totalCount = getTotalUserCount();\n        int partitionSize = totalCount / gridSize;\n        \n        for (int i = 0; i < gridSize; i++) {\n            ExecutionContext context = new ExecutionContext();\n            context.putInt(\"minValue\", i * partitionSize);\n            context.putInt(\"maxValue\", (i + 1) * partitionSize - 1);\n            context.putString(\"partitionName\", \"partition\" + i);\n            \n            partitions.put(\"partition\" + i, context);\n        }\n        \n        return partitions;\n    }\n    \n    private int getTotalUserCount() {\n        // Implementation to get total count\n        return 1000; // Example value\n    }\n}\n\n// Example: Job Scheduling\n@Configuration\n@EnableScheduling\npublic class JobSchedulingConfig {\n    \n    @Autowired\n    private JobLauncher jobLauncher;\n    \n    @Autowired\n    private Job userProcessingJob;\n    \n    @Scheduled(cron = \"0 0 2 * * ?\") // Daily at 2 AM\n    public void runUserProcessingJob() {\n        try {\n            JobParameters jobParameters = new JobParametersBuilder()\n                .addLong(\"time\", System.currentTimeMillis())\n                .toJobParameters();\n            \n            jobLauncher.run(userProcessingJob, jobParameters);\n        } catch (Exception e) {\n            log.error(\"Failed to run user processing job\", e);\n        }\n    }\n}\n\n// Example: Job Monitoring\n@Component\npublic class JobMonitoringService {\n    \n    @Autowired\n    private JobExplorer jobExplorer;\n    \n    @Autowired\n    private JobOperator jobOperator;\n    \n    public List<JobExecution> getRunningJobs() {\n        return jobExplorer.findRunningJobExecutions(\"userProcessingJob\");\n    }\n    \n    public JobExecution getJobExecution(Long executionId) {\n        return jobExplorer.getJobExecution(executionId);\n    }\n    \n    public void stopJob(Long executionId) {\n        jobOperator.stop(executionId);\n    }\n    \n    public void restartJob(Long executionId) {\n        jobOperator.restart(executionId);\n    }\n}"
        },
        {
          "name": "Spring Batch Advanced Patterns",
          "text": "# Spring Batch Advanced Patterns\n\n**Advanced patterns and techniques for complex batch processing scenarios.**\n\n## **Advanced Processing Patterns:**\n\n### **1. Multi-step Jobs**\n- **Sequential Steps**: Execute steps in sequence\n- **Conditional Steps**: Conditional step execution\n- **Parallel Steps**: Execute steps in parallel\n- **Decision Steps**: Decision-based step selection\n\n### **2. Complex Data Processing**\n- **Composite ItemProcessor**: Multiple processors\n- **Classifier**: Route items to different processors\n- **Aggregator**: Aggregate multiple items\n- **Splitter**: Split items into multiple outputs\n\n### **3. Error Handling Strategies**\n- **Skip Policies**: Custom skip logic\n- **Retry Policies**: Custom retry logic\n- **Exception Classifiers**: Classify exceptions\n- **Recovery Strategies**: Recovery mechanisms\n\n### **4. Performance Optimization**\n- **Chunk Size Tuning**: Optimize chunk sizes\n- **Memory Management**: Memory optimization\n- **Database Optimization**: Database tuning\n- **Resource Pooling**: Resource management\n\n## **Integration Patterns:**\n\n### **1. File Processing**\n- **Flat File Processing**: CSV, fixed-width files\n- **XML Processing**: XML file processing\n- **JSON Processing**: JSON file processing\n- **Multi-format Support**: Multiple file formats\n\n### **2. Database Integration**\n- **JPA Integration**: JPA-based processing\n- **JDBC Integration**: JDBC-based processing\n- **Stored Procedures**: Database procedures\n- **Batch Updates**: Bulk database operations\n\n### **3. Message Integration**\n- **JMS Integration**: JMS message processing\n- **Kafka Integration**: Kafka message processing\n- **RabbitMQ Integration**: RabbitMQ processing\n- **Event-driven Processing**: Event-based processing\n\n### **4. Web Service Integration**\n- **REST API Integration**: REST service calls\n- **SOAP Integration**: SOAP service calls\n- **Async Processing**: Asynchronous processing\n- **Circuit Breaker**: Fault tolerance",
          "code": "// Example: Multi-step Job with Decision\n@Configuration\npublic class MultiStepBatchConfig {\n    \n    @Bean\n    public Job multiStepJob() {\n        return jobBuilderFactory.get(\"multiStepJob\")\n            .start(initialStep())\n            .next(decisionStep())\n            .from(decisionStep())\n                .on(\"CONTINUE\")\n                .to(processingStep())\n            .from(decisionStep())\n                .on(\"SKIP\")\n                .to(cleanupStep())\n            .from(processingStep())\n                .next(validationStep())\n            .from(validationStep())\n                .on(\"VALID\")\n                .to(completionStep())\n            .from(validationStep())\n                .on(\"INVALID\")\n                .to(errorHandlingStep())\n            .end()\n            .build();\n    }\n    \n    @Bean\n    public Step decisionStep() {\n        return stepBuilderFactory.get(\"decisionStep\")\n            .jobExecutionDecider(new ProcessingDecisionDecider())\n            .build();\n    }\n}\n\n// Example: Custom Decision Decider\n@Component\npublic class ProcessingDecisionDecider implements JobExecutionDecider {\n    \n    @Override\n    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {\n        // Check if there are items to process\n        int itemCount = stepExecution.getReadCount();\n        \n        if (itemCount > 0) {\n            return new FlowExecutionStatus(\"CONTINUE\");\n        } else {\n            return new FlowExecutionStatus(\"SKIP\");\n        }\n    }\n}\n\n// Example: Composite Item Processor\n@Component\npublic class CompositeUserProcessor implements ItemProcessor<User, ProcessedUser> {\n    \n    @Autowired\n    private List<ItemProcessor<User, User>> processors;\n    \n    @Override\n    public ProcessedUser process(User user) throws Exception {\n        User processedUser = user;\n        \n        // Apply all processors in sequence\n        for (ItemProcessor<User, User> processor : processors) {\n            processedUser = processor.process(processedUser);\n        }\n        \n        // Convert to final output format\n        return convertToProcessedUser(processedUser);\n    }\n    \n    private ProcessedUser convertToProcessedUser(User user) {\n        ProcessedUser processedUser = new ProcessedUser();\n        processedUser.setId(user.getId());\n        processedUser.setName(user.getFirstName() + \" \" + user.getLastName());\n        processedUser.setEmail(user.getEmail());\n        processedUser.setProcessedDate(LocalDateTime.now());\n        return processedUser;\n    }\n}\n\n// Example: Custom Skip Policy\n@Component\npublic class CustomSkipPolicy implements SkipPolicy {\n    \n    @Override\n    public boolean shouldSkip(Throwable throwable, int skipCount) {\n        if (throwable instanceof ValidationException) {\n            return skipCount < 100; // Skip up to 100 validation errors\n        }\n        if (throwable instanceof DataAccessException) {\n            return skipCount < 10; // Skip up to 10 data access errors\n        }\n        return false; // Don't skip other exceptions\n    }\n}\n\n// Example: Custom Retry Policy\n@Component\npublic class CustomRetryPolicy implements RetryPolicy {\n    \n    @Override\n    public boolean canRetry(RetryContext context) {\n        Throwable lastException = context.getLastThrowable();\n        int retryCount = context.getRetryCount();\n        \n        if (lastException instanceof DataAccessException) {\n            return retryCount < 3; // Retry up to 3 times for data access errors\n        }\n        if (lastException instanceof TimeoutException) {\n            return retryCount < 5; // Retry up to 5 times for timeout errors\n        }\n        return false; // Don't retry other exceptions\n    }\n    \n    @Override\n    public void close(RetryContext context) {\n        // Cleanup resources if needed\n    }\n    \n    @Override\n    public void registerThrowable(RetryContext context, Throwable throwable) {\n        context.registerThrowable(throwable);\n    }\n}\n\n// Example: File Processing Job\n@Configuration\npublic class FileProcessingBatchConfig {\n    \n    @Bean\n    public Job fileProcessingJob() {\n        return jobBuilderFactory.get(\"fileProcessingJob\")\n            .start(fileProcessingStep())\n            .build();\n    }\n    \n    @Bean\n    public Step fileProcessingStep() {\n        return stepBuilderFactory.get(\"fileProcessingStep\")\n            .<String, ProcessedRecord>chunk(1000)\n            .reader(fileReader())\n            .processor(recordProcessor())\n            .writer(fileWriter())\n            .build();\n    }\n    \n    @Bean\n    public ItemReader<String> fileReader() {\n        return new FlatFileItemReaderBuilder<String>()\n            .name(\"fileReader\")\n            .resource(new ClassPathResource(\"data/input.csv\"))\n            .delimited()\n            .names(\"field1\", \"field2\", \"field3\")\n            .fieldSetMapper(new BeanWrapperFieldSetMapper<String>())\n            .build();\n    }\n    \n    @Bean\n    public ItemWriter<ProcessedRecord> fileWriter() {\n        return new FlatFileItemWriterBuilder<ProcessedRecord>()\n            .name(\"fileWriter\")\n            .resource(new FileSystemResource(\"data/output.csv\"))\n            .delimited()\n            .names(\"id\", \"name\", \"email\", \"processedDate\")\n            .build();\n    }\n}\n\n// Example: JMS Integration\n@Configuration\npublic class JmsBatchConfig {\n    \n    @Bean\n    public Job jmsProcessingJob() {\n        return jobBuilderFactory.get(\"jmsProcessingJob\")\n            .start(jmsProcessingStep())\n            .build();\n    }\n    \n    @Bean\n    public Step jmsProcessingStep() {\n        return stepBuilderFactory.get(\"jmsProcessingStep\")\n            .<Message, ProcessedMessage>chunk(100)\n            .reader(jmsReader())\n            .processor(messageProcessor())\n            .writer(jmsWriter())\n            .build();\n    }\n    \n    @Bean\n    public ItemReader<Message> jmsReader() {\n        return new JmsItemReaderBuilder<Message>()\n            .jmsTemplate(jmsTemplate())\n            .itemType(Message.class)\n            .build();\n    }\n    \n    @Bean\n    public ItemWriter<ProcessedMessage> jmsWriter() {\n        return new JmsItemWriterBuilder<ProcessedMessage>()\n            .jmsTemplate(jmsTemplate())\n            .build();\n    }\n}\n\n// Example: Performance Monitoring\n@Component\npublic class BatchPerformanceMonitor {\n    \n    @EventListener\n    public void handleStepExecution(StepExecutionListener stepExecution) {\n        long startTime = stepExecution.getStartTime().getTime();\n        long endTime = stepExecution.getEndTime().getTime();\n        long duration = endTime - startTime;\n        \n        int readCount = stepExecution.getReadCount();\n        int writeCount = stepExecution.getWriteCount();\n        int skipCount = stepExecution.getSkipCount();\n        \n        // Log performance metrics\n        log.info(\"Step: {}, Duration: {}ms, Read: {}, Write: {}, Skip: {}\", \n            stepExecution.getStepName(), duration, readCount, writeCount, skipCount);\n        \n        // Calculate throughput\n        double throughput = (double) writeCount / (duration / 1000.0);\n        log.info(\"Throughput: {} items/second\", throughput);\n    }\n}"
        }
      ]
    },
    {
      "id": "spring-security-advanced",
      "title": "ðŸ”’ Security Advanced",
      "sections": [
        {
          "name": "Authentication & Authorization",
          "text": "# Spring Security Advanced Authentication\n\n**Advanced authentication and authorization patterns with Spring Security.**\n\n## **Authentication Strategies:**\n\n### **1. JWT Authentication**\n- **Stateless**: No server-side session storage\n- **Self-Contained**: Contains user information and permissions\n- **Scalable**: Easy to scale across multiple services\n- **Security**: Signed and optionally encrypted\n\n### **2. OAuth 2.0 Integration**\n- **Authorization Server**: Centralized authorization\n- **Resource Server**: Protected resources\n- **Client Applications**: Consumer applications\n- **Grant Types**: Authorization Code, Client Credentials, etc.\n\n### **3. Multi-Factor Authentication**\n- **TOTP**: Time-based one-time passwords\n- **SMS**: SMS-based verification\n- **Email**: Email-based verification\n- **Hardware Tokens**: Physical security keys\n\n## **Authorization Patterns:**\n\n### **1. Method-Level Security**\n- **@PreAuthorize**: Pre-execution authorization\n- **@PostAuthorize**: Post-execution authorization\n- **@Secured**: Simple role-based security\n- **@RolesAllowed**: JSR-250 annotation support\n\n### **2. Custom Authorization**\n- **Voter Pattern**: Custom access decision voters\n- **Expression Evaluator**: Custom SpEL expressions\n- **Permission Evaluator**: Custom permission evaluation\n- **ACL**: Access Control Lists\n\n### **3. Resource-Level Security**\n- **Domain Object Security**: Secure individual objects\n- **ACL**: Fine-grained access control\n- **Custom Security**: Business logic-based security\n- **Dynamic Security**: Runtime security decisions",
          "code": "// Example: JWT Authentication Configuration\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Autowired\n    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;\n    \n    @Autowired\n    private JwtRequestFilter jwtRequestFilter;\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n    \n    @Bean\n    public AuthenticationManager authenticationManager(\n            AuthenticationConfiguration authConfig) throws Exception {\n        return authConfig.getAuthenticationManager();\n    }\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http.csrf().disable()\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/authenticate\", \"/register\").permitAll()\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .requestMatchers(\"/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint)\n            .and()\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        \n        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);\n        \n        return http.build();\n    }\n}\n\n// Example: JWT Token Provider\n@Component\npublic class JwtTokenProvider {\n    \n    private final String secretKey = \"mySecretKey\";\n    private final long validityInMilliseconds = 3600000; // 1 hour\n    \n    public String generateToken(UserDetails userDetails) {\n        Date now = new Date();\n        Date validity = new Date(now.getTime() + validityInMilliseconds);\n        \n        return Jwts.builder()\n            .setSubject(userDetails.getUsername())\n            .setIssuedAt(now)\n            .setExpiration(validity)\n            .claim(\"roles\", userDetails.getAuthorities())\n            .signWith(SignatureAlgorithm.HS256, secretKey)\n            .compact();\n    }\n    \n    public boolean validateToken(String token) {\n        try {\n            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);\n            return true;\n        } catch (JwtException | IllegalArgumentException e) {\n            return false;\n        }\n    }\n    \n    public String getUsernameFromToken(String token) {\n        return Jwts.parser()\n            .setSigningKey(secretKey)\n            .parseClaimsJws(token)\n            .getBody()\n            .getSubject();\n    }\n}\n\n// Example: Method-Level Security\n@Service\npublic class UserService {\n    \n    @PreAuthorize(\"hasRole('ADMIN') or #userId == authentication.name\")\n    public User getUser(String userId) {\n        return userRepository.findById(userId);\n    }\n    \n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public void deleteUser(String userId) {\n        userRepository.deleteById(userId);\n    }\n    \n    @PostAuthorize(\"returnObject.owner == authentication.name or hasRole('ADMIN')\")\n    public Order getOrder(String orderId) {\n        return orderRepository.findById(orderId);\n    }\n    \n    @Secured(\"ROLE_ADMIN\")\n    public void updateUser(User user) {\n        userRepository.save(user);\n    }\n}\n\n// Example: Custom Authorization\n@Component\npublic class CustomPermissionEvaluator implements PermissionEvaluator {\n    \n    @Override\n    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {\n        if (targetDomainObject instanceof User) {\n            User user = (User) targetDomainObject;\n            String username = authentication.getName();\n            \n            if (\"read\".equals(permission)) {\n                return user.getUsername().equals(username) || hasRole(authentication, \"ADMIN\");\n            }\n            if (\"write\".equals(permission)) {\n                return user.getUsername().equals(username);\n            }\n        }\n        \n        return false;\n    }\n    \n    @Override\n    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {\n        // Implementation for targetId-based permission checking\n        return false;\n    }\n    \n    private boolean hasRole(Authentication authentication, String role) {\n        return authentication.getAuthorities().stream()\n            .anyMatch(auth -> auth.getAuthority().equals(\"ROLE_\" + role));\n    }\n}\n\n// Example: OAuth 2.0 Resource Server\n@Configuration\n@EnableResourceServer\npublic class ResourceServerConfig extends ResourceServerConfigurerAdapter {\n    \n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n            .antMatchers(\"/api/public/**\").permitAll()\n            .antMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n            .antMatchers(\"/api/user/**\").hasRole(\"USER\")\n            .anyRequest().authenticated()\n            .and()\n            .oauth2ResourceServer()\n            .jwt();\n    }\n}\n\n// Example: Multi-Factor Authentication\n@Service\npublic class MfaService {\n    \n    @Autowired\n    private TotpService totpService;\n    \n    @Autowired\n    private EmailService emailService;\n    \n    public String generateTotpSecret(String username) {\n        return totpService.generateSecret();\n    }\n    \n    public boolean verifyTotpCode(String username, String code) {\n        String secret = getTotpSecret(username);\n        return totpService.verifyCode(secret, code);\n    }\n    \n    public void sendEmailVerification(String username, String email) {\n        String code = generateVerificationCode();\n        emailService.sendVerificationCode(email, code);\n        storeVerificationCode(username, code);\n    }\n    \n    public boolean verifyEmailCode(String username, String code) {\n        String storedCode = getVerificationCode(username);\n        return code.equals(storedCode);\n    }\n}"
        }
      ]
    }
  ]
}
