{
  "config": {
    "id": "java-advanced",
    "name": "Java Advanced",
    "description": "Advanced Java Concepts",
    "icon": "🎯",
    "enabled": true
  },
  "content": [
    {
      "id": "memory-management",
      "title": "🧠 Memory Management & JVM",
      "sections": [
        {
          "name": "✅ Heap Memory Structure",
          "text": "Understanding the JVM heap memory layout is crucial for performance optimization and memory leak detection.",
          "code": "// JVM Heap Memory Areas\n// 1. Young Generation (Eden, S0, S1)\n// 2. Old Generation (Tenured)\n// 3. Metaspace (Java 8+) / PermGen (Java 7-)\n\n// Memory allocation example\npublic class MemoryExample {\n    private static final int MEGABYTE = 1024 * 1024;\n    \n    public static void main(String[] args) {\n        // Large object allocation in Eden space\n        byte[] largeArray = new byte[10 * MEGABYTE];\n        \n        // Monitor memory usage\n        Runtime runtime = Runtime.getRuntime();\n        long maxMemory = runtime.maxMemory();\n        long totalMemory = runtime.totalMemory();\n        long freeMemory = runtime.freeMemory();\n        \n        System.out.println(\"Max Memory: \" + maxMemory / MEGABYTE + \" MB\");\n        System.out.println(\"Total Memory: \" + totalMemory / MEGABYTE + \" MB\");\n        System.out.println(\"Free Memory: \" + freeMemory / MEGABYTE + \" MB\");\n    }\n}"
        },
        {
          "name": "✅ Garbage Collection Algorithms",
          "text": "Different GC algorithms and their trade-offs for different application types.",
          "code": "// Garbage Collection Types\n// 1. Serial GC: Single-threaded, good for small applications\n// 2. Parallel GC: Multi-threaded, default for server applications\n// 3. G1 GC: Low-latency, good for large heap sizes\n// 4. ZGC/Shenandoah: Ultra-low latency\n\n// JVM Flags for GC tuning\n// -XX:+UseG1GC                    // Enable G1 GC\n// -XX:MaxGCPauseMillis=200        // Target pause time\n// -XX:G1HeapRegionSize=16m        // Region size\n// -XX:+PrintGCDetails             // Print GC details\n\npublic class GCExample {\n    private List<String> data = new ArrayList<>();\n    \n    public void createMemoryPressure() {\n        // Create objects that will be garbage collected\n        for (int i = 0; i < 1000000; i++) {\n            data.add(\"String \" + i);\n            \n            // Force GC every 100k iterations\n            if (i % 100000 == 0) {\n                System.gc(); // Hint to JVM\n            }\n        }\n    }\n    \n    // Memory leak example - objects not eligible for GC\n    private static List<Object> memoryLeak = new ArrayList<>();\n    \n    public void createMemoryLeak() {\n        // Objects added to static list never get GC'd\n        memoryLeak.add(new Object());\n    }\n}"
        },
        {
          "name": "✅ Memory Leaks & Profiling",
          "text": "Common memory leak patterns and how to detect them using profiling tools.",
          "code": "// Common Memory Leak Patterns\n\n// 1. Static Collections\npublic class StaticCollectionLeak {\n    private static List<Object> staticList = new ArrayList<>();\n    \n    public void addToStaticList(Object obj) {\n        staticList.add(obj); // Never removed!\n    }\n}\n\n// 2. Unclosed Resources\npublic class ResourceLeak {\n    public void readFile() {\n        FileInputStream fis = null;\n        try {\n            fis = new FileInputStream(\"file.txt\");\n            // Process file\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // Missing finally block to close fis!\n    }\n    \n    // Better approach with try-with-resources\n    public void readFileCorrectly() {\n        try (FileInputStream fis = new FileInputStream(\"file.txt\")) {\n            // Process file\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // Automatically closed\n    }\n}\n\n// 3. Event Listeners\npublic class ListenerLeak {\n    private List<EventListener> listeners = new ArrayList<>();\n    \n    public void addListener(EventListener listener) {\n        listeners.add(listener);\n    }\n    \n    // Missing removeListener method!\n    public void removeListener(EventListener listener) {\n        listeners.remove(listener);\n    }\n}\n\n// Memory profiling with WeakReference\npublic class MemoryProfiling {\n    public static void main(String[] args) {\n        Object obj = new Object();\n        WeakReference<Object> weakRef = new WeakReference<>(obj);\n        \n        // Check if object is still in memory\n        if (weakRef.get() != null) {\n            System.out.println(\"Object still in memory\");\n        }\n        \n        obj = null; // Remove strong reference\n        System.gc(); // Force GC\n        \n        if (weakRef.get() == null) {\n            System.out.println(\"Object has been garbage collected\");\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "concurrency-advanced",
      "title": "⚡ Advanced Concurrency",
      "sections": [
        {
          "name": "✅ Lock-Free Programming",
          "text": "Lock-free data structures and algorithms using CAS (Compare-And-Swap) operations.",
          "code": "import java.util.concurrent.atomic.*;\n\n// Lock-free counter using AtomicInteger\npublic class LockFreeCounter {\n    private final AtomicInteger count = new AtomicInteger(0);\n    \n    public int increment() {\n        return count.incrementAndGet();\n    }\n    \n    public int decrement() {\n        return count.decrementAndGet();\n    }\n    \n    public int get() {\n        return count.get();\n    }\n    \n    // Compare and swap example\n    public boolean compareAndSet(int expected, int newValue) {\n        return count.compareAndSet(expected, newValue);\n    }\n}\n\n// Lock-free stack implementation\npublic class LockFreeStack<T> {\n    private final AtomicReference<Node<T>> head = new AtomicReference<>();\n    \n    private static class Node<T> {\n        final T data;\n        final AtomicReference<Node<T>> next;\n        \n        Node(T data) {\n            this.data = data;\n            this.next = new AtomicReference<>();\n        }\n    }\n    \n    public void push(T item) {\n        Node<T> newNode = new Node<>(item);\n        Node<T> currentHead;\n        \n        do {\n            currentHead = head.get();\n            newNode.next.set(currentHead);\n        } while (!head.compareAndSet(currentHead, newNode));\n    }\n    \n    public T pop() {\n        Node<T> currentHead;\n        Node<T> newHead;\n        \n        do {\n            currentHead = head.get();\n            if (currentHead == null) {\n                return null;\n            }\n            newHead = currentHead.next.get();\n        } while (!head.compareAndSet(currentHead, newHead));\n        \n        return currentHead.data;\n    }\n}"
        },
        {
          "name": "✅ Thread Pools & Executors",
          "text": "Advanced thread pool configurations and custom executor implementations.",
          "code": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n// Custom ThreadFactory\npublic class CustomThreadFactory implements ThreadFactory {\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    private final String namePrefix;\n    \n    public CustomThreadFactory(String namePrefix) {\n        this.namePrefix = namePrefix;\n    }\n    \n    @Override\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());\n        t.setDaemon(false);\n        t.setPriority(Thread.NORM_PRIORITY);\n        return t;\n    }\n}\n\n// Custom RejectedExecutionHandler\npublic class CustomRejectedExecutionHandler implements RejectedExecutionHandler {\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n        if (!executor.isShutdown()) {\n            System.out.println(\"Task rejected: \" + r.toString());\n            // Could implement retry logic, logging, or fallback mechanism\n        }\n    }\n}\n\n// Advanced Thread Pool Configuration\npublic class AdvancedThreadPool {\n    \n    public static void main(String[] args) {\n        // Custom thread pool with monitoring\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n            2,                              // corePoolSize\n            10,                             // maximumPoolSize\n            60L,                            // keepAliveTime\n            TimeUnit.SECONDS,               // timeUnit\n            new LinkedBlockingQueue<>(100), // workQueue\n            new CustomThreadFactory(\"CustomPool-\"), // threadFactory\n            new CustomRejectedExecutionHandler()  // rejectedExecutionHandler\n        );\n        \n        // Add shutdown hook\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            executor.shutdown();\n            try {\n                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n                    executor.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                executor.shutdownNow();\n            }\n        }));\n        \n        // Submit tasks\n        for (int i = 0; i < 20; i++) {\n            final int taskId = i;\n            executor.submit(() -> {\n                System.out.println(\"Task \" + taskId + \" executed by \" + Thread.currentThread().getName());\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            });\n        }\n        \n        // Monitor thread pool\n        ScheduledExecutorService monitor = Executors.newScheduledThreadPool(1);\n        monitor.scheduleAtFixedRate(() -> {\n            System.out.println(\"Active threads: \" + executor.getActiveCount());\n            System.out.println(\"Completed tasks: \" + executor.getCompletedTaskCount());\n            System.out.println(\"Queue size: \" + executor.getQueue().size());\n        }, 0, 2, TimeUnit.SECONDS);\n    }\n}"
        },
        {
          "name": "✅ Concurrent Collections",
          "text": "Advanced usage of concurrent collections and custom concurrent data structures.",
          "code": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\nimport java.util.*;\n\n// ConcurrentHashMap advanced usage\npublic class ConcurrentCollectionsExample {\n    \n    public static void main(String[] args) {\n        // ConcurrentHashMap with custom operations\n        ConcurrentHashMap<String, AtomicInteger> map = new ConcurrentHashMap<>();\n        \n        // Thread-safe increment operation\n        map.computeIfAbsent(\"counter\", k -> new AtomicInteger(0)).incrementAndGet();\n        \n        // Atomic operations\n        map.merge(\"counter\", new AtomicInteger(1), (oldVal, newVal) -> {\n            oldVal.addAndGet(newVal.get());\n            return oldVal;\n        });\n        \n        // ConcurrentLinkedQueue for high-throughput scenarios\n        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();\n        \n        // Producer\n        ExecutorService producer = Executors.newFixedThreadPool(2);\n        for (int i = 0; i < 10; i++) {\n            final int item = i;\n            producer.submit(() -> {\n                queue.offer(\"Item-\" + item);\n                System.out.println(\"Produced: Item-\" + item);\n            });\n        }\n        \n        // Consumer\n        ExecutorService consumer = Executors.newFixedThreadPool(2);\n        for (int i = 0; i < 10; i++) {\n            consumer.submit(() -> {\n                String item = queue.poll();\n                if (item != null) {\n                    System.out.println(\"Consumed: \" + item);\n                }\n            });\n        }\n        \n        // CopyOnWriteArrayList for read-heavy scenarios\n        CopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>();\n        cowList.addAll(Arrays.asList(\"A\", \"B\", \"C\"));\n        \n        // Concurrent readers\n        ExecutorService readers = Executors.newFixedThreadPool(5);\n        for (int i = 0; i < 5; i++) {\n            readers.submit(() -> {\n                for (String item : cowList) {\n                    System.out.println(\"Read: \" + item);\n                }\n            });\n        }\n        \n        // Writer (creates new copy)\n        cowList.add(\"D\");\n        \n        // BlockingQueue for producer-consumer pattern\n        BlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<>(10);\n        \n        // Producer with blocking put\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 20; i++) {\n                    blockingQueue.put(i);\n                    System.out.println(\"Put: \" + i);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }).start();\n        \n        // Consumer with blocking take\n        new Thread(() -> {\n            try {\n                while (true) {\n                    Integer item = blockingQueue.take();\n                    System.out.println(\"Took: \" + item);\n                    Thread.sleep(100);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }).start();\n    }\n}"
        }
      ]
    },
    {
      "id": "design-patterns",
      "title": "🏗️ Advanced Design Patterns",
      "sections": [
        {
          "name": "✅ Singleton Patterns",
          "text": "Different singleton implementations and their trade-offs in concurrent environments.",
          "code": "// 1. Eager Initialization (Thread-safe but not lazy)\npublic class EagerSingleton {\n    private static final EagerSingleton INSTANCE = new EagerSingleton();\n    \n    private EagerSingleton() {}\n    \n    public static EagerSingleton getInstance() {\n        return INSTANCE;\n    }\n}\n\n// 2. Lazy Initialization (Not thread-safe)\npublic class LazySingleton {\n    private static LazySingleton instance;\n    \n    private LazySingleton() {}\n    \n    public static LazySingleton getInstance() {\n        if (instance == null) {\n            instance = new LazySingleton(); // Race condition!\n        }\n        return instance;\n    }\n}\n\n// 3. Thread-safe Lazy Initialization with synchronized\npublic class SynchronizedSingleton {\n    private static SynchronizedSingleton instance;\n    \n    private SynchronizedSingleton() {}\n    \n    public static synchronized SynchronizedSingleton getInstance() {\n        if (instance == null) {\n            instance = new SynchronizedSingleton();\n        }\n        return instance;\n    }\n}\n\n// 4. Double-checked Locking (Volatile required)\npublic class DoubleCheckedSingleton {\n    private static volatile DoubleCheckedSingleton instance;\n    \n    private DoubleCheckedSingleton() {}\n    \n    public static DoubleCheckedSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DoubleCheckedSingleton.class) {\n                if (instance == null) {\n                    instance = new DoubleCheckedSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n// 5. Bill Pugh Solution (Inner static class)\npublic class BillPughSingleton {\n    private BillPughSingleton() {}\n    \n    private static class SingletonHelper {\n        private static final BillPughSingleton INSTANCE = new BillPughSingleton();\n    }\n    \n    public static BillPughSingleton getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n}\n\n// 6. Enum Singleton (Best practice)\npublic enum EnumSingleton {\n    INSTANCE;\n    \n    public void doSomething() {\n        System.out.println(\"Enum singleton method\");\n    }\n}"
        },
        {
          "name": "✅ Observer Pattern Implementation",
          "text": "Custom observer pattern implementation with generics and thread safety.",
          "code": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\n// Generic Observer interface\npublic interface Observer<T> {\n    void update(T data);\n}\n\n// Generic Subject interface\npublic interface Subject<T> {\n    void addObserver(Observer<T> observer);\n    void removeObserver(Observer<T> observer);\n    void notifyObservers(T data);\n}\n\n// Thread-safe Observable implementation\npublic class ThreadSafeObservable<T> implements Subject<T> {\n    private final CopyOnWriteArrayList<Observer<T>> observers = new CopyOnWriteArrayList<>();\n    private final AtomicBoolean changed = new AtomicBoolean(false);\n    \n    @Override\n    public void addObserver(Observer<T> observer) {\n        if (observer != null && !observers.contains(observer)) {\n            observers.add(observer);\n        }\n    }\n    \n    @Override\n    public void removeObserver(Observer<T> observer) {\n        observers.remove(observer);\n    }\n    \n    @Override\n    public void notifyObservers(T data) {\n        if (changed.get()) {\n            for (Observer<T> observer : observers) {\n                observer.update(data);\n            }\n            changed.set(false);\n        }\n    }\n    \n    public void setChanged() {\n        changed.set(true);\n    }\n    \n    public void clearChanged() {\n        changed.set(false);\n    }\n}\n\n// Concrete implementation\npublic class NewsAgency extends ThreadSafeObservable<String> {\n    private String news;\n    \n    public void setNews(String news) {\n        this.news = news;\n        setChanged();\n        notifyObservers(news);\n    }\n    \n    public String getNews() {\n        return news;\n    }\n}\n\n// Concrete observers\npublic class NewsChannel implements Observer<String> {\n    private final String name;\n    \n    public NewsChannel(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void update(String news) {\n        System.out.println(name + \" received news: \" + news);\n    }\n}\n\n// Usage example\npublic class ObserverPatternDemo {\n    public static void main(String[] args) {\n        NewsAgency agency = new NewsAgency();\n        \n        Observer<String> channel1 = new NewsChannel(\"CNN\");\n        Observer<String> channel2 = new NewsChannel(\"BBC\");\n        Observer<String> channel3 = new NewsChannel(\"Fox News\");\n        \n        agency.addObserver(channel1);\n        agency.addObserver(channel2);\n        agency.addObserver(channel3);\n        \n        agency.setNews(\"Breaking: Java 21 released!\");\n        \n        agency.removeObserver(channel2);\n        agency.setNews(\"Update: Performance improvements confirmed\");\n    }\n}"
        },
        {
          "name": "✅ Factory Pattern Variations",
          "text": "Abstract Factory, Factory Method, and Builder patterns with practical examples.",
          "code": "// Abstract Factory Pattern\ninterface GUIFactory {\n    Button createButton();\n    Checkbox createCheckbox();\n}\n\nclass WindowsFactory implements GUIFactory {\n    @Override\n    public Button createButton() {\n        return new WindowsButton();\n    }\n    \n    @Override\n    public Checkbox createCheckbox() {\n        return new WindowsCheckbox();\n    }\n}\n\nclass MacFactory implements GUIFactory {\n    @Override\n    public Button createButton() {\n        return new MacButton();\n    }\n    \n    @Override\n    public Checkbox createCheckbox() {\n        return new MacCheckbox();\n    }\n}\n\n// Product interfaces\ninterface Button {\n    void render();\n}\n\ninterface Checkbox {\n    void render();\n}\n\n// Concrete products\nclass WindowsButton implements Button {\n    @Override\n    public void render() {\n        System.out.println(\"Windows Button rendered\");\n    }\n}\n\nclass MacButton implements Button {\n    @Override\n    public void render() {\n        System.out.println(\"Mac Button rendered\");\n    }\n}\n\n// Factory Method Pattern\nabstract class DocumentProcessor {\n    public void processDocument(String content) {\n        Document doc = createDocument(content);\n        doc.parse();\n        doc.validate();\n        doc.save();\n    }\n    \n    protected abstract Document createDocument(String content);\n}\n\nclass PDFProcessor extends DocumentProcessor {\n    @Override\n    protected Document createDocument(String content) {\n        return new PDFDocument(content);\n    }\n}\n\nclass WordProcessor extends DocumentProcessor {\n    @Override\n    protected Document createDocument(String content) {\n        return new WordDocument(content);\n    }\n}\n\n// Builder Pattern\npublic class Computer {\n    private final String cpu;\n    private final String ram;\n    private final String storage;\n    private final String gpu;\n    \n    private Computer(Builder builder) {\n        this.cpu = builder.cpu;\n        this.ram = builder.ram;\n        this.storage = builder.storage;\n        this.gpu = builder.gpu;\n    }\n    \n    public static class Builder {\n        private String cpu;\n        private String ram;\n        private String storage;\n        private String gpu;\n        \n        public Builder setCpu(String cpu) {\n            this.cpu = cpu;\n            return this;\n        }\n        \n        public Builder setRam(String ram) {\n            this.ram = ram;\n            return this;\n        }\n        \n        public Builder setStorage(String storage) {\n            this.storage = storage;\n            return this;\n        }\n        \n        public Builder setGpu(String gpu) {\n            this.gpu = gpu;\n            return this;\n        }\n        \n        public Computer build() {\n            return new Computer(this);\n        }\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"Computer{cpu='%s', ram='%s', storage='%s', gpu='%s'}\",\n                cpu, ram, storage, gpu);\n    }\n}\n\n// Usage examples\npublic class PatternDemo {\n    public static void main(String[] args) {\n        // Abstract Factory\n        GUIFactory factory = new WindowsFactory();\n        Button button = factory.createButton();\n        button.render();\n        \n        // Builder Pattern\n        Computer computer = new Computer.Builder()\n                .setCpu(\"Intel i7\")\n                .setRam(\"16GB\")\n                .setStorage(\"512GB SSD\")\n                .setGpu(\"RTX 3080\")\n                .build();\n        \n        System.out.println(computer);\n    }\n}"
        }
      ]
    },
    {
      "id": "performance-optimization",
      "title": "⚡ Performance Optimization",
      "sections": [
        {
          "name": "✅ JIT Compilation & Optimization",
          "text": "Understanding JIT compilation, hotspot optimizations, and performance tuning techniques.",
          "code": "// JIT Optimization Examples\n\n// 1. Method Inlining\npublic class InliningExample {\n    public int calculate(int a, int b) {\n        return add(a, b) * multiply(a, b);\n    }\n    \n    private int add(int a, int b) {\n        return a + b; // Will be inlined by JIT\n    }\n    \n    private int multiply(int a, int b) {\n        return a * b; // Will be inlined by JIT\n    }\n}\n\n// 2. Loop Unrolling\npublic class LoopUnrolling {\n    public int sumArray(int[] array) {\n        int sum = 0;\n        // JIT will unroll this loop for better performance\n        for (int i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n    \n    // Manual loop unrolling for critical sections\n    public int sumArrayUnrolled(int[] array) {\n        int sum = 0;\n        int i = 0;\n        \n        // Unroll by 4\n        for (; i < array.length - 3; i += 4) {\n            sum += array[i] + array[i + 1] + array[i + 2] + array[i + 3];\n        }\n        \n        // Handle remaining elements\n        for (; i < array.length; i++) {\n            sum += array[i];\n        }\n        \n        return sum;\n    }\n}\n\n// 3. Dead Code Elimination\npublic class DeadCodeElimination {\n    private static final boolean DEBUG = false;\n    \n    public void processData(String data) {\n        if (DEBUG) {\n            // This code will be eliminated by JIT when DEBUG is false\n            System.out.println(\"Debug: Processing \" + data);\n            logToFile(data);\n        }\n        \n        // Actual processing\n        performActualWork(data);\n    }\n    \n    private void logToFile(String data) {\n        // Debug logging code\n    }\n    \n    private void performActualWork(String data) {\n        // Real work\n    }\n}\n\n// 4. Branch Prediction Optimization\npublic class BranchPrediction {\n    // Good: Predictable branch pattern\n    public int processSortedArray(int[] sortedArray, int target) {\n        int count = 0;\n        for (int value : sortedArray) {\n            if (value < target) { // Predictable: mostly true\n                count++;\n            } else {\n                break; // Predictable: false when we hit target or higher\n            }\n        }\n        return count;\n    }\n    \n    // Bad: Unpredictable branch pattern\n    public int processRandomArray(int[] randomArray, int target) {\n        int count = 0;\n        for (int value : randomArray) {\n            if (value < target) { // Unpredictable: random true/false\n                count++;\n            }\n        }\n        return count;\n    }\n}"
        },
        {
          "name": "✅ Memory Access Patterns",
          "text": "Optimizing memory access patterns for better cache utilization and performance.",
          "code": "// Cache-friendly vs Cache-unfriendly patterns\n\n// 1. Sequential Access (Cache-friendly)\npublic class SequentialAccess {\n    public int sumMatrixSequential(int[][] matrix) {\n        int sum = 0;\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        \n        // Row-major order - cache friendly\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                sum += matrix[i][j];\n            }\n        }\n        return sum;\n    }\n}\n\n// 2. Random Access (Cache-unfriendly)\npublic class RandomAccess {\n    public int sumMatrixRandom(int[][] matrix) {\n        int sum = 0;\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        \n        // Column-major order - cache unfriendly\n        for (int j = 0; j < cols; j++) {\n            for (int i = 0; i < rows; i++) {\n                sum += matrix[i][j];\n            }\n        }\n        return sum;\n    }\n}\n\n// 3. Object Pool Pattern for Memory Efficiency\npublic class ObjectPool<T> {\n    private final Queue<T> pool;\n    private final Supplier<T> factory;\n    private final int maxSize;\n    \n    public ObjectPool(Supplier<T> factory, int maxSize) {\n        this.factory = factory;\n        this.maxSize = maxSize;\n        this.pool = new ConcurrentLinkedQueue<>();\n    }\n    \n    public T acquire() {\n        T obj = pool.poll();\n        if (obj == null) {\n            obj = factory.get();\n        }\n        return obj;\n    }\n    \n    public void release(T obj) {\n        if (pool.size() < maxSize) {\n            pool.offer(obj);\n        }\n    }\n}\n\n// 4. Memory-mapped Files for Large Data\nimport java.nio.*;\nimport java.nio.channels.*;\nimport java.io.*;\n\npublic class MemoryMappedFile {\n    private MappedByteBuffer buffer;\n    private FileChannel channel;\n    \n    public void mapFile(String filename) throws IOException {\n        RandomAccessFile file = new RandomAccessFile(filename, \"rw\");\n        channel = file.getChannel();\n        \n        // Map entire file to memory\n        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, channel.size());\n    }\n    \n    public void writeData(byte[] data, long position) {\n        buffer.position((int) position);\n        buffer.put(data);\n    }\n    \n    public byte[] readData(int size, long position) {\n        buffer.position((int) position);\n        byte[] data = new byte[size];\n        buffer.get(data);\n        return data;\n    }\n    \n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n}\n\n// 5. String Optimization\npublic class StringOptimization {\n    // Bad: String concatenation in loop\n    public String buildStringBad(String[] parts) {\n        String result = \"\";\n        for (String part : parts) {\n            result += part; // Creates new String object each time!\n        }\n        return result;\n    }\n    \n    // Good: StringBuilder\n    public String buildStringGood(String[] parts) {\n        StringBuilder sb = new StringBuilder();\n        for (String part : parts) {\n            sb.append(part);\n        }\n        return sb.toString();\n    }\n    \n    // Better: Pre-sized StringBuilder\n    public String buildStringBetter(String[] parts) {\n        int totalLength = 0;\n        for (String part : parts) {\n            totalLength += part.length();\n        }\n        \n        StringBuilder sb = new StringBuilder(totalLength);\n        for (String part : parts) {\n            sb.append(part);\n        }\n        return sb.toString();\n    }\n}"
        },
        {
          "name": "✅ Profiling & Benchmarking",
          "text": "Tools and techniques for profiling Java applications and measuring performance.",
          "code": "import java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicLong;\n\n// Custom benchmarking framework\npublic class Benchmark {\n    private final AtomicLong totalTime = new AtomicLong(0);\n    private final AtomicLong iterations = new AtomicLong(0);\n    \n    public void measure(String name, Runnable task) {\n        long startTime = System.nanoTime();\n        try {\n            task.run();\n        } finally {\n            long endTime = System.nanoTime();\n            long duration = endTime - startTime;\n            \n            totalTime.addAndGet(duration);\n            iterations.incrementAndGet();\n            \n            System.out.printf(\"%s: %d ns (%.2f ms)\\n\", \n                name, duration, duration / 1_000_000.0);\n        }\n    }\n    \n    public void measureAverage(String name, Runnable task, int iterations) {\n        long totalDuration = 0;\n        \n        // Warmup\n        for (int i = 0; i < 10; i++) {\n            task.run();\n        }\n        \n        // Actual measurement\n        for (int i = 0; i < iterations; i++) {\n            long startTime = System.nanoTime();\n            task.run();\n            long endTime = System.nanoTime();\n            totalDuration += (endTime - startTime);\n        }\n        \n        double averageNs = totalDuration / (double) iterations;\n        System.out.printf(\"%s (avg over %d iterations): %.2f ns (%.4f ms)\\n\", \n            name, iterations, averageNs, averageNs / 1_000_000.0);\n    }\n    \n    public void printStats() {\n        if (iterations.get() > 0) {\n            double avgTime = totalTime.get() / (double) iterations.get();\n            System.out.printf(\"Total iterations: %d, Average time: %.2f ns\\n\", \n                iterations.get(), avgTime);\n        }\n    }\n}\n\n// Performance comparison example\npublic class PerformanceComparison {\n    private static final int ARRAY_SIZE = 1000000;\n    private static final int[] testArray = new int[ARRAY_SIZE];\n    \n    static {\n        // Initialize test data\n        for (int i = 0; i < ARRAY_SIZE; i++) {\n            testArray[i] = i;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Benchmark benchmark = new Benchmark();\n        \n        // Compare different sum implementations\n        benchmark.measureAverage(\"Sequential Sum\", () -> {\n            int sum = 0;\n            for (int value : testArray) {\n                sum += value;\n            }\n            return sum;\n        }, 1000);\n        \n        benchmark.measureAverage(\"Parallel Stream Sum\", () -> {\n            return java.util.Arrays.stream(testArray).parallel().sum();\n        }, 1000);\n        \n        benchmark.measureAverage(\"Manual Parallel Sum\", () -> {\n            int processors = Runtime.getRuntime().availableProcessors();\n            int chunkSize = ARRAY_SIZE / processors;\n            \n            java.util.concurrent.Future<Integer>[] futures = new java.util.concurrent.Future[processors];\n            java.util.concurrent.ExecutorService executor = \n                java.util.concurrent.Executors.newFixedThreadPool(processors);\n            \n            for (int i = 0; i < processors; i++) {\n                final int start = i * chunkSize;\n                final int end = (i == processors - 1) ? ARRAY_SIZE : start + chunkSize;\n                \n                futures[i] = executor.submit(() -> {\n                    int sum = 0;\n                    for (int j = start; j < end; j++) {\n                        sum += testArray[j];\n                    }\n                    return sum;\n                });\n            }\n            \n            int totalSum = 0;\n            try {\n                for (java.util.concurrent.Future<Integer> future : futures) {\n                    totalSum += future.get();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                executor.shutdown();\n            }\n            \n            return totalSum;\n        }, 100);\n    }\n}\n\n// JVM Profiling flags\n/*\nCommon JVM flags for profiling:\n\n1. Memory profiling:\n   -XX:+HeapDumpOnOutOfMemoryError\n   -XX:HeapDumpPath=/path/to/dump\n   -XX:+PrintGCDetails\n   -XX:+PrintGCTimeStamps\n\n2. CPU profiling:\n   -XX:+UnlockDiagnosticVMOptions\n   -XX:+DebugNonSafepoints\n   -XX:+PreserveFramePointer\n\n3. JIT profiling:\n   -XX:+PrintCompilation\n   -XX:+PrintInlining\n   -XX:+TraceClassLoading\n\n4. Flight Recorder:\n   -XX:+FlightRecorder\n   -XX:StartFlightRecording=duration=60s,filename=profile.jfr\n*/"
        }
      ]
    },
    {
      "id": "functional-programming",
      "title": "🔧 Functional Programming in Java",
      "sections": [
        {
          "name": "✅ Advanced Stream Operations",
          "text": "Complex stream operations, custom collectors, and performance considerations.",
          "code": "import java.util.*;\nimport java.util.stream.*;\nimport java.util.function.*;\n\n// Custom Collector implementation\npublic class CustomCollectors {\n    \n    // Custom collector to find top N elements\n    public static <T extends Comparable<T>> Collector<T, ?, List<T>> topN(int n) {\n        return Collector.of(\n            () -> new PriorityQueue<>(n), // Supplier\n            (queue, item) -> { // Accumulator\n                if (queue.size() < n) {\n                    queue.offer(item);\n                } else if (queue.peek().compareTo(item) < 0) {\n                    queue.poll();\n                    queue.offer(item);\n                }\n            },\n            (queue1, queue2) -> { // Combiner\n                PriorityQueue<T> merged = new PriorityQueue<>(queue1);\n                queue2.forEach(merged::offer);\n                return merged;\n            },\n            queue -> queue.stream().sorted(Collections.reverseOrder()).collect(Collectors.toList()) // Finisher\n        );\n    }\n    \n    // Custom collector for grouping with custom key\n    public static <T, K> Collector<T, ?, Map<K, List<T>>> groupingByCustom(\n            Function<T, K> keyMapper, \n            Function<K, K> keyTransformer) {\n        return Collector.of(\n            HashMap::new, // Supplier\n            (map, item) -> { // Accumulator\n                K key = keyTransformer.apply(keyMapper.apply(item));\n                map.computeIfAbsent(key, k -> new ArrayList<>()).add(item);\n            },\n            (map1, map2) -> { // Combiner\n                map2.forEach((key, list) -> \n                    map1.merge(key, list, (list1, list2) -> {\n                        list1.addAll(list2);\n                        return list1;\n                    })\n                );\n                return map1;\n            },\n            Function.identity() // Finisher\n        );\n    }\n}\n\n// Advanced Stream Operations\npublic class AdvancedStreamOps {\n    \n    public static void main(String[] args) {\n        List<Person> people = Arrays.asList(\n            new Person(\"Alice\", 25, \"Engineer\"),\n            new Person(\"Bob\", 30, \"Manager\"),\n            new Person(\"Charlie\", 35, \"Engineer\"),\n            new Person(\"Diana\", 28, \"Designer\"),\n            new Person(\"Eve\", 32, \"Manager\")\n        );\n        \n        // 1. Complex grouping and aggregation\n        Map<String, Double> avgAgeByRole = people.stream()\n            .collect(Collectors.groupingBy(\n                Person::getRole,\n                Collectors.averagingInt(Person::getAge)\n            ));\n        \n        // 2. Custom collector usage\n        List<Person> top3Oldest = people.stream()\n            .collect(CustomCollectors.topN(3));\n        \n        // 3. Parallel stream with custom thread pool\n        ForkJoinPool customThreadPool = new ForkJoinPool(4);\n        try {\n            List<String> processedNames = customThreadPool.submit(() ->\n                people.parallelStream()\n                    .map(Person::getName)\n                    .map(String::toUpperCase)\n                    .collect(Collectors.toList())\n            ).get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        \n        // 4. Stream with custom spliterator\n        List<Integer> numbers = IntStream.range(0, 1000000)\n            .boxed()\n            .collect(Collectors.toList());\n        \n        // Custom spliterator for chunked processing\n        Spliterator<Integer> spliterator = numbers.spliterator();\n        List<List<Integer>> chunks = new ArrayList<>();\n        \n        while (spliterator.tryAdvance(item -> {\n            List<Integer> chunk = new ArrayList<>();\n            chunk.add(item);\n            \n            // Try to get more items for this chunk\n            for (int i = 0; i < 999 && spliterator.tryAdvance(chunk::add); i++) {\n                // Collect up to 1000 items per chunk\n            }\n            \n            chunks.add(chunk);\n        })) {\n            // Process chunks\n        }\n        \n        // 5. Stream with exception handling\n        List<String> fileNames = Arrays.asList(\"file1.txt\", \"file2.txt\", \"invalid.txt\");\n        \n        List<String> validContents = fileNames.stream()\n            .map(fileName -> {\n                try {\n                    return Files.readString(Paths.get(fileName));\n                } catch (IOException e) {\n                    return null; // Handle exception\n                }\n            })\n            .filter(Objects::nonNull)\n            .collect(Collectors.toList());\n    }\n}\n\n// Functional composition and currying\npublic class FunctionalComposition {\n    \n    // Function composition\n    public static <T, U, V> Function<T, V> compose(Function<U, V> f, Function<T, U> g) {\n        return x -> f.apply(g.apply(x));\n    }\n    \n    // Currying example\n    public static Function<Integer, Function<Integer, Integer>> add() {\n        return x -> y -> x + y;\n    }\n    \n    // Partial application\n    public static Function<Integer, Integer> add5() {\n        return add().apply(5);\n    }\n    \n    // Memoization\n    public static <T, R> Function<T, R> memoize(Function<T, R> function) {\n        Map<T, R> cache = new ConcurrentHashMap<>();\n        return input -> cache.computeIfAbsent(input, function);\n    }\n    \n    // Usage example\n    public static void main(String[] args) {\n        // Function composition\n        Function<String, Integer> stringLength = String::length;\n        Function<Integer, String> intToString = String::valueOf;\n        Function<String, String> composed = compose(intToString, stringLength);\n        \n        System.out.println(composed.apply(\"Hello\")); // \"5\"\n        \n        // Currying\n        Function<Integer, Integer> add5 = add5();\n        System.out.println(add5.apply(3)); // 8\n        \n        // Memoization\n        Function<Integer, Integer> expensiveFunction = memoize(n -> {\n            // Simulate expensive computation\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            return n * n;\n        });\n        \n        // First call takes time\n        long start = System.currentTimeMillis();\n        expensiveFunction.apply(5);\n        long firstCall = System.currentTimeMillis() - start;\n        \n        // Second call is instant (cached)\n        start = System.currentTimeMillis();\n        expensiveFunction.apply(5);\n        long secondCall = System.currentTimeMillis() - start;\n        \n        System.out.println(\"First call: \" + firstCall + \"ms\");\n        System.out.println(\"Second call: \" + secondCall + \"ms\");\n    }\n}\n\n// Person class for examples\nclass Person {\n    private final String name;\n    private final int age;\n    private final String role;\n    \n    public Person(String name, int age, String role) {\n        this.name = name;\n        this.age = age;\n        this.role = role;\n    }\n    \n    public String getName() { return name; }\n    public int getAge() { return age; }\n    public String getRole() { return role; }\n}"
        },
        {
          "name": "✅ Reactive Programming with CompletableFuture",
          "text": "Advanced asynchronous programming patterns using CompletableFuture and reactive streams.",
          "code": "import java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.stream.*;\n\n// Advanced CompletableFuture patterns\npublic class ReactiveProgramming {\n    \n    // Async service simulation\n    public static class UserService {\n        public CompletableFuture<User> getUserById(int id) {\n            return CompletableFuture.supplyAsync(() -> {\n                try {\n                    Thread.sleep(100); // Simulate network call\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n                return new User(id, \"User\" + id);\n            });\n        }\n    }\n    \n    public static class OrderService {\n        public CompletableFuture<List<Order>> getOrdersByUserId(int userId) {\n            return CompletableFuture.supplyAsync(() -> {\n                try {\n                    Thread.sleep(150); // Simulate network call\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n                return IntStream.range(1, 4)\n                    .mapToObj(i -> new Order(i, userId, \"Order\" + i))\n                    .collect(Collectors.toList());\n            });\n        }\n    }\n    \n    public static class PaymentService {\n        public CompletableFuture<Payment> processPayment(int orderId, double amount) {\n            return CompletableFuture.supplyAsync(() -> {\n                try {\n                    Thread.sleep(200); // Simulate payment processing\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n                return new Payment(orderId, amount, \"SUCCESS\");\n            });\n        }\n    }\n    \n    // Complex async orchestration\n    public CompletableFuture<OrderSummary> processOrder(int userId, double amount) {\n        UserService userService = new UserService();\n        OrderService orderService = new OrderService();\n        PaymentService paymentService = new PaymentService();\n        \n        return userService.getUserById(userId)\n            .thenCompose(user -> {\n                // Get user orders\n                CompletableFuture<List<Order>> ordersFuture = orderService.getOrdersByUserId(userId);\n                \n                // Process payment for each order\n                return ordersFuture.thenCompose(orders -> {\n                    List<CompletableFuture<Payment>> paymentFutures = orders.stream()\n                        .map(order -> paymentService.processPayment(order.getId(), amount))\n                        .collect(Collectors.toList());\n                    \n                    // Wait for all payments to complete\n                    CompletableFuture<List<Payment>> allPayments = CompletableFuture\n                        .allOf(paymentFutures.toArray(new CompletableFuture[0]))\n                        .thenApply(v -> paymentFutures.stream()\n                            .map(CompletableFuture::join)\n                            .collect(Collectors.toList()));\n                    \n                    return allPayments.thenApply(payments -> \n                        new OrderSummary(user, orders, payments));\n                });\n            })\n            .exceptionally(throwable -> {\n                System.err.println(\"Error processing order: \" + throwable.getMessage());\n                return null;\n            });\n    }\n    \n    // Timeout and fallback patterns\n    public CompletableFuture<String> getDataWithTimeout(String source, int timeoutMs) {\n        CompletableFuture<String> dataFuture = CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(timeoutMs + 100); // Simulate slow operation\n                return \"Data from \" + source;\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(e);\n            }\n        });\n        \n        CompletableFuture<String> timeoutFuture = CompletableFuture\n            .supplyAsync(() -> {\n                try {\n                    Thread.sleep(timeoutMs);\n                    return \"TIMEOUT\";\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(e);\n                }\n            });\n        \n        return dataFuture.applyToEither(timeoutFuture, Function.identity())\n            .exceptionally(throwable -> \"FALLBACK_DATA\");\n    }\n    \n    // Circuit breaker pattern\n    public static class CircuitBreaker {\n        private final int failureThreshold;\n        private final long timeoutMs;\n        private int failureCount = 0;\n        private long lastFailureTime = 0;\n        private State state = State.CLOSED;\n        \n        private enum State { CLOSED, OPEN, HALF_OPEN }\n        \n        public CircuitBreaker(int failureThreshold, long timeoutMs) {\n            this.failureThreshold = failureThreshold;\n            this.timeoutMs = timeoutMs;\n        }\n        \n        public <T> CompletableFuture<T> execute(Supplier<CompletableFuture<T>> operation) {\n            if (state == State.OPEN) {\n                if (System.currentTimeMillis() - lastFailureTime > timeoutMs) {\n                    state = State.HALF_OPEN;\n                } else {\n                    return CompletableFuture.failedFuture(\n                        new RuntimeException(\"Circuit breaker is OPEN\"));\n                }\n            }\n            \n            return operation.get()\n                .whenComplete((result, throwable) -> {\n                    if (throwable != null) {\n                        handleFailure();\n                    } else {\n                        handleSuccess();\n                    }\n                });\n        }\n        \n        private void handleFailure() {\n            failureCount++;\n            lastFailureTime = System.currentTimeMillis();\n            \n            if (failureCount >= failureThreshold) {\n                state = State.OPEN;\n            }\n        }\n        \n        private void handleSuccess() {\n            failureCount = 0;\n            state = State.CLOSED;\n        }\n    }\n    \n    public static void main(String[] args) {\n        ReactiveProgramming app = new ReactiveProgramming();\n        \n        // Process order example\n        app.processOrder(1, 100.0)\n            .thenAccept(summary -> {\n                System.out.println(\"Order processed successfully:\");\n                System.out.println(\"User: \" + summary.getUser().getName());\n                System.out.println(\"Orders: \" + summary.getOrders().size());\n                System.out.println(\"Payments: \" + summary.getPayments().size());\n            })\n            .join();\n        \n        // Timeout example\n        app.getDataWithTimeout(\"slow-service\", 1000)\n            .thenAccept(System.out::println)\n            .join();\n        \n        // Circuit breaker example\n        CircuitBreaker circuitBreaker = new CircuitBreaker(3, 5000);\n        \n        for (int i = 0; i < 5; i++) {\n            circuitBreaker.execute(() -> {\n                if (i < 3) {\n                    return CompletableFuture.failedFuture(new RuntimeException(\"Service error\"));\n                } else {\n                    return CompletableFuture.completedFuture(\"Success!\");\n                }\n            }).thenAccept(System.out::println)\n              .exceptionally(throwable -> {\n                  System.out.println(\"Failed: \" + throwable.getMessage());\n                  return null;\n              });\n        }\n    }\n}\n\n// Data classes\nclass User {\n    private final int id;\n    private final String name;\n    \n    public User(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n    \n    public int getId() { return id; }\n    public String getName() { return name; }\n}\n\nclass Order {\n    private final int id;\n    private final int userId;\n    private final String description;\n    \n    public Order(int id, int userId, String description) {\n        this.id = id;\n        this.userId = userId;\n        this.description = description;\n    }\n    \n    public int getId() { return id; }\n    public int getUserId() { return userId; }\n    public String getDescription() { return description; }\n}\n\nclass Payment {\n    private final int orderId;\n    private final double amount;\n    private final String status;\n    \n    public Payment(int orderId, double amount, String status) {\n        this.orderId = orderId;\n        this.amount = amount;\n        this.status = status;\n    }\n    \n    public int getOrderId() { return orderId; }\n    public double getAmount() { return amount; }\n    public String getStatus() { return status; }\n}\n\nclass OrderSummary {\n    private final User user;\n    private final List<Order> orders;\n    private final List<Payment> payments;\n    \n    public OrderSummary(User user, List<Order> orders, List<Payment> payments) {\n        this.user = user;\n        this.orders = orders;\n        this.payments = payments;\n    }\n    \n    public User getUser() { return user; }\n    public List<Order> getOrders() { return orders; }\n    public List<Payment> getPayments() { return payments; }\n}"
        }
      ]
    },
    {
      "id": "jvm-internals",
      "title": "🔍 JVM Internals & Bytecode",
      "sections": [
        {
          "name": "✅ Bytecode Analysis",
          "text": "Understanding Java bytecode, JVM instructions, and how to analyze compiled code.",
          "code": "// Bytecode analysis examples\n\n// 1. Simple method bytecode\npublic class BytecodeExample {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public int multiply(int a, int b) {\n        return a * b;\n    }\n    \n    public void loop() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(i);\n        }\n    }\n}\n\n/*\nBytecode for add(int a, int b):\n0: iload_1        // Load first parameter\n1: iload_2        // Load second parameter\n2: iadd           // Add them\n3: ireturn        // Return result\n\nBytecode for multiply(int a, int b):\n0: iload_1        // Load first parameter\n1: iload_2        // Load second parameter\n2: imul           // Multiply them\n3: ireturn        // Return result\n\nBytecode for loop():\n0: iconst_0       // Push 0\n1: istore_1       // Store in local variable 1 (i)\n2: iload_1        // Load i\n3: bipush 10      // Push 10\n5: if_icmpge 19   // Compare and branch if i >= 10\n8: getstatic #2   // Get System.out\n11: iload_1       // Load i\n12: invokevirtual #3 // Call println\n15: iinc 1, 1     // Increment i by 1\n18: goto 2        // Jump back to condition\n19: return        // Return\n*/\n\n// 2. String concatenation bytecode\npublic class StringConcat {\n    public String concat(String a, String b) {\n        return a + b;\n    }\n    \n    public String concatWithBuilder(String a, String b) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(a);\n        sb.append(b);\n        return sb.toString();\n    }\n}\n\n/*\nBytecode for concat(String a, String b):\n0: new #2         // Create StringBuilder\n3: dup            // Duplicate reference\n4: invokespecial #3 // Call StringBuilder constructor\n7: aload_1        // Load first string\n8: invokevirtual #4 // Call append\n11: aload_2       // Load second string\n12: invokevirtual #4 // Call append\n15: invokevirtual #5 // Call toString\n18: areturn       // Return result\n\nThis shows that string concatenation with + is compiled to StringBuilder operations!\n*/\n\n// 3. Exception handling bytecode\npublic class ExceptionHandling {\n    public void tryCatch() {\n        try {\n            riskyOperation();\n        } catch (RuntimeException e) {\n            handleException(e);\n        } finally {\n            cleanup();\n        }\n    }\n    \n    private void riskyOperation() {\n        throw new RuntimeException(\"Something went wrong\");\n    }\n    \n    private void handleException(RuntimeException e) {\n        System.out.println(\"Handled: \" + e.getMessage());\n    }\n    \n    private void cleanup() {\n        System.out.println(\"Cleanup\");\n    }\n}\n\n/*\nBytecode for tryCatch():\n0: aload_0        // Load this\n1: invokespecial #2 // Call riskyOperation\n4: aload_0        // Load this\n5: invokespecial #3 // Call cleanup\n8: goto 20       // Jump to end\n11: astore_1     // Store exception\n12: aload_0      // Load this\n13: aload_1      // Load exception\n14: invokespecial #4 // Call handleException\n17: aload_0      // Load this\n18: invokespecial #3 // Call cleanup\n21: goto 20      // Jump to end\n24: astore_2     // Store any exception from finally\n25: aload_0      // Load this\n26: invokespecial #3 // Call cleanup\n29: aload_2      // Load stored exception\n30: athrow       // Re-throw exception\n31: return       // Normal return\n\nException table:\nfrom to target type\n0    4   11   java/lang/RuntimeException\n0    4   24   any\n11   17  24   any\n*/\n\n// 4. Method invocation bytecode\npublic class MethodInvocation {\n    public void instanceMethod() {\n        this.toString();\n    }\n    \n    public static void staticMethod() {\n        System.out.println(\"Static method\");\n    }\n    \n    public void interfaceMethod() {\n        Runnable r = () -> System.out.println(\"Lambda\");\n        r.run();\n    }\n}\n\n/*\nBytecode for instanceMethod():\n0: aload_0       // Load this\n1: invokevirtual #2 // Call toString()\n4: pop           // Discard result\n5: return        // Return\n\nBytecode for staticMethod():\n0: getstatic #2  // Get System.out\n3: ldc #3        // Load string constant\n5: invokevirtual #4 // Call println\n8: return        // Return\n\nBytecode for interfaceMethod():\n0: invokedynamic #2 // Invoke dynamic (lambda)\n5: astore_1      // Store in local variable\n6: aload_1       // Load lambda\n7: invokeinterface #3 // Call run()\n12: return       // Return\n*/\n\n// 5. Class loading and initialization\npublic class ClassLoadingExample {\n    static {\n        System.out.println(\"Static initializer\");\n    }\n    \n    {\n        System.out.println(\"Instance initializer\");\n    }\n    \n    public ClassLoadingExample() {\n        System.out.println(\"Constructor\");\n    }\n}\n\n/*\nClass loading process:\n1. Loading: Load .class file into memory\n2. Linking: Verify, prepare, resolve\n3. Initialization: Execute static initializers\n\nWhen creating instance:\n1. Allocate memory\n2. Initialize instance variables\n3. Execute instance initializers\n4. Execute constructor\n*/\n\n// Tools for bytecode analysis:\n/*\n1. javap -c ClassName          // Disassemble bytecode\n2. javap -v ClassName          // Verbose output with constant pool\n3. javap -p ClassName          // Show private members\n4. ASM library                 // Programmatic bytecode manipulation\n5. JProfiler                   // Profiling with bytecode view\n6. VisualVM                    // JVM monitoring\n7. JConsole                    // JMX monitoring\n*/\n\n// Bytecode manipulation with ASM\nimport org.objectweb.asm.*;\n\npublic class BytecodeManipulation {\n    \n    public static class MethodProfiler extends ClassVisitor {\n        public MethodProfiler(ClassVisitor cv) {\n            super(Opcodes.ASM9, cv);\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String descriptor, \n                                       String signature, String[] exceptions) {\n            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n            \n            if (!name.equals(\"<init>\") && !name.equals(\"<clinit>\")) {\n                return new MethodProfilerAdapter(mv, name);\n            }\n            \n            return mv;\n        }\n    }\n    \n    public static class MethodProfilerAdapter extends MethodVisitor {\n        private final String methodName;\n        \n        public MethodProfilerAdapter(MethodVisitor mv, String methodName) {\n            super(Opcodes.ASM9, mv);\n            this.methodName = methodName;\n        }\n        \n        @Override\n        public void visitCode() {\n            // Add timing start\n            mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/System\", \"out\", \n                            \"Ljava/io/PrintStream;\");\n            mv.visitLdcInsn(\"Starting \" + methodName);\n            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/io/PrintStream\", \n                            \"println\", \"(Ljava/lang/String;)V\", false);\n            \n            super.visitCode();\n        }\n        \n        @Override\n        public void visitInsn(int opcode) {\n            if (opcode == Opcodes.RETURN || opcode == Opcodes.IRETURN || \n                opcode == Opcodes.ARETURN || opcode == Opcodes.LRETURN || \n                opcode == Opcodes.DRETURN || opcode == Opcodes.FRETURN) {\n                \n                // Add timing end\n                mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/System\", \"out\", \n                                \"Ljava/io/PrintStream;\");\n                mv.visitLdcInsn(\"Ending \" + methodName);\n                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/io/PrintStream\", \n                                \"println\", \"(Ljava/lang/String;)V\", false);\n            }\n            \n            super.visitInsn(opcode);\n        }\n    }\n}"
        },
        {
          "name": "✅ Class Loading & Reflection",
          "text": "Deep dive into class loading mechanisms, reflection API, and dynamic class loading.",
          "code": "import java.lang.reflect.*;\nimport java.net.*;\nimport java.io.*;\n\n// Custom ClassLoader implementation\npublic class CustomClassLoader extends ClassLoader {\n    private final String classPath;\n    \n    public CustomClassLoader(String classPath) {\n        this.classPath = classPath;\n    }\n    \n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        try {\n            byte[] classBytes = loadClassBytes(name);\n            return defineClass(name, classBytes, 0, classBytes.length);\n        } catch (IOException e) {\n            throw new ClassNotFoundException(\"Could not load class \" + name, e);\n        }\n    }\n    \n    private byte[] loadClassBytes(String className) throws IOException {\n        String fileName = className.replace('.', '/') + \".class\";\n        String fullPath = classPath + \"/\" + fileName;\n        \n        try (FileInputStream fis = new FileInputStream(fullPath);\n             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n            \n            return baos.toByteArray();\n        }\n    }\n}\n\n// Advanced Reflection Examples\npublic class AdvancedReflection {\n    \n    // Dynamic method invocation with caching\n    private static final Map<String, Method> methodCache = new ConcurrentHashMap<>();\n    \n    public static Object invokeMethod(Object target, String methodName, Object... args) {\n        try {\n            String cacheKey = target.getClass().getName() + \".\" + methodName;\n            Method method = methodCache.computeIfAbsent(cacheKey, key -> {\n                try {\n                    Class<?>[] paramTypes = new Class[args.length];\n                    for (int i = 0; i < args.length; i++) {\n                        paramTypes[i] = args[i].getClass();\n                    }\n                    return target.getClass().getMethod(methodName, paramTypes);\n                } catch (NoSuchMethodException e) {\n                    throw new RuntimeException(e);\n                }\n            });\n            \n            return method.invoke(target, args);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to invoke method \" + methodName, e);\n        }\n    }\n    \n    // Generic type erasure and reification\n    public static class TypeToken<T> {\n        private final Type type;\n        \n        protected TypeToken() {\n            this.type = ((ParameterizedType) getClass().getGenericSuperclass())\n                .getActualTypeArguments()[0];\n        }\n        \n        public Type getType() {\n            return type;\n        }\n        \n        public Class<T> getRawType() {\n            return (Class<T>) getRawType(type);\n        }\n        \n        private Class<?> getRawType(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            } else if (type instanceof ParameterizedType) {\n                return getRawType(((ParameterizedType) type).getRawType());\n            } else if (type instanceof GenericArrayType) {\n                return Array.newInstance(getRawType(((GenericArrayType) type).getGenericComponentType()), 0).getClass();\n            }\n            return Object.class;\n        }\n    }\n    \n    // Dynamic proxy for interface implementation\n    public static <T> T createProxy(Class<T> interfaceClass, InvocationHandler handler) {\n        return (T) Proxy.newProxyInstance(\n            interfaceClass.getClassLoader(),\n            new Class[]{interfaceClass},\n            handler\n        );\n    }\n    \n    // Method interceptor using dynamic proxy\n    public static class MethodInterceptor implements InvocationHandler {\n        private final Object target;\n        private final Map<String, Method> beforeMethods = new HashMap<>();\n        private final Map<String, Method> afterMethods = new HashMap<>();\n        \n        public MethodInterceptor(Object target) {\n            this.target = target;\n        }\n        \n        public MethodInterceptor addBefore(String methodName, Method beforeMethod) {\n            beforeMethods.put(methodName, beforeMethod);\n            return this;\n        }\n        \n        public MethodInterceptor addAfter(String methodName, Method afterMethod) {\n            afterMethods.put(methodName, afterMethod);\n            return this;\n        }\n        \n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            String methodName = method.getName();\n            \n            // Execute before method\n            if (beforeMethods.containsKey(methodName)) {\n                beforeMethods.get(methodName).invoke(null);\n            }\n            \n            // Execute target method\n            Object result = method.invoke(target, args);\n            \n            // Execute after method\n            if (afterMethods.containsKey(methodName)) {\n                afterMethods.get(methodName).invoke(null);\n            }\n            \n            return result;\n        }\n    }\n    \n    // Annotation processing at runtime\n    public static class AnnotationProcessor {\n        public static void processAnnotations(Class<?> clazz) {\n            // Process class-level annotations\n            for (Annotation annotation : clazz.getAnnotations()) {\n                System.out.println(\"Class annotation: \" + annotation.annotationType().getSimpleName());\n            }\n            \n            // Process method annotations\n            for (Method method : clazz.getDeclaredMethods()) {\n                for (Annotation annotation : method.getAnnotations()) {\n                    System.out.println(\"Method \" + method.getName() + \" has annotation: \" + \n                        annotation.annotationType().getSimpleName());\n                }\n            }\n            \n            // Process field annotations\n            for (Field field : clazz.getDeclaredFields()) {\n                for (Annotation annotation : field.getAnnotations()) {\n                    System.out.println(\"Field \" + field.getName() + \" has annotation: \" + \n                        annotation.annotationType().getSimpleName());\n                }\n            }\n        }\n    }\n    \n    // Custom annotation for method timing\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    public @interface Timed {\n        String value() default \"\";\n    }\n    \n    // Method timing using reflection\n    public static class MethodTimer {\n        public static void timeMethods(Object target) {\n            Class<?> clazz = target.getClass();\n            \n            for (Method method : clazz.getDeclaredMethods()) {\n                if (method.isAnnotationPresent(Timed.class)) {\n                    Timed annotation = method.getAnnotation(Timed.class);\n                    String timerName = annotation.value().isEmpty() ? \n                        method.getName() : annotation.value();\n                    \n                    try {\n                        long startTime = System.nanoTime();\n                        method.invoke(target);\n                        long endTime = System.nanoTime();\n                        \n                        System.out.printf(\"%s took %d ns (%.2f ms)\\n\", \n                            timerName, endTime - startTime, (endTime - startTime) / 1_000_000.0);\n                    } catch (Exception e) {\n                        System.err.println(\"Error timing method \" + method.getName() + \": \" + e.getMessage());\n                    }\n                }\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Type token example\n        TypeToken<List<String>> stringListToken = new TypeToken<List<String>>() {};\n        System.out.println(\"Type: \" + stringListToken.getType());\n        System.out.println(\"Raw type: \" + stringListToken.getRawType());\n        \n        // Dynamic proxy example\n        List<String> proxyList = createProxy(List.class, (proxy, method, args1) -> {\n            System.out.println(\"Intercepted call to \" + method.getName());\n            return method.invoke(new ArrayList<>(), args1);\n        });\n        \n        proxyList.add(\"Hello\");\n        System.out.println(\"Size: \" + proxyList.size());\n        \n        // Method interceptor example\n        List<String> originalList = new ArrayList<>();\n        MethodInterceptor interceptor = new MethodInterceptor(originalList)\n            .addBefore(\"add\", String.class.getMethod(\"valueOf\", int.class))\n            .addAfter(\"add\", String.class.getMethod(\"valueOf\", int.class));\n        \n        List<String> interceptedList = createProxy(List.class, interceptor);\n        interceptedList.add(\"Test\");\n    }\n}\n\n// Example class for annotation processing\nclass ExampleClass {\n    @Timed(\"initialization\")\n    public void initialize() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n    \n    @Timed\n    public void process() {\n        try {\n            Thread.sleep(50);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}"
        }
      ]
    }
  ]
}
