{
  "config": {
    "id": "java-advanced",
    "name": "Java Advanced",
    "description": "Advanced Java Concepts - Complete Enhanced Guide",
    "icon": "üéØ",
    "enabled": true
  },
  "content": [
    {
      "id": "memory-management",
      "title": "üß† Memory Management & JVM",
      "sections": [
        {
          "name": "‚úÖ Heap Memory Structure",
          "text": "**Usage:** Understanding JVM heap memory layout is crucial for diagnosing memory issues, tuning application performance, and preventing OutOfMemoryErrors.\n\n**Gains:**\n‚Ä¢ **30-50% Reduction in GC Pause Times:** With proper heap tuning\n‚Ä¢ **20-40% Memory Efficiency:** Better object allocation strategies\n‚Ä¢ **Prevent OOM Errors:** Avoid application crashes from memory exhaustion\n‚Ä¢ **Predictable Performance:** Eliminate unexpected pauses under load\n‚Ä¢ **Cost Savings:** Reduce infrastructure costs with efficient memory usage\n\n**Key Concepts:**\n‚Ä¢ **Young Generation (33% of heap):** Short-lived objects (90%+ die here)\n  - Eden Space: 80% of Young Gen - new object allocation\n  - Survivor Spaces (S0/S1): 10% each - objects surviving GC\n‚Ä¢ **Old Generation (67% of heap):** Long-lived objects promoted from Young\n‚Ä¢ **Metaspace (Java 8+):** Class metadata in native memory\n\n**When to Tune:**\n‚Ä¢ GC consuming >5-10% of CPU time\n‚Ä¢ Pause times exceeding 1 second\n‚Ä¢ Frequent OutOfMemoryError\n‚Ä¢ Excessive promotion to Old Generation",
          "code": "import java.lang.management.*;\n\npublic class MemoryAnalysis {\n    private static final int MB = 1024 * 1024;\n    \n    public static void analyzeMemory() {\n        Runtime runtime = Runtime.getRuntime();\n        \n        // Basic memory info\n        long maxMemory = runtime.maxMemory();     // -Xmx value\n        long totalMemory = runtime.totalMemory(); // Current heap\n        long freeMemory = runtime.freeMemory();   // Free in current\n        long usedMemory = totalMemory - freeMemory;\n        \n        System.out.printf(\"Max Memory (Xmx): %d MB%n\", maxMemory / MB);\n        System.out.printf(\"Total Memory: %d MB%n\", totalMemory / MB);\n        System.out.printf(\"Used Memory: %d MB%n\", usedMemory / MB);\n        System.out.printf(\"Free Memory: %d MB%n\", freeMemory / MB);\n        \n        // Detailed memory pools\n        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();\n        \n        System.out.println(\"\\n=== Heap Memory ===\");\n        printMemoryUsage(memoryBean.getHeapMemoryUsage());\n        \n        System.out.println(\"\\n=== Non-Heap (Metaspace) ===\");\n        printMemoryUsage(memoryBean.getNonHeapMemoryUsage());\n        \n        // Individual pools\n        System.out.println(\"\\n=== Memory Pools ===\");\n        for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {\n            System.out.println(\"\\nPool: \" + pool.getName());\n            System.out.println(\"Type: \" + pool.getType());\n            printMemoryUsage(pool.getUsage());\n        }\n    }\n    \n    private static void printMemoryUsage(MemoryUsage usage) {\n        System.out.printf(\"  Init: %d MB%n\", usage.getInit() / MB);\n        System.out.printf(\"  Used: %d MB%n\", usage.getUsed() / MB);\n        System.out.printf(\"  Committed: %d MB%n\", usage.getCommitted() / MB);\n        System.out.printf(\"  Max: %d MB%n\", usage.getMax() / MB);\n    }\n}\n\n// JVM Memory Tuning Flags:\n/*\n=== Basic Heap Settings ===\n-Xms2g                    // Initial heap: 2GB\n-Xmx4g                    // Maximum heap: 4GB\n-XX:+AlwaysPreTouch       // Touch all memory at startup\n\n=== Young Generation ===\n-XX:NewSize=512m          // Initial Young Gen\n-XX:MaxNewSize=1g         // Max Young Gen\n-XX:NewRatio=2            // Old/Young ratio (Old = 2x Young)\n-XX:SurvivorRatio=8       // Eden/Survivor ratio (Eden = 8x Survivor)\n\n=== Metaspace (Java 8+) ===\n-XX:MetaspaceSize=256m    // Initial metaspace\n-XX:MaxMetaspaceSize=512m // Max metaspace\n\n=== Memory Diagnostics ===\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/logs/heapdump.hprof\n-XX:+PrintGCDetails\n-XX:+PrintGCTimeStamps\n*/"
        },
        {
          "name": "‚úÖ Garbage Collection Algorithms",
          "text": "**Usage:** Choose the right GC algorithm based on application requirements: throughput vs latency, heap size, and pause time tolerance.\n\n**Gains:**\n‚Ä¢ **G1 GC:** Balanced performance, 4-32GB heaps, ~200ms pause target, 90% throughput\n‚Ä¢ **ZGC:** Ultra-low latency <10ms pauses, TB+ heaps, 85% throughput, 10-15% overhead\n‚Ä¢ **Shenandoah:** Low latency <10ms, 10-100GB heaps, concurrent evacuation\n‚Ä¢ **Parallel GC:** Maximum throughput 100%, multi-second pauses acceptable\n‚Ä¢ **Serial GC:** Small heaps <256MB, single-threaded, minimal overhead\n\n**Performance Impact:**\n```\nScenario: 8GB heap, mixed workload\nParallel GC:  Throughput: 100%, Pause: 2000ms\nG1 GC:        Throughput: 90%,  Pause: 200ms\nZGC:          Throughput: 85%,  Pause: 5ms\n```\n\n**Decision Matrix:**\n‚Ä¢ **General purpose / Unknown:** G1 GC (Java 9+ default)\n‚Ä¢ **Low latency critical (<10ms):** ZGC (Java 15+) or Shenandoah\n‚Ä¢ **Massive heaps (>100GB):** ZGC\n‚Ä¢ **Batch processing:** Parallel GC\n‚Ä¢ **Containers (<256MB):** Serial GC\n\n**Cost Trade-offs:**\n‚Ä¢ ZGC: 10-15% CPU overhead, 10-20% more memory for performance",
          "code": "import java.lang.management.*;\nimport java.util.*;\n\npublic class GCAnalysis {\n    \n    public static void monitorGC() {\n        for (GarbageCollectorMXBean gc : \n             ManagementFactory.getGarbageCollectorMXBeans()) {\n            \n            System.out.println(\"\\n=== GC: \" + gc.getName() + \" ===\");\n            System.out.println(\"Collection count: \" + gc.getCollectionCount());\n            System.out.println(\"Collection time: \" + gc.getCollectionTime() + \"ms\");\n            System.out.println(\"Memory pools: \" + \n                Arrays.toString(gc.getMemoryPoolNames()));\n            \n            // Calculate GC overhead\n            long totalTime = ManagementFactory.getRuntimeMXBean().getUptime();\n            double gcOverhead = (gc.getCollectionTime() * 100.0) / totalTime;\n            System.out.printf(\"GC Overhead: %.2f%%%n\", gcOverhead);\n            \n            if (gcOverhead > 10) {\n                System.out.println(\"‚ö†Ô∏è  WARNING: GC overhead exceeds 10%!\");\n            }\n        }\n    }\n    \n    // Create GC pressure for testing\n    public static void createGCPressure() {\n        List<byte[]> data = new ArrayList<>();\n        \n        for (int i = 0; i < 100; i++) {\n            data.add(new byte[1024 * 1024]); // 1MB\n            \n            // Release some objects\n            if (i % 10 == 0) {\n                data.subList(0, data.size() / 2).clear();\n            }\n        }\n    }\n}\n\n// === G1 GC Configuration (Recommended) ===\n/*\n-XX:+UseG1GC                           // Enable G1\n-XX:MaxGCPauseMillis=200               // Target pause: 200ms\n-XX:G1HeapRegionSize=16m               // Region size: 1-32MB\n-XX:InitiatingHeapOccupancyPercent=45  // Concurrent marking threshold\n-XX:G1ReservePercent=10                // Reserve for to-space\n-XX:+ParallelRefProcEnabled            // Parallel reference processing\n\n// G1 Logging\n-Xlog:gc*:file=gc.log:time,level,tags\n*/\n\n// === ZGC Configuration (Ultra-low latency) ===\n/*\n-XX:+UseZGC                    // Enable ZGC (Java 15+)\n-XX:ZCollectionInterval=5      // GC interval: 5 seconds\n-XX:ZAllocationSpikeTolerance=2 // Handle allocation spikes\n-XX:SoftMaxHeapSize=4g         // Soft heap limit\n-XX:ConcGCThreads=4            // Concurrent GC threads\n\n// ZGC Logging\n-Xlog:gc*:file=zgc.log:time,level,tags\n*/\n\n// === Shenandoah GC (Low latency) ===\n/*\n-XX:+UseShenandoahGC                    // Enable Shenandoah (Java 12+)\n-XX:ShenandoahGCHeuristics=adaptive     // Heuristics: adaptive/compact/static\n-XX:ShenandoahGuaranteedGCInterval=20000 // Max interval: 20s\n*/\n\n// === Parallel GC (Throughput) ===\n/*\n-XX:+UseParallelGC             // Enable Parallel GC\n-XX:ParallelGCThreads=8        // GC threads\n-XX:MaxGCPauseMillis=1000      // Max pause (best effort)\n*/\n\n// === Serial GC (Small heaps) ===\n/*\n-XX:+UseSerialGC               // Single-threaded GC\n*/\n\n// === Common GC Logging ===\n/*\n// Java 9+ (unified logging)\n-Xlog:gc                       // Basic GC info\n-Xlog:gc*                      // Detailed GC info\n-Xlog:gc*:file=gc.log:time,level,tags\n\n// Java 8 (legacy)\n-XX:+PrintGCDetails\n-XX:+PrintGCTimeStamps\n-XX:+PrintGCDateStamps\n-Xloggc:gc.log\n*/"
        },
        {
          "name": "‚úÖ Memory Leaks & Detection",
          "text": "**Usage:** Identify and prevent memory leaks using profiling tools and best practices to avoid OutOfMemoryErrors and performance degradation.\n\n**Gains:**\n‚Ä¢ **Early Detection:** Find leaks in development, not production\n‚Ä¢ **Prevent Crashes:** Avoid OutOfMemoryError-caused downtime\n‚Ä¢ **Better Performance:** Eliminate memory bloat (50%+ improvement possible)\n‚Ä¢ **Cost Savings:** Reduce memory requirements by 20-50%\n\n**Common Leak Patterns:**\n1. **Static Collections (40%):** Never-cleared caches and lists\n2. **Event Listeners (25%):** Unregistered listeners hold references\n3. **Unclosed Resources (20%):** Files, connections, streams\n4. **ThreadLocal (10%):** Not cleaned in thread pools\n5. **Inner Classes (5%):** Implicit outer class references\n\n**Detection Tools:**\n‚Ä¢ **VisualVM:** Free, real-time monitoring, heap dumps\n‚Ä¢ **Eclipse MAT:** Free, heap dump analysis, leak suspects report\n‚Ä¢ **JProfiler:** Commercial $499, advanced analysis, low overhead\n‚Ä¢ **YourKit:** Commercial $799, intelligent leak detection\n‚Ä¢ **JFR (Java Flight Recorder):** Built-in, production-ready, <1% overhead\n\n**Impact Metrics:**\n‚Ä¢ 10MB/hour leak ‚Üí 8.6GB/month growth\n‚Ä¢ 20% memory waste ‚Üí 2x infrastructure costs\n‚Ä¢ Detection time: 5min (profiler) vs 5hrs (log analysis)",
          "code": "import java.lang.ref.*;\nimport java.util.*;\nimport java.io.*;\n\n// === ANTI-PATTERN 1: Static Collection Leak ===\nclass StaticCollectionLeak {\n    // MEMORY LEAK: Never cleared!\n    private static List<Object> cache = new ArrayList<>();\n    \n    public void addToCache(Object obj) {\n        cache.add(obj); // Accumulates forever\n    }\n    \n    // FIX 1: Add cleanup method\n    public void clearCache() {\n        cache.clear();\n    }\n    \n    // FIX 2: Bounded cache with LRU eviction\n    private static Map<String, Object> boundedCache = \n        Collections.synchronizedMap(\n            new LinkedHashMap<String, Object>(100, 0.75f, true) {\n                @Override\n                protected boolean removeEldestEntry(Map.Entry eldest) {\n                    return size() > 100; // Max 100 entries\n                }\n            }\n        );\n}\n\n// === ANTI-PATTERN 2: Unclosed Resources ===\nclass ResourceLeak {\n    \n    // BAD: Resource not closed (LEAK!)\n    public void readFileBad(String path) throws IOException {\n        FileInputStream fis = new FileInputStream(path);\n        // Process file...\n        // LEAK: fis never closed!\n    }\n    \n    // GOOD: try-with-resources (Java 7+)\n    public void readFileGood(String path) throws IOException {\n        try (FileInputStream fis = new FileInputStream(path)) {\n            // Process file...\n        } // Automatically closed!\n    }\n    \n    // GOOD: Multiple resources\n    public void copyFile(String src, String dest) throws IOException {\n        try (FileInputStream in = new FileInputStream(src);\n             FileOutputStream out = new FileOutputStream(dest)) {\n            byte[] buffer = new byte[8192];\n            int n;\n            while ((n = in.read(buffer)) > 0) {\n                out.write(buffer, 0, n);\n            }\n        } // Both streams closed automatically\n    }\n}\n\n// === ANTI-PATTERN 3: Event Listener Leak ===\nclass ListenerLeak {\n    private List<EventListener> listeners = new ArrayList<>();\n    \n    public void addListener(EventListener listener) {\n        listeners.add(listener); // Holds strong reference!\n    }\n    \n    // MUST provide remove (often forgotten)\n    public void removeListener(EventListener listener) {\n        listeners.remove(listener);\n    }\n    \n    // BETTER: Use WeakReference for auto cleanup\n    private List<WeakReference<EventListener>> weakListeners = new ArrayList<>();\n    \n    public void addWeakListener(EventListener listener) {\n        weakListeners.add(new WeakReference<>(listener));\n    }\n    \n    public void fireEvent(String event) {\n        // Clean dead references\n        weakListeners.removeIf(ref -> ref.get() == null);\n        \n        // Notify alive listeners\n        for (WeakReference<EventListener> ref : weakListeners) {\n            EventListener listener = ref.get();\n            if (listener != null) {\n                listener.onEvent(event);\n            }\n        }\n    }\n}\n\n// === ANTI-PATTERN 4: ThreadLocal Leak ===\nclass ThreadLocalLeak {\n    // ThreadLocal in thread pool - LEAK!\n    private static ThreadLocal<byte[]> threadData = new ThreadLocal<>();\n    \n    // BAD: Data never cleared\n    public void processRequestBad() {\n        threadData.set(new byte[1024 * 1024]); // 1MB\n        // Process...\n        // LEAK: Thread reused, data never cleared!\n    }\n    \n    // GOOD: Always clean up in finally\n    public void processRequestGood() {\n        try {\n            threadData.set(new byte[1024 * 1024]);\n            // Process...\n        } finally {\n            threadData.remove(); // CRITICAL!\n        }\n    }\n}\n\n// === Memory Leak Detection ===\nclass LeakDetector {\n    \n    // Test if object is garbage collected\n    public static void testGC() throws InterruptedException {\n        Object obj = new Object();\n        WeakReference<Object> weakRef = new WeakReference<>(obj);\n        \n        System.out.println(\"Before GC: \" + (weakRef.get() != null)); // true\n        \n        obj = null; // Remove strong reference\n        System.gc(); // Suggest GC\n        Thread.sleep(100); // Give GC time\n        \n        System.out.println(\"After GC: \" + (weakRef.get() != null)); // false\n    }\n    \n    // Monitor heap growth over time\n    public static void monitorHeapGrowth() {\n        Runtime runtime = Runtime.getRuntime();\n        long startUsed = runtime.totalMemory() - runtime.freeMemory();\n        \n        // Do work...\n        \n        long endUsed = runtime.totalMemory() - runtime.freeMemory();\n        long growth = endUsed - startUsed;\n        long growthMB = growth / (1024 * 1024);\n        \n        System.out.println(\"Heap growth: \" + growthMB + \" MB\");\n        \n        if (growthMB > 100) {\n            System.out.println(\"‚ö†Ô∏è  WARNING: Potential memory leak!\");\n        }\n    }\n}\n\ninterface EventListener {\n    void onEvent(String event);\n}\n\n// === Java Flight Recorder Commands ===\n/*\n// Start recording\njcmd <pid> JFR.start name=MyRecording duration=60s filename=app.jfr\n\n// Dump ongoing recording\njcmd <pid> JFR.dump name=MyRecording filename=dump.jfr\n\n// Stop recording\njcmd <pid> JFR.stop name=MyRecording\n\n// Analyze with Java Mission Control\njmc -open app.jfr\n\n// Heap dump for analysis\njcmd <pid> GC.heap_dump /tmp/heapdump.hprof\n*/"
        }
      ]
    },
    {
      "id": "concurrency-advanced",
      "title": "‚ö° Advanced Concurrency",
      "sections": [
        {
          "name": "‚úÖ Lock-Free Programming",
          "text": "**Usage:** Implement high-performance concurrent data structures using Compare-And-Swap (CAS) operations instead of locks for maximum throughput.\n\n**Gains:**\n‚Ä¢ **5-10x Throughput:** Compared to synchronized methods under high contention\n‚Ä¢ **No Deadlocks:** Elimination of deadlock possibility\n‚Ä¢ **Better Scalability:** Linear performance improvement with CPU cores\n‚Ä¢ **Lower Latency:** No context switching overhead from blocking\n‚Ä¢ **Wait-Free Progress:** Guaranteed progress for at least one thread\n\n**Performance Comparison:**\n```\nSynchronized Counter:  ~5M ops/sec  (8 threads)\nLock-Free Counter:    ~30M ops/sec (8 threads)\nSpeedup:              6x faster\n```\n\n**When to Use:**\n‚Ä¢ High contention on shared state (many threads, same data)\n‚Ä¢ Need maximum throughput and low latency\n‚Ä¢ Avoiding deadlocks is critical\n‚Ä¢ Real-time systems requiring progress guarantees\n\n**When NOT to Use:**\n‚Ä¢ Complex state transitions (multiple dependent variables)\n‚Ä¢ Low contention (locks are simpler and sufficient)\n‚Ä¢ Algorithm complexity outweighs benefits",
          "code": "import java.util.concurrent.atomic.*;\n\n// === Lock-Free Counter (6x faster than synchronized) ===\npublic class LockFreeCounter {\n    private final AtomicInteger count = new AtomicInteger(0);\n    \n    // Atomic increment - no locks!\n    public int increment() {\n        return count.incrementAndGet();\n    }\n    \n    public int decrement() {\n        return count.decrementAndGet();\n    }\n    \n    public int get() {\n        return count.get();\n    }\n    \n    // CAS loop for conditional update\n    public boolean incrementIfLessThan(int max) {\n        int current, next;\n        do {\n            current = count.get();\n            if (current >= max) return false;\n            next = current + 1;\n        } while (!count.compareAndSet(current, next));\n        return true;\n    }\n}\n\n// === Lock-Free Stack ===\npublic class LockFreeStack<T> {\n    private final AtomicReference<Node<T>> head = new AtomicReference<>();\n    \n    private static class Node<T> {\n        final T data;\n        Node<T> next;\n        Node(T data, Node<T> next) {\n            this.data = data;\n            this.next = next;\n        }\n    }\n    \n    public void push(T item) {\n        Node<T> newHead = new Node<>(item, null);\n        Node<T> currentHead;\n        do {\n            currentHead = head.get();\n            newHead.next = currentHead;\n        } while (!head.compareAndSet(currentHead, newHead));\n    }\n    \n    public T pop() {\n        Node<T> currentHead, newHead;\n        do {\n            currentHead = head.get();\n            if (currentHead == null) return null;\n            newHead = currentHead.next;\n        } while (!head.compareAndSet(currentHead, newHead));\n        return currentHead.data;\n    }\n}\n\n// === Comparison: Synchronized vs Lock-Free ===\nclass CounterBenchmark {\n    \n    // OLD: Synchronized (slower)\n    static class SyncCounter {\n        private int count = 0;\n        public synchronized int increment() {\n            return ++count;\n        }\n    }\n    \n    // NEW: Lock-Free (6x faster)\n    static class AtomicCounter {\n        private final AtomicInteger count = new AtomicInteger(0);\n        public int increment() {\n            return count.incrementAndGet();\n        }\n    }\n}"
        },
        {
          "name": "‚úÖ Thread Pools & Executors",
          "text": "**Usage:** Manage thread lifecycle efficiently using thread pools instead of creating threads manually, with proper sizing and monitoring.\n\n**Gains:**\n‚Ä¢ **50-200% Throughput:** With optimal pool sizing vs default\n‚Ä¢ **1000x Faster Thread Reuse:** vs creating new threads (1-2Œºs vs 1-2ms)\n‚Ä¢ **Resource Control:** Prevent thread exhaustion with bounded pools\n‚Ä¢ **Load Management:** Handle spikes with task queues\n‚Ä¢ **Better Monitoring:** Track metrics for bottleneck identification\n\n**Optimal Pool Sizing:**\n```\nCPU-bound:  threads = CPU cores + 1\nI/O-bound:  threads = cores √ó (1 + wait_time/compute_time)\n\nExample: 8 cores, 90% I/O wait\nthreads = 8 √ó (1 + 9) = 80 threads\n```\n\n**Pool Types:**\n‚Ä¢ **FixedThreadPool:** Fixed size, bounded queue, predictable resources\n‚Ä¢ **CachedThreadPool:** Unlimited threads, 60s timeout, dynamic workload\n‚Ä¢ **SingleThreadExecutor:** One thread, sequential execution guaranteed\n‚Ä¢ **ScheduledThreadPool:** Delayed/periodic tasks\n‚Ä¢ **VirtualThreadPerTask:** Millions of virtual threads (Java 21+)\n\n**When to Use:**\n‚Ä¢ **Fixed:** Known workload, prevent resource exhaustion\n‚Ä¢ **Cached:** Short-lived async tasks, variable load\n‚Ä¢ **Scheduled:** Cron-like periodic tasks\n‚Ä¢ **Virtual:** High concurrency (10K+ concurrent operations)",
          "code": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n// === Custom ThreadFactory ===\npublic class CustomThreadFactory implements ThreadFactory {\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    private final String namePrefix;\n    \n    public CustomThreadFactory(String namePrefix) {\n        this.namePrefix = namePrefix;\n    }\n    \n    @Override\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(r, \n            namePrefix + \"-\" + threadNumber.getAndIncrement());\n        t.setDaemon(false);\n        t.setUncaughtExceptionHandler((thread, throwable) -> {\n            System.err.println(\"Error in \" + thread.getName());\n            throwable.printStackTrace();\n        });\n        return t;\n    }\n}\n\n// === Optimized Thread Pool ===\npublic class OptimizedThreadPool {\n    \n    public static ThreadPoolExecutor createOptimized() {\n        int processors = Runtime.getRuntime().availableProcessors();\n        int coreSize = processors + 1;\n        int maxSize = processors * 2;\n        \n        return new ThreadPoolExecutor(\n            coreSize,                              // Core threads\n            maxSize,                               // Max threads\n            60L, TimeUnit.SECONDS,                 // Idle timeout\n            new LinkedBlockingQueue<>(1000),       // Bounded queue\n            new CustomThreadFactory(\"Worker\"),     // Named threads\n            new ThreadPoolExecutor.CallerRunsPolicy() // Backpressure\n        );\n    }\n}\n\n// === Thread Pool Monitoring ===\npublic class PoolMonitor {\n    \n    public static void monitor(ThreadPoolExecutor executor) {\n        System.out.println(\"\\n=== Thread Pool Stats ===\");\n        System.out.println(\"Pool size: \" + executor.getPoolSize());\n        System.out.println(\"Active threads: \" + executor.getActiveCount());\n        System.out.println(\"Task count: \" + executor.getTaskCount());\n        System.out.println(\"Completed: \" + executor.getCompletedTaskCount());\n        System.out.println(\"Queue size: \" + executor.getQueue().size());\n        \n        // Alerts\n        int queueSize = executor.getQueue().size();\n        int capacity = executor.getQueue().remainingCapacity();\n        double usage = queueSize / (double)(queueSize + capacity);\n        \n        if (usage > 0.8) {\n            System.out.println(\"‚ö†Ô∏è  Queue \" + (int)(usage*100) + \"% full!\");\n        }\n        if (executor.getActiveCount() == executor.getMaximumPoolSize()) {\n            System.out.println(\"‚ö†Ô∏è  All threads busy!\");\n        }\n    }\n}\n\n// === Graceful Shutdown ===\npublic class GracefulShutdown {\n    \n    public static void shutdown(ExecutorService executor, long timeout) {\n        executor.shutdown();\n        try {\n            if (!executor.awaitTermination(timeout, TimeUnit.SECONDS)) {\n                executor.shutdownNow();\n                if (!executor.awaitTermination(timeout, TimeUnit.SECONDS)) {\n                    System.err.println(\"Executor did not terminate\");\n                }\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }\n}"
        },
        {
          "name": "‚úÖ Concurrent Collections",
          "text": "**Usage:** Use thread-safe collections optimized for concurrent access instead of synchronized wrappers for better performance.\n\n**Gains:**\n‚Ä¢ **10x Throughput:** ConcurrentHashMap vs synchronized HashMap (8 threads)\n‚Ä¢ **Lock-Free Reads:** No blocking on read operations\n‚Ä¢ **Fine-Grained Locking:** Better concurrency than Collections.synchronized*\n‚Ä¢ **Atomic Operations:** compute(), merge() without external synchronization\n\n**Performance Comparison:**\n```\nSynchronized HashMap:    ~1M ops/sec (8 threads)\nConcurrentHashMap:      ~10M ops/sec (8 threads)\nImprovement:            10x faster\n```\n\n**Collection Choice:**\n‚Ä¢ **ConcurrentHashMap:** High read/write concurrency\n‚Ä¢ **CopyOnWriteArrayList:** 99% reads, 1% writes, small lists\n‚Ä¢ **ConcurrentLinkedQueue:** Lock-free queue, high throughput\n‚Ä¢ **BlockingQueue:** Producer-consumer patterns\n‚Ä¢ **ConcurrentSkipListMap:** Sorted concurrent access\n\n**Anti-Patterns to Avoid:**\n‚Ä¢ Don't use Collections.synchronizedMap() - use ConcurrentHashMap\n‚Ä¢ Don't iterate ConcurrentHashMap with locks - it's thread-safe\n‚Ä¢ Don't use CopyOnWriteArrayList for write-heavy scenarios",
          "code": "import java.util.concurrent.*;\nimport java.util.*;\n\n// === ConcurrentHashMap Advanced Operations ===\npublic class ConcurrentMapExample {\n    private final ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n    \n    // Atomic compute\n    public void incrementCounter(String key) {\n        map.compute(key, (k, v) -> v == null ? 1 : v + 1);\n    }\n    \n    // Atomic merge\n    public void addValue(String key, int delta) {\n        map.merge(key, delta, Integer::sum);\n    }\n    \n    // putIfAbsent (atomic)\n    public Integer getOrCreate(String key) {\n        return map.computeIfAbsent(key, k -> expensiveComputation(k));\n    }\n    \n    private Integer expensiveComputation(String key) {\n        return key.hashCode();\n    }\n    \n    // Parallel bulk operations\n    public void parallelForEach() {\n        map.forEach(100, (key, value) -> {\n            // Parallel processing with threshold=100\n            System.out.println(key + \" = \" + value);\n        });\n    }\n}\n\n// === Producer-Consumer with BlockingQueue ===\npublic class ProducerConsumer {\n    private final BlockingQueue<Task> queue = \n        new ArrayBlockingQueue<>(100);\n    \n    // Producer\n    public void produce(Task task) throws InterruptedException {\n        queue.put(task); // Blocks if queue full\n    }\n    \n    // Consumer\n    public Task consume() throws InterruptedException {\n        return queue.take(); // Blocks if queue empty\n    }\n    \n    // Non-blocking variants\n    public boolean tryProduce(Task task) {\n        return queue.offer(task); // Returns false if full\n    }\n    \n    public Task tryConsume() {\n        return queue.poll(); // Returns null if empty\n    }\n}\n\n// === CopyOnWriteArrayList (Read-Heavy) ===\npublic class EventListeners {\n    // Perfect for listeners: many reads, rare writes\n    private final CopyOnWriteArrayList<Listener> listeners = \n        new CopyOnWriteArrayList<>();\n    \n    public void addListener(Listener listener) {\n        listeners.add(listener); // Copies entire array (expensive!)\n    }\n    \n    public void removeListener(Listener listener) {\n        listeners.remove(listener); // Copies entire array\n    }\n    \n    public void fireEvent(Event event) {\n        // Reads don't lock, use snapshot\n        for (Listener listener : listeners) {\n            listener.onEvent(event);\n        }\n    }\n}\n\n// === ConcurrentSkipListMap (Sorted) ===\npublic class SortedConcurrentExample {\n    private final ConcurrentSkipListMap<Long, String> sortedMap = \n        new ConcurrentSkipListMap<>();\n    \n    public void addTimestampedEvent(String event) {\n        sortedMap.put(System.currentTimeMillis(), event);\n    }\n    \n    public NavigableMap<Long, String> getRecentEvents(long since) {\n        return sortedMap.tailMap(since);\n    }\n}\n\ninterface Listener {\n    void onEvent(Event event);\n}\n\nclass Event {}\nclass Task {}"
        }
      ]
    },
    {
      "id": "design-patterns",
      "title": "üé® Design Patterns",
      "sections": [
        {
          "name": "‚úÖ Singleton Pattern",
          "text": "**Usage:** Ensure only one instance of a class exists globally, providing controlled access to shared resources.\n\n**Gains:**\n‚Ä¢ **Resource Control:** Single database connection pool, configuration manager\n‚Ä¢ **Memory Efficiency:** One instance instead of multiple duplicates\n‚Ä¢ **Global Access:** Controlled access point for shared state\n‚Ä¢ **Thread-Safety:** Various implementations with different safety guarantees\n\n**Implementation Comparison:**\n\n| Approach | Thread-Safe | Lazy Init | Performance | Recommended |\n|----------|-------------|-----------|-------------|-------------|\n| Eager | ‚úÖ | ‚ùå | Fast | Simple apps |\n| Lazy | ‚ùå | ‚úÖ | Fast | ‚ùå Don't use |\n| Synchronized | ‚úÖ | ‚úÖ | 2x slower | Low traffic |\n| Double-checked | ‚úÖ | ‚úÖ | Fast | ‚ö†Ô∏è Volatile needed |\n| Bill Pugh | ‚úÖ | ‚úÖ | Fast | ‚úÖ Best |\n| Enum | ‚úÖ | ‚ùå | Fast | ‚úÖ Joshua Bloch |\n\n**Best Practices:**\n‚Ä¢ **Use Enum** for simplicity and safety (prevents reflection/serialization attacks)\n‚Ä¢ **Use Bill Pugh** for lazy initialization without synchronization\n‚Ä¢ **Avoid Double-checked** unless you understand volatile semantics\n\n**Common Pitfalls:**\n‚Ä¢ Reflection can break singleton (except enum)\n‚Ä¢ Serialization can create multiple instances (except enum)\n‚Ä¢ Cloning can violate singleton pattern",
          "code": "// === 1. Eager Initialization (Simple) ===\npublic class EagerSingleton {\n    private static final EagerSingleton INSTANCE = new EagerSingleton();\n    \n    private EagerSingleton() {} // Private constructor\n    \n    public static EagerSingleton getInstance() {\n        return INSTANCE;\n    }\n}\n\n// === 2. Lazy Initialization (NOT thread-safe!) ===\npublic class LazySingleton {\n    private static LazySingleton instance;\n    \n    private LazySingleton() {}\n    \n    // DON'T USE: Not thread-safe!\n    public static LazySingleton getInstance() {\n        if (instance == null) {\n            instance = new LazySingleton(); // Race condition!\n        }\n        return instance;\n    }\n}\n\n// === 3. Synchronized (Thread-safe but slow) ===\npublic class SynchronizedSingleton {\n    private static SynchronizedSingleton instance;\n    \n    private SynchronizedSingleton() {}\n    \n    // Thread-safe but 2x slower\n    public static synchronized SynchronizedSingleton getInstance() {\n        if (instance == null) {\n            instance = new SynchronizedSingleton();\n        }\n        return instance;\n    }\n}\n\n// === 4. Double-Checked Locking (Fast + thread-safe) ===\npublic class DoubleCheckedSingleton {\n    // MUST be volatile!\n    private static volatile DoubleCheckedSingleton instance;\n    \n    private DoubleCheckedSingleton() {}\n    \n    public static DoubleCheckedSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DoubleCheckedSingleton.class) {\n                if (instance == null) {\n                    instance = new DoubleCheckedSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n// === 5. Bill Pugh (Best for lazy init) ===\npublic class BillPughSingleton {\n    private BillPughSingleton() {}\n    \n    // Inner class loaded only when getInstance() is called\n    private static class SingletonHolder {\n        private static final BillPughSingleton INSTANCE = new BillPughSingleton();\n    }\n    \n    public static BillPughSingleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n\n// === 6. Enum Singleton (Best overall - Joshua Bloch) ===\npublic enum EnumSingleton {\n    INSTANCE;\n    \n    private int value;\n    \n    public int getValue() {\n        return value;\n    }\n    \n    public void setValue(int value) {\n        this.value = value;\n    }\n    \n    public void doSomething() {\n        System.out.println(\"Singleton operation\");\n    }\n}\n\n// Usage: EnumSingleton.INSTANCE.doSomething();\n\n// === Why Enum is Best ===\n/*\nAdvantages:\n1. Thread-safe by default\n2. Serialization-safe (no multiple instances)\n3. Reflection-proof (cannot instantiate enum)\n4. Concise - one line!\n5. Works with switch statements\n\nDisadvantages:\n1. Not lazy (initialized at class loading)\n2. Cannot extend classes (but can implement interfaces)\n*/\n\n// === Singleton with Dependency Injection ===\npublic class DatabaseConnection {\n    private static volatile DatabaseConnection instance;\n    private final String connectionString;\n    \n    private DatabaseConnection(String connectionString) {\n        this.connectionString = connectionString;\n    }\n    \n    public static DatabaseConnection getInstance(String connectionString) {\n        if (instance == null) {\n            synchronized (DatabaseConnection.class) {\n                if (instance == null) {\n                    instance = new DatabaseConnection(connectionString);\n                }\n            }\n        }\n        return instance;\n    }\n    \n    // Prevent cloning\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException(\"Singleton cannot be cloned\");\n    }\n    \n    // Serialization protection\n    protected Object readResolve() {\n        return getInstance(connectionString);\n    }\n}"
        },
        {
          "name": "‚úÖ Factory Pattern",
          "text": "**Usage:** Create objects without specifying exact classes, providing flexibility and decoupling object creation from usage.\n\n**Gains:**\n‚Ä¢ **Loose Coupling:** Client code doesn't depend on concrete classes\n‚Ä¢ **Flexibility:** Easy to add new types without changing client code\n‚Ä¢ **Single Responsibility:** Object creation logic in one place\n‚Ä¢ **Polymorphism:** Return different implementations through same interface\n\n**Pattern Variants:**\n‚Ä¢ **Simple Factory:** Single factory method, not part of Gang of Four\n‚Ä¢ **Factory Method:** Subclasses decide which class to instantiate\n‚Ä¢ **Abstract Factory:** Family of related objects\n\n**When to Use:**\n‚Ä¢ Complex object creation logic\n‚Ä¢ Need to support multiple product variants\n‚Ä¢ Want to hide implementation details from client\n‚Ä¢ Object creation depends on configuration/context",
          "code": "// === Simple Factory ===\npublic class ShapeFactory {\n    \n    public static Shape createShape(String type) {\n        return switch (type.toLowerCase()) {\n            case \"circle\" -> new Circle();\n            case \"rectangle\" -> new Rectangle();\n            case \"triangle\" -> new Triangle();\n            default -> throw new IllegalArgumentException(\"Unknown shape: \" + type);\n        };\n    }\n}\n\n// === Factory Method Pattern ===\npublic abstract class DocumentCreator {\n    \n    // Factory method - subclasses override\n    protected abstract Document createDocument();\n    \n    // Template method using factory\n    public void openDocument() {\n        Document doc = createDocument();\n        doc.open();\n        doc.render();\n    }\n}\n\npublic class PDFCreator extends DocumentCreator {\n    @Override\n    protected Document createDocument() {\n        return new PDFDocument();\n    }\n}\n\npublic class WordCreator extends DocumentCreator {\n    @Override\n    protected Document createDocument() {\n        return new WordDocument();\n    }\n}\n\n// === Abstract Factory Pattern ===\npublic interface GUIFactory {\n    Button createButton();\n    TextField createTextField();\n    Checkbox createCheckbox();\n}\n\npublic class WindowsFactory implements GUIFactory {\n    @Override\n    public Button createButton() {\n        return new WindowsButton();\n    }\n    \n    @Override\n    public TextField createTextField() {\n        return new WindowsTextField();\n    }\n    \n    @Override\n    public Checkbox createCheckbox() {\n        return new WindowsCheckbox();\n    }\n}\n\npublic class MacFactory implements GUIFactory {\n    @Override\n    public Button createButton() {\n        return new MacButton();\n    }\n    \n    @Override\n    public TextField createTextField() {\n        return new MacTextField();\n    }\n    \n    @Override\n    public Checkbox createCheckbox() {\n        return new MacCheckbox();\n    }\n}\n\n// === Usage ===\npublic class Application {\n    private final GUIFactory factory;\n    \n    public Application(GUIFactory factory) {\n        this.factory = factory;\n    }\n    \n    public void createUI() {\n        Button button = factory.createButton();\n        TextField textField = factory.createTextField();\n        Checkbox checkbox = factory.createCheckbox();\n        \n        // Use components...\n    }\n    \n    public static void main(String[] args) {\n        // Choose factory based on OS\n        String os = System.getProperty(\"os.name\");\n        GUIFactory factory = os.contains(\"Windows\") ? \n            new WindowsFactory() : new MacFactory();\n        \n        Application app = new Application(factory);\n        app.createUI();\n    }\n}\n\n// Interfaces\ninterface Shape { void draw(); }\ninterface Document { void open(); void render(); }\ninterface Button { void render(); void onClick(); }\ninterface TextField { void render(); String getText(); }\ninterface Checkbox { void render(); boolean isChecked(); }\n\n// Implementations\nclass Circle implements Shape { public void draw() {} }\nclass Rectangle implements Shape { public void draw() {} }\nclass Triangle implements Shape { public void draw() {} }\nclass PDFDocument implements Document { public void open() {} public void render() {} }\nclass WordDocument implements Document { public void open() {} public void render() {} }\nclass WindowsButton implements Button { public void render() {} public void onClick() {} }\nclass MacButton implements Button { public void render() {} public void onClick() {} }\nclass WindowsTextField implements TextField { public void render() {} public String getText() { return \"\"; } }\nclass MacTextField implements TextField { public void render() {} public String getText() { return \"\"; } }\nclass WindowsCheckbox implements Checkbox { public void render() {} public boolean isChecked() { return false; } }\nclass MacCheckbox implements Checkbox { public void render() {} public boolean isChecked() { return false; } }"
        },
        {
          "name": "‚úÖ Observer Pattern",
          "text": "**Usage:** Define one-to-many dependency where multiple observers get notified when subject's state changes.\n\n**Gains:**\n‚Ä¢ **Loose Coupling:** Subjects don't know concrete observer classes\n‚Ä¢ **Dynamic Subscription:** Add/remove observers at runtime\n‚Ä¢ **Broadcast Communication:** Notify all observers automatically\n‚Ä¢ **Event-Driven Architecture:** Foundation for reactive systems\n\n**Java Built-in Support:**\n‚Ä¢ `java.util.Observer` (deprecated Java 9+)\n‚Ä¢ `java.beans.PropertyChangeListener`\n‚Ä¢ Modern: Use functional interfaces with lambdas\n\n**Common Use Cases:**\n‚Ä¢ GUI event handling (button clicks, text changes)\n‚Ä¢ Model-View-Controller (MVC) pattern\n‚Ä¢ Event systems and message brokers\n‚Ä¢ Real-time data updates (stock prices, sensor data)\n\n**Thread Safety:**\n‚Ä¢ Use CopyOnWriteArrayList for thread-safe observer list\n‚Ä¢ WeakReference to prevent memory leaks\n‚Ä¢ Consider async notification with ExecutorService",
          "code": "import java.util.*;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.function.Consumer;\n\n// === Modern Observer with Functional Interface ===\n@FunctionalInterface\npublic interface Observer<T> {\n    void update(T data);\n}\n\npublic class Subject<T> {\n    // Thread-safe observer list\n    private final List<Observer<T>> observers = \n        new CopyOnWriteArrayList<>();\n    \n    public void subscribe(Observer<T> observer) {\n        observers.add(observer);\n    }\n    \n    public void unsubscribe(Observer<T> observer) {\n        observers.remove(observer);\n    }\n    \n    protected void notifyObservers(T data) {\n        for (Observer<T> observer : observers) {\n            observer.update(data);\n        }\n    }\n}\n\n// === Example: Stock Price Monitor ===\npublic class Stock extends Subject<Double> {\n    private String symbol;\n    private double price;\n    \n    public Stock(String symbol, double price) {\n        this.symbol = symbol;\n        this.price = price;\n    }\n    \n    public void setPrice(double price) {\n        this.price = price;\n        notifyObservers(price); // Notify all observers\n    }\n    \n    public String getSymbol() {\n        return symbol;\n    }\n    \n    public double getPrice() {\n        return price;\n    }\n}\n\n// === Observers ===\npublic class PriceAlert implements Observer<Double> {\n    private final String name;\n    private final double threshold;\n    \n    public PriceAlert(String name, double threshold) {\n        this.name = name;\n        this.threshold = threshold;\n    }\n    \n    @Override\n    public void update(Double price) {\n        if (price > threshold) {\n            System.out.println(name + \": Alert! Price \" + price + \n                \" exceeds \" + threshold);\n        }\n    }\n}\n\n// === Usage ===\npublic class ObserverDemo {\n    public static void main(String[] args) {\n        Stock apple = new Stock(\"AAPL\", 150.0);\n        \n        // Subscribe with lambda\n        apple.subscribe(price -> \n            System.out.println(\"Price updated: $\" + price));\n        \n        // Subscribe with object\n        apple.subscribe(new PriceAlert(\"High Price Alert\", 160.0));\n        \n        // Subscribe with method reference\n        apple.subscribe(System.out::println);\n        \n        // Trigger notifications\n        apple.setPrice(155.0);\n        apple.setPrice(165.0); // Triggers alert\n    }\n}\n\n// === Event Filtering ===\npublic class FilteredObserver<T> implements Observer<T> {\n    private final Observer<T> delegate;\n    private final java.util.function.Predicate<T> filter;\n    \n    public FilteredObserver(Observer<T> delegate, \n                           java.util.function.Predicate<T> filter) {\n        this.delegate = delegate;\n        this.filter = filter;\n    }\n    \n    @Override\n    public void update(T data) {\n        if (filter.test(data)) {\n            delegate.update(data);\n        }\n    }\n}\n\n// === Usage with filter ===\n// Only notify if price > 160\nStock stock = new Stock(\"GOOGL\", 150.0);\nObserver<Double> filtered = new FilteredObserver<>(\n    price -> System.out.println(\"High price: \" + price),\n    price -> price > 160\n);\nstock.subscribe(filtered);"
        }
      ]
    },
    {
      "id": "performance",
      "title": "üöÄ Performance Optimization",
      "sections": [
        {
          "name": "‚úÖ JIT Compilation & Optimization",
          "text": "**Usage:** Understanding JIT (Just-In-Time) compiler optimizations to write JIT-friendly code for maximum performance.\n\n**Gains:**\n‚Ä¢ **Method Inlining:** 5-20% speedup by eliminating method call overhead (~5ns per call)\n‚Ä¢ **Loop Unrolling:** 2-4x faster for tight loops\n‚Ä¢ **Escape Analysis:** 10x faster by avoiding heap allocation\n‚Ä¢ **Branch Prediction:** 20-50% improvement for sorted data\n‚Ä¢ **Dead Code Elimination:** Remove unused calculations\n\n**JIT Compilation Tiers:**\n```\nInterpreted:      100x slower than native\nC1 (Client):      ~10x slower, fast compilation\nC2 (Server):      Near-native speed, aggressive optimization\n```\n\n**Warmup Impact:**\n```\nCold start (interpreted):  1000 ms\nAfter warmup (JIT):        100 ms\nSpeedup:                   10x faster\n```\n\n**Key Optimizations:**\n1. **Inlining:** Methods <35 bytecodes inlined automatically\n2. **Loop Unrolling:** Reduces loop overhead, better CPU pipelining\n3. **Escape Analysis:** Objects that don't escape can be stack-allocated\n4. **Branch Prediction:** Consistent branches predicted correctly\n\n**When Important:**\n‚Ä¢ High-frequency methods (millions of calls)\n‚Ä¢ Tight loops processing large datasets\n‚Ä¢ Low-latency requirements (<10ms)\n‚Ä¢ CPU-bound computations",
          "code": "// === Method Inlining Example ===\npublic class InliningDemo {\n    \n    // Small method - will be inlined by JIT\n    private static int add(int a, int b) {\n        return a + b; // <35 bytecodes\n    }\n    \n    public static void main(String[] args) {\n        int sum = 0;\n        // After JIT warmup, add() call overhead eliminated\n        for (int i = 0; i < 1_000_000; i++) {\n            sum += add(i, i + 1); // Inlined\n        }\n    }\n    \n    // Too large - won't be inlined\n    private static int complexCalculation(int a, int b) {\n        // Many operations...\n        int result = 0;\n        for (int i = 0; i < 100; i++) {\n            result += a * b + i;\n        }\n        return result; // >35 bytecodes\n    }\n}\n\n// === Loop Unrolling ===\npublic class LoopUnrolling {\n    \n    // Original loop\n    public static int sumOriginal(int[] array) {\n        int sum = 0;\n        for (int i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n    \n    // JIT unrolls to something like this (4x unrolling)\n    public static int sumUnrolled(int[] array) {\n        int sum = 0;\n        int i = 0;\n        int len = array.length;\n        int limit = len - 3;\n        \n        // Process 4 elements at a time\n        for (; i < limit; i += 4) {\n            sum += array[i];\n            sum += array[i + 1];\n            sum += array[i + 2];\n            sum += array[i + 3];\n        }\n        \n        // Handle remaining elements\n        for (; i < len; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n}\n\n// === Escape Analysis ===\npublic class EscapeAnalysis {\n    \n    // Object escapes - heap allocated\n    public static Point createPoint() {\n        return new Point(10, 20); // Returned - escapes!\n    }\n    \n    // Object doesn't escape - stack allocated (10x faster!)\n    public static int usePoint() {\n        Point p = new Point(10, 20); // Doesn't escape\n        return p.x + p.y; // JIT allocates on stack\n    }\n    \n    static class Point {\n        int x, y;\n        Point(int x, int y) { this.x = x; this.y = y; }\n    }\n}\n\n// === Branch Prediction Optimization ===\npublic class BranchPrediction {\n    \n    public static long sumEvens(int[] array) {\n        long sum = 0;\n        // If array is sorted, branch prediction very accurate\n        for (int value : array) {\n            if (value % 2 == 0) { // Predictable if sorted\n                sum += value;\n            }\n        }\n        return sum;\n    }\n}\n\n// === JIT Compiler Flags ===\n/*\n// Print JIT compilation\n-XX:+PrintCompilation\n\n// Print inlining decisions\n-XX:+UnlockDiagnosticVMOptions\n-XX:+PrintInlining\n\n// Print assembly code\n-XX:+PrintAssembly\n\n// Control inlining\n-XX:MaxInlineSize=35        // Max bytecodes to inline\n-XX:FreqInlineSize=325      // Inline hot methods up to this size\n\n// Tiered compilation (default in Java 8+)\n-XX:+TieredCompilation\n-XX:TieredStopAtLevel=4     // 1=C1 only, 4=C2 (default)\n\n// Force compilation (testing)\n-XX:CompileThreshold=1000   // Compile after N invocations\n*/"
        },
        {
          "name": "‚úÖ Memory Access Patterns",
          "text": "**Usage:** Optimize memory access patterns for CPU cache efficiency to achieve 5-20x performance improvements.\n\n**Gains:**\n‚Ä¢ **Cache-Friendly Access:** 5-20x faster than cache-missing patterns\n‚Ä¢ **Sequential Access:** ~10GB/s vs ~500MB/s for random access (20x)\n‚Ä¢ **Object Pooling:** 10x reduction in GC pressure\n‚Ä¢ **Memory-Mapped Files:** 2-5x faster for large file operations\n\n**CPU Cache Hierarchy:**\n```\nL1 Cache:  ~1ns,    32-64KB   (per core)\nL2 Cache:  ~3ns,    256KB-1MB (per core)\nL3 Cache:  ~10ns,   8-32MB    (shared)\nRAM:       ~100ns,  GB+       (main memory)\n\nCache miss penalty: 100x slower!\n```\n\n**Access Pattern Impact:**\n```\nRow-major (cache-friendly):     1000ms\nColumn-major (cache-unfriendly): 5000ms\nDifference:                      5x slower\n```\n\n**Best Practices:**\n‚Ä¢ Sequential array access (not random)\n‚Ä¢ Process data in chunks that fit in cache\n‚Ä¢ Use primitive arrays over object arrays\n‚Ä¢ Consider data structure layout (AoS vs SoA)\n‚Ä¢ Pool frequently allocated objects",
          "code": "import java.nio.*;\nimport java.nio.file.*;\nimport java.io.*;\nimport java.util.*;\n\n// === Cache-Friendly vs Cache-Unfriendly ===\npublic class CacheOptimization {\n    \n    // Row-major: FAST (cache-friendly)\n    public static long sumRowMajor(int[][] matrix) {\n        long sum = 0;\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[i].length; j++) {\n                sum += matrix[i][j]; // Sequential access\n            }\n        }\n        return sum;\n    }\n    \n    // Column-major: SLOW (5x slower, cache misses)\n    public static long sumColumnMajor(int[][] matrix) {\n        long sum = 0;\n        for (int j = 0; j < matrix[0].length; j++) {\n            for (int i = 0; i < matrix.length; i++) {\n                sum += matrix[i][j]; // Random access\n            }\n        }\n        return sum;\n    }\n}\n\n// === Object Pooling ===\npublic class ObjectPool<T> {\n    private final Queue<T> pool = new ArrayDeque<>();\n    private final java.util.function.Supplier<T> factory;\n    private final int maxSize;\n    \n    public ObjectPool(java.util.function.Supplier<T> factory, int maxSize) {\n        this.factory = factory;\n        this.maxSize = maxSize;\n    }\n    \n    public T acquire() {\n        T obj = pool.poll();\n        return obj != null ? obj : factory.get();\n    }\n    \n    public void release(T obj) {\n        if (pool.size() < maxSize) {\n            pool.offer(obj);\n        }\n    }\n}\n\n// Usage\nclass ByteBufferPool {\n    private static final ObjectPool<ByteBuffer> pool = \n        new ObjectPool<>(() -> ByteBuffer.allocate(8192), 100);\n    \n    public static void processData(byte[] data) {\n        ByteBuffer buffer = pool.acquire();\n        try {\n            buffer.clear();\n            buffer.put(data);\n            // Process buffer...\n        } finally {\n            pool.release(buffer);\n        }\n    }\n}\n\n// === Memory-Mapped Files (2-5x faster) ===\npublic class MemoryMappedFileExample {\n    \n    // Traditional I/O - slower\n    public static void readTraditional(String path) throws IOException {\n        try (FileInputStream fis = new FileInputStream(path)) {\n            byte[] buffer = new byte[8192];\n            while (fis.read(buffer) != -1) {\n                // Process buffer\n            }\n        }\n    }\n    \n    // Memory-mapped - 2-5x faster for large files\n    public static void readMemoryMapped(String path) throws IOException {\n        try (var channel = FileChannel.open(Paths.get(path), \n                                           StandardOpenOption.READ)) {\n            \n            MappedByteBuffer buffer = channel.map(\n                FileChannel.MapMode.READ_ONLY, 0, channel.size());\n            \n            // Direct memory access - very fast\n            while (buffer.hasRemaining()) {\n                byte b = buffer.get();\n                // Process byte\n            }\n        }\n    }\n}\n\n// === Primitive Arrays vs Object Arrays ===\npublic class ArrayComparison {\n    \n    // FAST: Primitive array (compact, cache-friendly)\n    public static long sumPrimitive(int[] array) {\n        long sum = 0;\n        for (int value : array) {\n            sum += value; // Direct access, no indirection\n        }\n        return sum;\n    }\n    \n    // SLOW: Object array (3x slower, cache-unfriendly)\n    public static long sumObjects(Integer[] array) {\n        long sum = 0;\n        for (Integer value : array) {\n            sum += value; // Pointer indirection, boxing overhead\n        }\n        return sum;\n    }\n}\n\n// === Data Structure Layout ===\n// Array of Structures (AoS) - object-oriented\nclass AoS {\n    static class Point {\n        int x, y, z;\n    }\n    Point[] points = new Point[1000];\n}\n\n// Structure of Arrays (SoA) - cache-friendly\nclass SoA {\n    int[] x = new int[1000];\n    int[] y = new int[1000];\n    int[] z = new int[1000];\n    \n    // Process all X values together (better cache utilization)\n    public void processX() {\n        for (int i = 0; i < x.length; i++) {\n            x[i] *= 2;\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "functional",
      "title": "üîÑ Functional Programming",
      "sections": [
        {
          "name": "‚úÖ Advanced Stream Operations",
          "text": "**Usage:** Master advanced stream operations for complex data transformations and efficient parallel processing.\n\n**Gains:**\n‚Ä¢ **Custom Collectors:** 2-5x faster than multiple stream operations\n‚Ä¢ **Parallel Streams:** Near-linear speedup with CPU cores (for CPU-bound tasks)\n‚Ä¢ **Lazy Evaluation:** Process only needed elements (infinite streams)\n‚Ä¢ **Composability:** Chain operations for readable, maintainable code\n\n**Performance:**\n```\nSequential stream:   1000ms (1 core)\nParallel stream:     150ms (8 cores)\nSpeedup:            6.7x faster\n```\n\n**When to Use Parallel:**\n‚Ä¢ Large datasets (>10,000 elements)\n‚Ä¢ CPU-bound operations (not I/O)\n‚Ä¢ Independent operations (no shared state)\n‚Ä¢ Cost of parallelization < benefit\n\n**When NOT to Use:**\n‚Ä¢ Small datasets (<1000 elements)\n‚Ä¢ I/O operations (use async instead)\n‚Ä¢ Operations have side effects\n‚Ä¢ Ordered processing required",
          "code": "import java.util.*;\nimport java.util.stream.*;\nimport java.util.function.*;\n\n// === Custom Collector (Top N) ===\npublic class CustomCollectors {\n    \n    // Collect top N elements efficiently\n    public static <T> Collector<T, ?, List<T>> topN(\n            int n, Comparator<? super T> comparator) {\n        \n        return Collector.of(\n            () -> new PriorityQueue<>(n, comparator.reversed()),\n            (queue, elem) -> {\n                queue.offer(elem);\n                if (queue.size() > n) {\n                    queue.poll();\n                }\n            },\n            (q1, q2) -> {\n                q2.forEach(q1::offer);\n                return q1;\n            },\n            queue -> {\n                List<T> result = new ArrayList<>(queue);\n                result.sort(comparator);\n                return result;\n            }\n        );\n    }\n    \n    // Usage\n    public static void demo() {\n        List<Integer> numbers = IntStream.range(1, 100)\n            .boxed()\n            .collect(Collectors.toList());\n        \n        List<Integer> top10 = numbers.stream()\n            .collect(topN(10, Comparator.naturalOrder()));\n        \n        System.out.println(\"Top 10: \" + top10);\n    }\n}\n\n// === Parallel Streams with Custom Thread Pool ===\npublic class ParallelStreamExample {\n    \n    public static void processParallel(List<String> data) {\n        ForkJoinPool customPool = new ForkJoinPool(4);\n        \n        try {\n            customPool.submit(() -> \n                data.parallelStream()\n                    .map(String::toUpperCase)\n                    .filter(s -> s.length() > 5)\n                    .collect(Collectors.toList())\n            ).get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            customPool.shutdown();\n        }\n    }\n}\n\n// === Exception Handling in Streams ===\npublic class StreamExceptions {\n    \n    @FunctionalInterface\n    interface ThrowingFunction<T, R> {\n        R apply(T t) throws Exception;\n    }\n    \n    // Wrapper to handle checked exceptions\n    public static <T, R> Function<T, R> unchecked(\n            ThrowingFunction<T, R> f) {\n        return t -> {\n            try {\n                return f.apply(t);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        };\n    }\n    \n    // Usage\n    public static void demo(List<String> filePaths) {\n        List<String> contents = filePaths.stream()\n            .map(unchecked(Files::readString))\n            .collect(Collectors.toList());\n    }\n}\n\n// === Infinite Streams ===\npublic class InfiniteStreams {\n    \n    // Generate Fibonacci sequence\n    public static Stream<Long> fibonacci() {\n        return Stream.iterate(\n            new long[]{0, 1},\n            arr -> new long[]{arr[1], arr[0] + arr[1]}\n        ).map(arr -> arr[0]);\n    }\n    \n    // Usage\n    public static void demo() {\n        // Take only first 20 Fibonacci numbers\n        List<Long> fibs = fibonacci()\n            .limit(20)\n            .collect(Collectors.toList());\n        \n        System.out.println(fibs);\n    }\n}\n\n// === Complex Grouping ===\npublic class ComplexGrouping {\n    \n    record Employee(String dept, String name, double salary) {}\n    \n    public static void groupingDemo(List<Employee> employees) {\n        // Average salary by department\n        Map<String, Double> avgSalaryByDept = employees.stream()\n            .collect(Collectors.groupingBy(\n                Employee::dept,\n                Collectors.averagingDouble(Employee::salary)\n            ));\n        \n        // Top 3 earners per department\n        Map<String, List<Employee>> top3ByDept = employees.stream()\n            .collect(Collectors.groupingBy(\n                Employee::dept,\n                Collectors.collectingAndThen(\n                    Collectors.toList(),\n                    list -> list.stream()\n                        .sorted(Comparator.comparing(Employee::salary).reversed())\n                        .limit(3)\n                        .toList()\n                )\n            ));\n    }\n}"
        },
        {
          "name": "‚úÖ CompletableFuture & Reactive",
          "text": "**Usage:** Build non-blocking, asynchronous applications with CompletableFuture for better resource utilization and scalability.\n\n**Gains:**\n‚Ä¢ **100x Scalability:** 10,000+ concurrent operations vs 100 with blocking\n‚Ä¢ **Better Resource Utilization:** Non-blocking I/O frees threads\n‚Ä¢ **Composability:** Chain async operations declaratively\n‚Ä¢ **Error Handling:** Unified exception handling across async operations\n\n**Performance:**\n```\nBlocking I/O:      100 concurrent users\nNon-blocking:      10,000+ concurrent users\nImprovement:       100x better scalability\n```\n\n**Patterns:**\n1. **Sequential Chaining:** thenCompose, thenApply\n2. **Parallel Execution:** allOf, anyOf\n3. **Error Recovery:** exceptionally, handle\n4. **Timeout:** orTimeout, completeOnTimeout (Java 9+)\n\n**When to Use:**\n‚Ä¢ I/O-bound operations (network, database, files)\n‚Ä¢ Multiple independent async calls\n‚Ä¢ Need to compose async operations\n‚Ä¢ High concurrency requirements",
          "code": "import java.util.concurrent.*;\nimport java.util.*;\nimport java.time.Duration;\n\n// === Basic CompletableFuture ===\npublic class CompletableFutureBasics {\n    \n    // Async execution\n    public static CompletableFuture<String> fetchUserAsync(int userId) {\n        return CompletableFuture.supplyAsync(() -> {\n            // Simulate API call\n            sleep(1000);\n            return \"User\" + userId;\n        });\n    }\n    \n    // Chaining\n    public static CompletableFuture<String> getUserDetails(int userId) {\n        return fetchUserAsync(userId)\n            .thenApply(user -> user.toUpperCase())\n            .thenApply(user -> \"Details: \" + user);\n    }\n    \n    // Sequential composition\n    public static CompletableFuture<String> fetchUserAndOrders(int userId) {\n        return fetchUserAsync(userId)\n            .thenCompose(user -> fetchOrdersAsync(user));\n    }\n    \n    private static CompletableFuture<String> fetchOrdersAsync(String user) {\n        return CompletableFuture.supplyAsync(() -> {\n            sleep(500);\n            return user + \"'s orders\";\n        });\n    }\n}\n\n// === Parallel Execution ===\npublic class ParallelAsync {\n    \n    public static CompletableFuture<Map<String, Object>> fetchAllData(int userId) {\n        CompletableFuture<String> userFuture = fetchUser(userId);\n        CompletableFuture<List<String>> ordersFuture = fetchOrders(userId);\n        CompletableFuture<String> profileFuture = fetchProfile(userId);\n        \n        // Wait for all to complete\n        return CompletableFuture.allOf(userFuture, ordersFuture, profileFuture)\n            .thenApply(v -> Map.of(\n                \"user\", userFuture.join(),\n                \"orders\", ordersFuture.join(),\n                \"profile\", profileFuture.join()\n            ));\n    }\n    \n    // First to complete wins\n    public static CompletableFuture<String> fetchFromMultipleSources() {\n        CompletableFuture<String> source1 = fetchFromSource1();\n        CompletableFuture<String> source2 = fetchFromSource2();\n        CompletableFuture<String> source3 = fetchFromSource3();\n        \n        return CompletableFuture.anyOf(source1, source2, source3)\n            .thenApply(result -> (String) result);\n    }\n    \n    private static CompletableFuture<String> fetchUser(int id) { return null; }\n    private static CompletableFuture<List<String>> fetchOrders(int id) { return null; }\n    private static CompletableFuture<String> fetchProfile(int id) { return null; }\n    private static CompletableFuture<String> fetchFromSource1() { return null; }\n    private static CompletableFuture<String> fetchFromSource2() { return null; }\n    private static CompletableFuture<String> fetchFromSource3() { return null; }\n}\n\n// === Error Handling ===\npublic class AsyncErrorHandling {\n    \n    public static CompletableFuture<String> fetchWithFallback(int userId) {\n        return CompletableFuture.supplyAsync(() -> {\n            if (userId < 0) {\n                throw new IllegalArgumentException(\"Invalid user ID\");\n            }\n            return \"User\" + userId;\n        })\n        .exceptionally(ex -> {\n            System.err.println(\"Error: \" + ex.getMessage());\n            return \"DefaultUser\"; // Fallback value\n        });\n    }\n    \n    // Handle both success and failure\n    public static CompletableFuture<String> fetchWithHandle(int userId) {\n        return CompletableFuture.supplyAsync(() -> fetchData(userId))\n            .handle((result, ex) -> {\n                if (ex != null) {\n                    return \"Error: \" + ex.getMessage();\n                }\n                return \"Success: \" + result;\n            });\n    }\n    \n    private static String fetchData(int id) { return \"data\"; }\n}\n\n// === Timeout & Circuit Breaker ===\npublic class AsyncTimeout {\n    \n    // Timeout after 2 seconds (Java 9+)\n    public static CompletableFuture<String> fetchWithTimeout(int userId) {\n        return CompletableFuture.supplyAsync(() -> {\n            sleep(5000); // Slow operation\n            return \"User\" + userId;\n        })\n        .orTimeout(2, TimeUnit.SECONDS)\n        .exceptionally(ex -> \"Timeout!\");\n    }\n    \n    // Fallback on timeout\n    public static CompletableFuture<String> fetchWithTimeoutFallback(int userId) {\n        return CompletableFuture.supplyAsync(() -> {\n            sleep(5000);\n            return \"User\" + userId;\n        })\n        .completeOnTimeout(\"CachedUser\" + userId, 2, TimeUnit.SECONDS);\n    }\n}\n\nprivate static void sleep(long ms) {\n    try { Thread.sleep(ms); } \n    catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n}"
        }
      ]
    }
  ]
}