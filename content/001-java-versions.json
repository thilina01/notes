{
  "config": {
    "id": "java-versions",
    "name": "Java Versions",
    "description": "Java Programming Language & Ecosystem - Comprehensive Feature Guide",
    "icon": "‚òï",
    "enabled": true
  },
  "content": [
    {
      "id": "8",
      "title": "üß© Java 8 (2014) ‚Äî Functional Revolution",
      "sections": [
        {
          "name": "‚úÖ Lambda Expressions",
          "text": "**Usage:** Replace anonymous inner classes with concise functional syntax for cleaner, more readable code.\n\n**Gains:**\n‚Ä¢ **Conciseness:** Reduces boilerplate code by ~70% compared to anonymous classes\n‚Ä¢ **Better Readability:** Focus on business logic rather than ceremony\n‚Ä¢ **Faster JVM Startup:** No separate .class files generated (unlike inner classes)\n‚Ä¢ **Parallel Processing:** Easy integration with Stream API for multi-core utilization\n‚Ä¢ **Functional Programming:** Enables passing behavior as data, code reuse through variables",
          "code": "// Before Java 8 - Anonymous Inner Class\nList<String> names = Arrays.asList(\"Thilina\", \"Sara\", \"Maya\");\nnames.forEach(new Consumer<String>() {\n    public void accept(String n) {\n        System.out.println(\"Hello, \" + n);\n    }\n});\n\n// After Java 8 - Lambda Expression\nnames.forEach(n -> System.out.println(\"Hello, \" + n));\n\n// Lambda with type inference\nPredicate<String> notEmpty = s -> !s.isEmpty();\n\n// Lambda as variable (reusable)\nBiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;\nSystem.out.println(add.apply(10, 20)); // 30"
        },
        {
          "name": "‚úÖ Stream API",
          "text": "**Usage:** Process collections declaratively with functional-style operations like filter, map, and reduce.\n\n**Gains:**\n‚Ä¢ **Declarative Code:** Express what to do, not how to do it\n‚Ä¢ **Lazy Evaluation:** Only processes elements when terminal operation is called\n‚Ä¢ **Parallel Processing:** Easy parallelization with .parallelStream()\n‚Ä¢ **No Intermediate Collections:** Efficient memory usage, no temporary lists\n‚Ä¢ **Composable Operations:** Chain multiple operations for complex transformations\n‚Ä¢ **Better Performance:** Optimized internally, especially for large datasets",
          "code": "// Filter odd numbers, square them, and sum\nint sum = List.of(1, 2, 3, 4, 5)\n              .stream()\n              .filter(n -> n % 2 == 1)      // Only odd numbers\n              .mapToInt(n -> n * n)         // Square them\n              .sum();                        // Sum result\nSystem.out.println(sum); // 35 (1 + 9 + 25)\n\n// Parallel processing for large datasets\nList<String> result = bigList.parallelStream()\n    .filter(s -> s.length() > 5)\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());"
        },
        {
          "name": "‚úÖ Functional Interfaces",
          "text": "**Usage:** Single abstract method interfaces that work seamlessly with lambda expressions.\n\n**Gains:**\n‚Ä¢ **Lambda Compatibility:** Target type for lambda expressions\n‚Ä¢ **Code Reusability:** Pass behavior as parameters to methods\n‚Ä¢ **Built-in Interfaces:** Predicate, Function, Consumer, Supplier for common patterns\n‚Ä¢ **Type Safety:** Compile-time checking for functional contracts",
          "code": "// Predicate - boolean test\nPredicate<String> notEmpty = s -> !s.isEmpty();\nSystem.out.println(notEmpty.test(\"Java\")); // true\n\n// Function - transform input to output\nFunction<String, Integer> length = s -> s.length();\nSystem.out.println(length.apply(\"Hello\")); // 5\n\n// Consumer - accept input, no return\nConsumer<String> print = s -> System.out.println(s);\nprint.accept(\"Java 8\");\n\n// Custom functional interface\n@FunctionalInterface\ninterface Calculator {\n    int calculate(int a, int b);\n}\nCalculator multiply = (a, b) -> a * b;"
        },
        {
          "name": "‚úÖ Default & Static Methods in Interfaces",
          "text": "**Usage:** Add new methods to interfaces without breaking existing implementations.\n\n**Gains:**\n‚Ä¢ **Backward Compatibility:** Evolve interfaces without breaking clients\n‚Ä¢ **Code Reuse:** Share common logic across implementations\n‚Ä¢ **Multiple Inheritance:** Compose behavior from multiple interfaces\n‚Ä¢ **Static Utilities:** Interface-level helper methods",
          "code": "interface Greeting {\n    // Default method - can be overridden\n    default void sayHello() { \n        System.out.println(\"Hello!\"); \n    }\n\n    // Static method - interface-level utility\n    static void info() { \n        System.out.println(\"Static method in interface.\"); \n    }\n\n    // Private helper (Java 9+)\n    private void logMessage(String msg) {\n        System.out.println(\"LOG: \" + msg);\n    }\n}\n\nclass Person implements Greeting {\n    // Inherits sayHello() automatically\n}\n\nnew Person().sayHello(); // Hello!\nGreeting.info();         // Static method in interface."
        },
        {
          "name": "‚úÖ Optional",
          "text": "**Usage:** Explicit handling of potentially null values to avoid NullPointerException.\n\n**Gains:**\n‚Ä¢ **Null Safety:** Makes null handling explicit and intentional\n‚Ä¢ **Expressive API:** Fluent methods for common null-check patterns\n‚Ä¢ **Better Documentation:** Method signatures show optional values clearly\n‚Ä¢ **Stream Integration:** Works seamlessly with Stream API\n‚Ä¢ **Functional Style:** Chain operations with map, flatMap, filter",
          "code": "// Create Optional\nOptional<String> name = Optional.ofNullable(getUserName());\n\n// Provide default value\nString result = name.orElse(\"Unknown\");\n\n// Execute only if present\nname.ifPresent(n -> System.out.println(\"Hello, \" + n));\n\n// Transform value if present\nOptional<Integer> length = name.map(String::length);\n\n// Chain with flatMap\nOptional<String> email = getUserById(id)\n    .flatMap(User::getEmail)\n    .filter(e -> e.contains(\"@\"))\n    .map(String::toLowerCase);\n\n// Get or throw custom exception\nString value = name.orElseThrow(() -> \n    new IllegalStateException(\"Name required\"));"
        },
        {
          "name": "‚úÖ Date and Time API",
          "text": "**Usage:** Modern, immutable, and thread-safe date-time handling replacing old Date/Calendar.\n\n**Gains:**\n‚Ä¢ **Immutability:** Thread-safe, no unexpected mutations\n‚Ä¢ **Clear API:** Separate classes for date, time, and timestamp\n‚Ä¢ **Time Zone Support:** Proper handling of zones and offsets\n‚Ä¢ **Fluent Interface:** Easy date arithmetic and manipulation\n‚Ä¢ **ISO-8601 Standard:** Industry-standard date-time formatting",
          "code": "// Current date and time\nLocalDate today = LocalDate.now();\nLocalTime now = LocalTime.now();\nLocalDateTime dateTime = LocalDateTime.now();\n\n// Date arithmetic\nLocalDate nextWeek = today.plusWeeks(1);\nLocalDate lastMonth = today.minusMonths(1);\n\n// Specific date\nLocalDate birthday = LocalDate.of(1990, Month.JANUARY, 15);\n\n// Time zone handling\nZonedDateTime utcNow = ZonedDateTime.now(ZoneId.of(\"UTC\"));\nZonedDateTime dubai = utcNow.withZoneSameInstant(\n    ZoneId.of(\"Asia/Dubai\"));\n\n// Period between dates\nPeriod age = Period.between(birthday, today);\nSystem.out.println(\"Age: \" + age.getYears() + \" years\");"
        },
        {
          "name": "‚úÖ Parallel Streams",
          "text": "**Usage:** Leverage multi-core processors for parallel data processing with minimal code changes.\n\n**Gains:**\n‚Ä¢ **Easy Parallelization:** Single method call to enable parallel processing\n‚Ä¢ **Automatic Thread Management:** JVM handles thread pool automatically\n‚Ä¢ **Performance Boost:** Significant speedup for CPU-intensive operations\n‚Ä¢ **Same API:** No code changes needed beyond .parallel() or .parallelStream()",
          "code": "// Sequential processing\nlong count = IntStream.range(1, 1_000_000)\n    .filter(n -> isPrime(n))\n    .count();\n\n// Parallel processing - utilizes all CPU cores\nlong countParallel = IntStream.range(1, 1_000_000)\n    .parallel()\n    .filter(n -> isPrime(n))\n    .count();\n\n// Parallel forEach\nList<String> urls = getUrls();\nurls.parallelStream()\n    .forEach(url -> processUrl(url));"
        }
      ]
    },
    {
      "id": "9",
      "title": "üß± Java 9 (2017) ‚Äî Modularity & Tooling",
      "sections": [
        {
          "name": "‚úÖ Java Platform Module System (JPMS)",
          "text": "**Usage:** Organize code into modules with explicit dependencies for better encapsulation and smaller runtimes.\n\n**Gains:**\n‚Ä¢ **Strong Encapsulation:** Control which packages are accessible to other modules\n‚Ä¢ **Smaller Runtimes:** Create custom JRE with only needed modules (reduced footprint by ~90%)\n‚Ä¢ **Better Dependency Management:** Explicit module dependencies, resolve conflicts at compile-time\n‚Ä¢ **Improved Performance:** Faster startup time and reduced memory usage\n‚Ä¢ **Enhanced Security:** Limit access to internal APIs",
          "code": "// module-info.java\nmodule com.example.myapp {\n    // Dependencies\n    requires java.sql;\n    requires java.logging;\n\n    // Export packages\n    exports com.example.myapp.api;\n\n    // Provide service\n    provides com.example.Service \n        with com.example.ServiceImpl;\n}\n\n// Create custom runtime (reduced size)\njlink --module-path $JAVA_HOME/jmods:mods \\\n      --add-modules com.example.myapp \\\n      --output custom-jre"
        },
        {
          "name": "‚úÖ Improved Streams API (takeWhile/dropWhile)",
          "text": "**Usage:** Process stream elements conditionally until/after a predicate becomes false.\n\n**Gains:**\n‚Ä¢ **Early Termination:** Stop processing when condition fails (better performance)\n‚Ä¢ **Expressive Code:** Clearly express intent for conditional streaming\n‚Ä¢ **Memory Efficient:** Doesn't process unnecessary elements\n‚Ä¢ **Ordered Processing:** Works on sequential or parallel streams",
          "code": "// takeWhile - take elements while condition is true\nStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)\n      .takeWhile(n -> n < 5)\n      .forEach(System.out::print); // 1234\n\n// dropWhile - drop elements while condition is true\nStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)\n      .dropWhile(n -> n < 5)\n      .forEach(System.out::print); // 56789\n\n// Use case: Process until empty line\nFiles.lines(Path.of(\"file.txt\"))\n     .takeWhile(line -> !line.isEmpty())\n     .forEach(System.out::println);"
        },
        {
          "name": "‚úÖ Private Methods in Interfaces",
          "text": "**Usage:** Share code between default methods without exposing helper methods to implementers.\n\n**Gains:**\n‚Ä¢ **Code Reusability:** Avoid duplication in default methods\n‚Ä¢ **Better Encapsulation:** Keep helper methods private to interface\n‚Ä¢ **Cleaner API:** Don't expose implementation details\n‚Ä¢ **Maintainability:** Centralize common logic in one place",
          "code": "interface Calculator {\n    default int addEvenNumbers(int... nums) {\n        return add(n -> n % 2 == 0, nums);\n    }\n\n    default int addOddNumbers(int... nums) {\n        return add(n -> n % 2 != 0, nums);\n    }\n\n    // Private helper method - shared logic\n    private int add(IntPredicate predicate, int... nums) {\n        return IntStream.of(nums)\n                        .filter(predicate)\n                        .sum();\n    }\n}\n\nclass MyCalc implements Calculator {}\nMyCalc calc = new MyCalc();\nSystem.out.println(calc.addEvenNumbers(1,2,3,4,5,6)); // 12"
        },
        {
          "name": "‚úÖ Factory Methods for Collections",
          "text": "**Usage:** Create immutable collections with concise factory methods.\n\n**Gains:**\n‚Ä¢ **Immutability:** Thread-safe, cannot be modified after creation\n‚Ä¢ **Concise Syntax:** No need for verbose initialization code\n‚Ä¢ **Better Performance:** Optimized internal representation\n‚Ä¢ **Null-Safe:** Doesn't allow null elements (fails fast)",
          "code": "// Immutable List\nList<String> list = List.of(\"A\", \"B\", \"C\");\n// list.add(\"D\"); // UnsupportedOperationException\n\n// Immutable Set\nSet<Integer> set = Set.of(1, 2, 3, 4, 5);\n\n// Immutable Map\nMap<String, Integer> map = Map.of(\n    \"one\", 1,\n    \"two\", 2,\n    \"three\", 3\n);\n\n// Larger maps with entries\nMap<String, String> largeMap = Map.ofEntries(\n    Map.entry(\"key1\", \"value1\"),\n    Map.entry(\"key2\", \"value2\")\n);"
        }
      ]
    },
    {
      "id": "10",
      "title": "üîç Java 10 (2018) ‚Äî Local Variable Type Inference",
      "sections": [
        {
          "name": "‚úÖ Local Variable Type Inference (var)",
          "text": "**Usage:** Let the compiler infer local variable types for cleaner, more readable code.\n\n**Gains:**\n‚Ä¢ **Reduced Boilerplate:** Less repetitive type declarations, especially with generics\n‚Ä¢ **Better Readability:** Focus on variable names and logic, not types\n‚Ä¢ **Easier Refactoring:** Change types without updating all declarations\n‚Ä¢ **Familiar Syntax:** Similar to JavaScript, TypeScript, C#, Kotlin\n‚Ä¢ **Compile-Time Safety:** Still strongly typed, not dynamic typing\n\n**Limitations:**\n‚Ä¢ Only for local variables with initializers\n‚Ä¢ Cannot use with method parameters, return types, or fields\n‚Ä¢ Cannot initialize with null (ambiguous type)\n‚Ä¢ Not for lambda expressions (need explicit target type)",
          "code": "// Before Java 10 - verbose generics\nMap<String, List<String>> companyToEmployees = new HashMap<>();\nfor (Map.Entry<String, List<String>> entry : companyToEmployees.entrySet()) {\n    List<String> employees = entry.getValue();\n}\n\n// With Java 10 var - cleaner and concise\nvar companyToEmployees = new HashMap<String, List<String>>();\nfor (var entry : companyToEmployees.entrySet()) {\n    var employees = entry.getValue();\n}\n\n// Simple types\nvar list = List.of(\"Java\", \"10\", \"var\");\nvar map = Map.of(\"key\", \"value\");\nvar stream = list.stream();\n\n// Still compile-time type checking\nvar number = 10;\n// number = \"string\"; // Compile error!"
        }
      ]
    },
    {
      "id": "11",
      "title": "üß∞ Java 11 (2018 LTS) ‚Äî Modernization & LTS",
      "sections": [
        {
          "name": "‚úÖ New HttpClient API",
          "text": "**Usage:** Modern, feature-rich HTTP client with HTTP/2 support, async operations, and clean API.\n\n**Gains:**\n‚Ä¢ **HTTP/2 Support:** Better performance with multiplexing and server push\n‚Ä¢ **Async Operations:** Non-blocking I/O with CompletableFuture\n‚Ä¢ **WebSocket Support:** Built-in WebSocket client\n‚Ä¢ **Clean Builder API:** Fluent, readable request/response handling\n‚Ä¢ **Better Performance:** 4-5x faster than legacy HttpURLConnection\n‚Ä¢ **No External Dependencies:** Built into JDK (no Apache HttpClient needed)",
          "code": "// Create HTTP client (reusable, thread-safe)\nvar client = HttpClient.newBuilder()\n    .version(HttpClient.Version.HTTP_2)\n    .connectTimeout(Duration.ofSeconds(10))\n    .build();\n\n// Synchronous GET request\nvar request = HttpRequest.newBuilder()\n    .uri(URI.create(\"https://api.example.com/users\"))\n    .header(\"Accept\", \"application/json\")\n    .build();\n\nvar response = client.send(request, HttpResponse.BodyHandlers.ofString());\nSystem.out.println(response.statusCode());\nSystem.out.println(response.body());\n\n// Asynchronous request\nclient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n      .thenApply(HttpResponse::body)\n      .thenAccept(System.out::println);\n\n// POST with JSON\nvar postRequest = HttpRequest.newBuilder()\n    .uri(URI.create(\"https://api.example.com/users\"))\n    .header(\"Content-Type\", \"application/json\")\n    .POST(HttpRequest.BodyPublishers.ofString(\"{\\\"name\\\":\\\"John\\\"}\"))\n    .build();"
        },
        {
          "name": "‚úÖ String Enhancements (isBlank, strip, lines)",
          "text": "**Usage:** New methods for common string operations with Unicode support.\n\n**Gains:**\n‚Ä¢ **Unicode Support:** strip() handles all Unicode whitespace (trim() only handles ASCII ‚â§32)\n‚Ä¢ **Expressive API:** Clear intent with isBlank(), lines()\n‚Ä¢ **Stream Integration:** lines() returns Stream for functional processing\n‚Ä¢ **Better Performance:** Optimized implementations",
          "code": "String text = \"  Java 11  \";\n\n// isBlank() - checks for empty or only whitespace\nSystem.out.println(text.isBlank());        // false\nSystem.out.println(\"   \".isBlank());       // true\nSystem.out.println(\"\".isBlank());          // true\n\n// strip() - removes leading and trailing whitespace (Unicode-aware)\nSystem.out.println(text.strip());          // \"Java 11\"\nSystem.out.println(text.stripLeading());   // \"Java 11  \"\nSystem.out.println(text.stripTrailing());  // \"  Java 11\"\n\n// lines() - split by line terminators, returns Stream\nString multiline = \"Line 1\\nLine 2\\nLine 3\";\nlong count = multiline.lines().count();    // 3\nmultiline.lines()\n         .map(String::toUpperCase)\n         .forEach(System.out::println);\n\n// repeat() - repeat string n times\nString repeated = \"Java\".repeat(3);        // \"JavaJavaJava\""
        }
      ]
    },
    {
      "id": "14",
      "title": "üí° Java 14 (2020) ‚Äî Expressive Code",
      "sections": [
        {
          "name": "‚úÖ Switch Expressions (Standard)",
          "text": "**Usage:** Use switch as an expression that returns a value, with no fall-through and exhaustiveness checking.\n\n**Gains:**\n‚Ä¢ **Returns Values:** Switch can be assigned to variables\n‚Ä¢ **No break Statements:** Arrow syntax (->) prevents fall-through bugs\n‚Ä¢ **Exhaustiveness:** Compiler ensures all cases are covered\n‚Ä¢ **Multiple Labels:** Combine multiple case labels with comma\n‚Ä¢ **Cleaner Code:** Reduces boilerplate and potential bugs by ~50%\n‚Ä¢ **yield Keyword:** Explicitly return values from code blocks",
          "code": "// Switch expression with arrow syntax\nString day = \"SAT\";\nString type = switch (day) {\n    case \"SAT\", \"SUN\" -> \"Weekend\";\n    case \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\" -> \"Weekday\";\n    default -> \"Unknown\";\n};\nSystem.out.println(type); // Weekend\n\n// With yield for code blocks\nint numLetters = switch (day) {\n    case \"SAT\", \"SUN\" -> {\n        System.out.println(\"Weekend day\");\n        yield 6;\n    }\n    case \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\" -> {\n        System.out.println(\"Weekday\");\n        yield 7;\n    }\n    default -> 0;\n};"
        }
      ]
    },
    {
      "id": "15",
      "title": "üß¨ Java 15 (2020) ‚Äî Syntax Modernization",
      "sections": [
        {
          "name": "‚úÖ Text Blocks",
          "text": "**Usage:** Multi-line string literals for HTML, JSON, SQL without escape sequences and concatenation.\n\n**Gains:**\n‚Ä¢ **No Escape Sequences:** No need for \\n, \\\", \\\\ in multi-line strings\n‚Ä¢ **Better Readability:** See actual format of text (HTML, JSON, SQL)\n‚Ä¢ **Easier Maintenance:** Spot syntax errors easily (missing quotes, commas)\n‚Ä¢ **No Concatenation:** No + operators for multi-line strings\n‚Ä¢ **Automatic Indentation:** Intelligent whitespace handling\n‚Ä¢ **Syntax Highlighting:** IDEs can highlight embedded languages",
          "code": "// HTML with text blocks - clean and readable\nString html = \"\"\"\n    <html>\n      <body>\n        <h1>Hello World!</h1>\n      </body>\n    </html>\n    \"\"\";\n\n// JSON example\nString json = \"\"\"\n    {\n      \"name\": \"Thilina\",\n      \"role\": \"Lead Developer\",\n      \"skills\": [\"Java\", \"Spring\", \"Microservices\"]\n    }\n    \"\"\";\n\n// SQL query\nString sql = \"\"\"\n    SELECT id, name, email\n    FROM users\n    WHERE age > 18\n      AND status = 'active'\n    ORDER BY name\n    \"\"\";\n\n// String interpolation with formatted()\nString name = \"Alice\";\nString message = \"\"\"\n    Hello, %s!\n    Welcome to Java 15.\n    \"\"\".formatted(name);"
        }
      ]
    },
    {
      "id": "16",
      "title": "ü¶æ Java 16 (2021) ‚Äî Records Become Official",
      "sections": [
        {
          "name": "‚úÖ Records",
          "text": "**Usage:** Immutable data carriers with automatic constructor, getters, equals, hashCode, and toString.\n\n**Gains:**\n‚Ä¢ **Conciseness:** Define data class in one line (vs 50+ lines of POJO)\n‚Ä¢ **Immutability:** All fields are final by default (thread-safe)\n‚Ä¢ **Less Boilerplate:** No need to write getters, equals, hashCode, toString\n‚Ä¢ **Clear Intent:** Explicitly marks class as data holder\n‚Ä¢ **Pattern Matching:** Works seamlessly with pattern matching (Java 21+)\n‚Ä¢ **Compile-Time Validation:** Constructor validates components automatically",
          "code": "// Record definition - one line!\nrecord Point(int x, int y) {}\n\n// Using records\nPoint p = new Point(10, 20);\nSystem.out.println(p.x() + \", \" + p.y());  // 10, 20\nSystem.out.println(p);                      // Point[x=10, y=20]\n\n// Custom constructor with validation\nrecord Person(String name, int age) {\n    // Compact constructor\n    Person {\n        if (age < 0) {\n            throw new IllegalArgumentException(\"Age cannot be negative\");\n        }\n    }\n}\n\n// Records in collections\nList<Point> points = List.of(\n    new Point(0, 0),\n    new Point(10, 20),\n    new Point(5, 15)\n);"
        }
      ]
    },
    {
      "id": "17",
      "title": "üß† Java 17 (2021 LTS) ‚Äî Stability & Sealing",
      "sections": [
        {
          "name": "‚úÖ Sealed Classes",
          "text": "**Usage:** Restrict which classes can extend/implement a class/interface for controlled inheritance.\n\n**Gains:**\n‚Ä¢ **Controlled Inheritance:** Define exact set of permitted subclasses\n‚Ä¢ **Better Domain Modeling:** Accurately model fixed sets of possibilities\n‚Ä¢ **Exhaustiveness Checking:** Compiler ensures all cases handled in switch\n‚Ä¢ **Improved Security:** Prevent unauthorized extensions\n‚Ä¢ **Better Maintainability:** Clear hierarchy at compile time\n‚Ä¢ **Pattern Matching:** Works with switch pattern matching for type-safe code",
          "code": "// Sealed interface with permitted implementations\nsealed interface Shape permits Circle, Rectangle, Triangle {}\n\nfinal class Circle implements Shape {\n    double radius;\n}\n\nfinal class Rectangle implements Shape {\n    double width, height;\n}\n\nfinal class Triangle implements Shape {\n    double base, height;\n}\n\n// Exhaustive pattern matching (no default needed)\ndouble calculateArea(Shape shape) {\n    return switch (shape) {\n        case Circle c -> Math.PI * c.radius * c.radius;\n        case Rectangle r -> r.width * r.height;\n        case Triangle t -> 0.5 * t.base * t.height;\n        // No default needed - all cases covered!\n    };\n}"
        }
      ]
    },
    {
      "id": "18",
      "title": "‚ö° Java 18 (2022) ‚Äî Networking & UTF",
      "sections": [
        {
          "name": "‚úÖ Simple Web Server (jwebserver)",
          "text": "**Usage:** Built-in minimal HTTP server for prototyping, testing, and serving static files.\n\n**Gains:**\n‚Ä¢ **Zero Setup:** No installation, configuration, or dependencies\n‚Ä¢ **Quick Testing:** Instantly serve HTML, JSON, or files for testing\n‚Ä¢ **Prototyping:** Fast ad-hoc development and debugging\n‚Ä¢ **File Browsing:** Easy directory listing and file sharing\n‚Ä¢ **Programmatic API:** Can be embedded in applications\n\n**Use Cases:**\n‚Ä¢ Testing web applications during development\n‚Ä¢ Serving static files for demos\n‚Ä¢ Quick API endpoint mocking\n‚Ä¢ File sharing across systems",
          "code": "# Command line - start server in current directory\njwebserver\n# Serving /current/directory on http://127.0.0.1:8000\n\n# Custom port and directory\njwebserver --port 9000 --directory /path/to/files\n\n# Programmatic usage\nimport com.sun.net.httpserver.*;\n\nvar server = SimpleFileServer.createFileServer(\n    new InetSocketAddress(8080),\n    Path.of(\"/some/path\"),\n    SimpleFileServer.OutputLevel.VERBOSE\n);\nserver.start();\n\n// Custom file handler\nvar handler = SimpleFileServer.createFileHandler(Path.of(\"/path\"));\nvar server = HttpServer.create(new InetSocketAddress(8080), 10, \"/\", handler);\nserver.start();"
        },
        {
          "name": "‚úÖ UTF-8 by Default",
          "text": "**Usage:** UTF-8 is now the default charset for all Java APIs, ensuring consistent behavior across platforms.\n\n**Gains:**\n‚Ä¢ **Platform Independence:** Same behavior on Windows, Linux, macOS\n‚Ä¢ **Predictable Encoding:** No surprises from OS/locale settings\n‚Ä¢ **International Support:** Proper handling of all Unicode characters\n‚Ä¢ **Simpler Code:** No need to explicitly specify charset in most cases\n‚Ä¢ **Fewer Bugs:** Eliminates encoding-related issues\n\n**Note:** Console I/O (System.out/err) still uses native encoding",
          "code": "// Before Java 18 - encoding depended on OS/locale\nFileReader reader = new FileReader(\"file.txt\"); // Platform-dependent!\n\n// Java 18+ - UTF-8 by default\nFileReader reader = new FileReader(\"file.txt\"); // Always UTF-8\n\n// Reading files\nString content = Files.readString(Path.of(\"file.txt\")); // UTF-8\n\n// Writing files\nFiles.writeString(Path.of(\"output.txt\"), content); // UTF-8\n\n// Revert to old behavior if needed\n// java -Dfile.encoding=COMPAT MyApp\n\n// Get native encoding\nString nativeEncoding = System.getProperty(\"native.encoding\");\nSystem.out.println(nativeEncoding); // e.g., \"Cp1252\" on Windows"
        }
      ]
    },
    {
      "id": "21",
      "title": "üßµ Java 21 (2023 LTS) ‚Äî Big Leap Forward",
      "sections": [
        {
          "name": "‚úÖ Virtual Threads",
          "text": "**Usage:** Lightweight threads for high-concurrency applications without resource overhead.\n\n**Gains:**\n‚Ä¢ **Massive Scalability:** Millions of threads vs thousands of platform threads\n‚Ä¢ **Low Memory Overhead:** ~1KB per virtual thread vs ~1MB for platform thread\n‚Ä¢ **Simple Programming Model:** Keep thread-per-request model, no reactive complexity\n‚Ä¢ **Better Resource Utilization:** JVM manages thread scheduling efficiently\n‚Ä¢ **Backward Compatible:** Works with existing thread-based code\n‚Ä¢ **Faster Startup:** Reduced thread creation/destruction overhead",
          "code": "// Create and start virtual thread\nThread.startVirtualThread(() -> {\n    System.out.println(\"Running in: \" + Thread.currentThread());\n});\n\n// Executor for virtual threads\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    IntStream.range(0, 10_000).forEach(i ->\n        executor.submit(() -> {\n            // Each task runs in its own virtual thread\n            processRequest(i);\n        })\n    );\n} // Auto-shutdown\n\n// Compare: Platform thread pool (limited)\nvar platformPool = Executors.newFixedThreadPool(100); // Max 100\n\n// Virtual threads - millions possible\nvar virtualExecutor = Executors.newVirtualThreadPerTaskExecutor();\n\n// Builder API\nThread vThread = Thread.ofVirtual()\n    .name(\"virtual-worker\")\n    .unstarted(() -> doWork());\nvThread.start();"
        },
        {
          "name": "‚úÖ Record Patterns",
          "text": "**Usage:** Deconstruct records in pattern matching to access components directly.\n\n**Gains:**\n‚Ä¢ **Concise Extraction:** Access record components in one step\n‚Ä¢ **Nested Deconstruction:** Handle complex nested records elegantly\n‚Ä¢ **Type Safety:** Compile-time checking of patterns\n‚Ä¢ **Readable Code:** Clear intent for data extraction\n‚Ä¢ **Works with Switch:** Powerful combination with pattern matching switch",
          "code": "record Point(int x, int y) {}\n\n// Deconstruct in instanceof\nObject obj = new Point(5, 10);\nif (obj instanceof Point(int x, int y)) {\n    System.out.println(\"x=\" + x + \", y=\" + y); // Direct access\n}\n\n// Nested records\nrecord Name(String first, String last) {}\nrecord Person(Name name, int age) {}\n\nPerson person = new Person(new Name(\"John\", \"Doe\"), 30);\n\n// Nested pattern matching\nif (person instanceof Person(Name(var first, var last), var age)) {\n    System.out.println(first + \" \" + last + \" is \" + age);\n}\n\n// In switch expressions\nString describe(Object obj) {\n    return switch (obj) {\n        case Point(int x, int y) -> \"Point at (\" + x + \", \" + y + \")\";\n        case Person(Name(var f, var l), var a) -> f + \" \" + l + \", age \" + a;\n        default -> \"Unknown\";\n    };\n}"
        },
        {
          "name": "‚úÖ Pattern Matching for switch",
          "text": "**Usage:** Match patterns in switch statements/expressions including type patterns and guards.\n\n**Gains:**\n‚Ä¢ **Type Patterns:** Switch on types, not just constants\n‚Ä¢ **Null Handling:** Can include null cases explicitly\n‚Ä¢ **Guard Clauses:** Add conditions with when\n‚Ä¢ **Exhaustiveness:** Compiler ensures all types covered (with sealed classes)\n‚Ä¢ **Cleaner Code:** Replaces long if-else chains\n‚Ä¢ **Better Performance:** Potentially faster than if-else chains",
          "code": "// Type pattern matching in switch\nstatic String describe(Object obj) {\n    return switch (obj) {\n        case Integer i -> \"int: \" + i;\n        case String s -> \"string: \" + s;\n        case Point(int x, int y) -> \"Point(\" + x + \", \" + y + \")\";\n        case null -> \"null value\";\n        default -> \"unknown\";\n    };\n}\n\n// Guard clauses with when\nstatic String classify(Object obj) {\n    return switch (obj) {\n        case String s when s.length() > 10 -> \"Long string\";\n        case String s -> \"Short string\";\n        case Integer i when i > 0 -> \"Positive\";\n        case Integer i -> \"Non-positive\";\n        default -> \"Other\";\n    };\n}\n\n// With sealed classes - no default needed\nsealed interface Result permits Success, Error {}\nrecord Success(String data) implements Result {}\nrecord Error(String message) implements Result {}\n\nString handle(Result result) {\n    return switch (result) {\n        case Success(var data) -> \"Got: \" + data;\n        case Error(var msg) -> \"Error: \" + msg;\n        // No default - exhaustive!\n    };\n}"
        },
        {
          "name": "‚úÖ Sequenced Collections",
          "text": "**Usage:** Uniform API to access first/last elements and reverse iteration for ordered collections.\n\n**Gains:**\n‚Ä¢ **Consistent API:** Same methods across List, Deque, SortedSet, LinkedHashMap\n‚Ä¢ **Reverse Iteration:** Easy iteration in reverse order\n‚Ä¢ **First/Last Access:** Direct access to first and last elements\n‚Ä¢ **Better Readability:** Clear intent with getFirst(), getLast()\n‚Ä¢ **No Index Calculations:** No need for size()-1 tricks",
          "code": "// SequencedCollection methods\nSequencedSet<String> set = new LinkedHashSet<>();\nset.addFirst(\"first\");\nset.addLast(\"last\");\nset.add(\"middle\");\n\nSystem.out.println(set.getFirst());  // \"first\"\nSystem.out.println(set.getLast());   // \"last\"\n\n// Reverse iteration\nfor (String s : set.reversed()) {\n    System.out.println(s); // last, middle, first\n}\n\n// SequencedMap\nSequencedMap<String, Integer> map = new LinkedHashMap<>();\nmap.putFirst(\"a\", 1);\nmap.putLast(\"z\", 26);\n\nvar firstEntry = map.firstEntry();  // a=1\nvar lastEntry = map.lastEntry();    // z=26\n\n// Before Java 21 - awkward\nList<String> list = List.of(\"a\", \"b\", \"c\");\nString last = list.get(list.size() - 1); // Awkward!\n\n// Java 21 - clean\nString lastNew = list.getLast(); // Clean!"
        }
      ]
    },
    {
      "id": "22",
      "title": "üîÆ Java 22 (2024) ‚Äî Polish & Practical Power",
      "sections": [
        {
          "name": "‚úÖ Statements before super() in Constructors",
          "text": "**Usage:** Execute validation and preparation statements before calling super() or this() in constructors.\n\n**Gains:**\n‚Ä¢ **Cleaner Code:** No need for static helper methods to validate arguments\n‚Ä¢ **Better Validation:** Validate before passing to parent constructor\n‚Ä¢ **Argument Preparation:** Transform/prepare arguments before super() call\n‚Ä¢ **More Intuitive:** Natural flow of constructor logic\n‚Ä¢ **Works with Records:** Also applies to record compact constructors\n\n**Restrictions:**\n‚Ä¢ Cannot access instance members (this.field) before super()\n‚Ä¢ Cannot use unqualified 'this' expressions\n‚Ä¢ Can use static methods, local variables, parameters",
          "code": "class Parent {\n    Parent(int value) {\n        if (value < 0) throw new IllegalArgumentException();\n    }\n}\n\n// Before Java 22 - awkward static method workaround\nclass ChildOld extends Parent {\n    ChildOld(int value) {\n        super(validatePositive(value));\n    }\n    private static int validatePositive(int v) {\n        if (v < 0) throw new IllegalArgumentException();\n        return v;\n    }\n}\n\n// Java 22 - natural flow\nclass Child extends Parent {\n    Child(int value) {\n        // Validate BEFORE calling super\n        if (value < 0) {\n            throw new IllegalArgumentException(\"Value must be positive\");\n        }\n        super(value);\n    }\n}\n\n// Argument preparation\nclass Email extends Parent {\n    Email(String local, String domain) {\n        // Prepare argument before super()\n        String fullEmail = local + \"@\" + domain;\n        if (!fullEmail.contains(\"@\")) {\n            throw new IllegalArgumentException(\"Invalid email\");\n        }\n        super(fullEmail.hashCode());\n    }\n}\n\n// Record with validation\nrecord Person(String name, int age) {\n    Person {\n        // Statements before this() call to canonical constructor\n        if (age < 0) {\n            System.out.println(\"Adjusting negative age\");\n            age = 0;\n        }\n    }\n}"
        },
        {
          "name": "‚úÖ Foreign Function & Memory API (Final)",
          "text": "**Usage:** Call native libraries and access off-heap memory safely without JNI's complexity and dangers.\n\n**Gains:**\n‚Ä¢ **JNI Replacement:** Modern, safe alternative to Java Native Interface\n‚Ä¢ **4-5x Faster:** Significantly faster than JNI\n‚Ä¢ **Memory Safety:** Managed arenas prevent crashes, throw exceptions instead\n‚Ä¢ **90% Less Code:** Dramatically less boilerplate than JNI\n‚Ä¢ **Native Library Access:** Call C libraries (OpenGL, TensorFlow, OS APIs) directly\n‚Ä¢ **Off-Heap Memory:** Efficient access to native memory for performance-critical code\n‚Ä¢ **Type Safety:** Compile-time checking for foreign function calls\n\n**Use Cases:**\n‚Ä¢ High-performance computing\n‚Ä¢ Game development (OpenGL, Vulkan)\n‚Ä¢ Machine learning (TensorFlow, PyTorch)\n‚Ä¢ OS-specific APIs\n‚Ä¢ Legacy C/C++ library integration",
          "code": "import java.lang.foreign.*;\nimport static java.lang.foreign.ValueLayout.*;\n\n// Allocate and access native memory\ntry (Arena arena = Arena.ofConfined()) {\n    // Allocate 8 bytes off-heap\n    MemorySegment segment = arena.allocate(8);\n    \n    // Write long value\n    segment.set(JAVA_LONG, 0, 123L);\n    \n    // Read long value\n    long value = segment.get(JAVA_LONG, 0);\n    System.out.println(value); // 123\n}\n// Memory automatically freed when arena closes\n\n// Call C library function (e.g., strlen)\nLinker linker = Linker.nativeLinker();\nSymbolLookup stdlib = linker.defaultLookup();\n\n// Find strlen function\nMemorySegment strlenAddr = stdlib.find(\"strlen\").orElseThrow();\n\n// Define function signature: size_t strlen(const char *)\nFunctionDescriptor strlenDesc = FunctionDescriptor.of(\n    JAVA_LONG,  // return type\n    ADDRESS     // parameter type\n);\n\n// Create method handle\nMethodHandle strlen = linker.downcallHandle(\n    strlenAddr,\n    strlenDesc\n);\n\n// Call native strlen\ntry (Arena arena = Arena.ofConfined()) {\n    MemorySegment str = arena.allocateUtf8String(\"Hello\");\n    long length = (long) strlen.invoke(str);\n    System.out.println(length); // 5\n}"
        }
      ]
    }
  ]
}